/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!**************************************!*\
  !*** ../~/webpack/buildin/global.js ***!
  \**************************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanM/NjJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */,
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ../~/rot-js/lib/rot.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {/*\n\tThis is rot.js, the ROguelike Toolkit in JavaScript.\n\tVersion 0.6~dev, generated on Mon Nov 30 10:34:42 CET 2015.\n*/\n/**\n * Add objects for Node.js environment\n */\nglobal.requestAnimationFrame = function(cb) {\n\treturn setTimeout(cb, 1000/60);\n};\n\nglobal.document = {\n\tbody: {\n\t\tappendChild: function(child) {},\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t},\n\tcreateElement: function(type) {\n\t\tvar canvas;\n\t\treturn canvas = {\n\t\t\tgetBoundingClientRect: function() {\n\t\t\t\tvar rect;\n\t\t\t\treturn rect = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetContext: function(type) {\n\t\t\t\tvar context;\n\t\t\t\treturn context = {\n\t\t\t\t\t_termcolor: null,\n\t\t\t\t\tbeginPath: function() {},\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tclearRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawImage: function(a, b, c, d, e, f, g, h, i) {},\n\t\t\t\t\tfill: function() {},\n\t\t\t\t\tfillRect: function(x, y, w, h) {\n\t\t\t\t\t\tif(this._termcolor !== null) {\n\t\t\t\t\t\t\tvar clearCmd = this._termcolor.clearToAnsi(this.fillStyle);\n\t\t\t\t\t\t\tprocess.stdout.write(clearCmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tfillStyle: \"#000\",\n\t\t\t\t\tfillText: function(chs, x, y) {},\n\t\t\t\t\tfont: \"monospace\",\n\t\t\t\t\tlineTo: function(x, y) {},\n\t\t\t\t\tmeasureText: function(ch) {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\treturn result = {\n\t\t\t\t\t\t\twidth: 12\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tmoveTo: function(x, y) {},\n\t\t\t\t\ttextAlign: \"center\",\n\t\t\t\t\ttextBaseline: \"middle\"\n\t\t\t\t};\n\t\t\t},\n\t\t\theight: 0,\n\t\t\tstyle: {\n\t\t\t\tleft: \"100px\",\n\t\t\t\tposition: \"absolute\",\n\t\t\t\ttop: \"100px\",\n\t\t\t\tvisibility: \"hidden\"\n\t\t\t},\n\t\t\twidth: 0\n\t\t};\n\t},\n\tdocumentElement: {\n\t\tscrollLeft: 0,\n\t\tscrollTop: 0\n\t}\n};\n/**\n * @namespace Top-level ROT namespace\n */\nvar ROT = {\n\t/**\n\t * @returns {bool} Is rot.js supported by this browser?\n\t */\n\tisSupported: function() {\n\t\treturn !!(document.createElement(\"canvas\").getContext && Function.prototype.bind);\n\t},\n\n\t/** Default with for display and map generators */\n\tDEFAULT_WIDTH: 80,\n\t/** Default height for display and map generators */\n\tDEFAULT_HEIGHT: 25,\n\n\t/** Directional constants. Ordering is important! */\n\tDIRS: {\n\t\t\"4\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  0]\n\t\t],\n\t\t\"8\": [\n\t\t\t[ 0, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 1,  0],\n\t\t\t[ 1,  1],\n\t\t\t[ 0,  1],\n\t\t\t[-1,  1],\n\t\t\t[-1,  0],\n\t\t\t[-1, -1]\n\t\t],\n\t\t\"6\": [\n\t\t\t[-1, -1],\n\t\t\t[ 1, -1],\n\t\t\t[ 2,  0],\n\t\t\t[ 1,  1],\n\t\t\t[-1,  1],\n\t\t\t[-2,  0]\n\t\t]\n\t},\n\n\t/** Cancel key. */\n\tVK_CANCEL: 3, \n\t/** Help key. */\n\tVK_HELP: 6, \n\t/** Backspace key. */\n\tVK_BACK_SPACE: 8, \n\t/** Tab key. */\n\tVK_TAB: 9, \n\t/** 5 key on Numpad when NumLock is unlocked. Or on Mac, clear key which is positioned at NumLock key. */\n\tVK_CLEAR: 12, \n\t/** Return/enter key on the main keyboard. */\n\tVK_RETURN: 13, \n\t/** Reserved, but not used. */\n\tVK_ENTER: 14, \n\t/** Shift key. */\n\tVK_SHIFT: 16, \n\t/** Control key. */\n\tVK_CONTROL: 17, \n\t/** Alt (Option on Mac) key. */\n\tVK_ALT: 18, \n\t/** Pause key. */\n\tVK_PAUSE: 19, \n\t/** Caps lock. */\n\tVK_CAPS_LOCK: 20, \n\t/** Escape key. */\n\tVK_ESCAPE: 27, \n\t/** Space bar. */\n\tVK_SPACE: 32, \n\t/** Page Up key. */\n\tVK_PAGE_UP: 33, \n\t/** Page Down key. */\n\tVK_PAGE_DOWN: 34, \n\t/** End key. */\n\tVK_END: 35, \n\t/** Home key. */\n\tVK_HOME: 36, \n\t/** Left arrow. */\n\tVK_LEFT: 37, \n\t/** Up arrow. */\n\tVK_UP: 38, \n\t/** Right arrow. */\n\tVK_RIGHT: 39, \n\t/** Down arrow. */\n\tVK_DOWN: 40, \n\t/** Print Screen key. */\n\tVK_PRINTSCREEN: 44, \n\t/** Ins(ert) key. */\n\tVK_INSERT: 45, \n\t/** Del(ete) key. */\n\tVK_DELETE: 46, \n\t/***/\n\tVK_0: 48,\n\t/***/\n\tVK_1: 49,\n\t/***/\n\tVK_2: 50,\n\t/***/\n\tVK_3: 51,\n\t/***/\n\tVK_4: 52,\n\t/***/\n\tVK_5: 53,\n\t/***/\n\tVK_6: 54,\n\t/***/\n\tVK_7: 55,\n\t/***/\n\tVK_8: 56,\n\t/***/\n\tVK_9: 57,\n\t/** Colon (:) key. Requires Gecko 15.0 */\n\tVK_COLON: 58, \n\t/** Semicolon (;) key. */\n\tVK_SEMICOLON: 59, \n\t/** Less-than (<) key. Requires Gecko 15.0 */\n\tVK_LESS_THAN: 60, \n\t/** Equals (=) key. */\n\tVK_EQUALS: 61, \n\t/** Greater-than (>) key. Requires Gecko 15.0 */\n\tVK_GREATER_THAN: 62, \n\t/** Question mark (?) key. Requires Gecko 15.0 */\n\tVK_QUESTION_MARK: 63, \n\t/** Atmark (@) key. Requires Gecko 15.0 */\n\tVK_AT: 64, \n\t/***/\n\tVK_A: 65,\n\t/***/\n\tVK_B: 66,\n\t/***/\n\tVK_C: 67,\n\t/***/\n\tVK_D: 68,\n\t/***/\n\tVK_E: 69,\n\t/***/\n\tVK_F: 70,\n\t/***/\n\tVK_G: 71,\n\t/***/\n\tVK_H: 72,\n\t/***/\n\tVK_I: 73,\n\t/***/\n\tVK_J: 74,\n\t/***/\n\tVK_K: 75,\n\t/***/\n\tVK_L: 76,\n\t/***/\n\tVK_M: 77,\n\t/***/\n\tVK_N: 78,\n\t/***/\n\tVK_O: 79,\n\t/***/\n\tVK_P: 80,\n\t/***/\n\tVK_Q: 81,\n\t/***/\n\tVK_R: 82,\n\t/***/\n\tVK_S: 83,\n\t/***/\n\tVK_T: 84,\n\t/***/\n\tVK_U: 85,\n\t/***/\n\tVK_V: 86,\n\t/***/\n\tVK_W: 87,\n\t/***/\n\tVK_X: 88,\n\t/***/\n\tVK_Y: 89,\n\t/***/\n\tVK_Z: 90,\n\t/***/\n\tVK_CONTEXT_MENU: 93,\n\t/** 0 on the numeric keypad. */\n\tVK_NUMPAD0: 96, \n\t/** 1 on the numeric keypad. */\n\tVK_NUMPAD1: 97, \n\t/** 2 on the numeric keypad. */\n\tVK_NUMPAD2: 98, \n\t/** 3 on the numeric keypad. */\n\tVK_NUMPAD3: 99, \n\t/** 4 on the numeric keypad. */\n\tVK_NUMPAD4: 100, \n\t/** 5 on the numeric keypad. */\n\tVK_NUMPAD5: 101, \n\t/** 6 on the numeric keypad. */\n\tVK_NUMPAD6: 102, \n\t/** 7 on the numeric keypad. */\n\tVK_NUMPAD7: 103, \n\t/** 8 on the numeric keypad. */\n\tVK_NUMPAD8: 104, \n\t/** 9 on the numeric keypad. */\n\tVK_NUMPAD9: 105, \n\t/** * on the numeric keypad. */\n\tVK_MULTIPLY: 106,\n\t/** + on the numeric keypad. */\n\tVK_ADD: 107, \n\t/***/\n\tVK_SEPARATOR: 108,\n\t/** - on the numeric keypad. */\n\tVK_SUBTRACT: 109, \n\t/** Decimal point on the numeric keypad. */\n\tVK_DECIMAL: 110, \n\t/** / on the numeric keypad. */\n\tVK_DIVIDE: 111, \n\t/** F1 key. */\n\tVK_F1: 112, \n\t/** F2 key. */\n\tVK_F2: 113, \n\t/** F3 key. */\n\tVK_F3: 114, \n\t/** F4 key. */\n\tVK_F4: 115, \n\t/** F5 key. */\n\tVK_F5: 116, \n\t/** F6 key. */\n\tVK_F6: 117, \n\t/** F7 key. */\n\tVK_F7: 118, \n\t/** F8 key. */\n\tVK_F8: 119, \n\t/** F9 key. */\n\tVK_F9: 120, \n\t/** F10 key. */\n\tVK_F10: 121, \n\t/** F11 key. */\n\tVK_F11: 122, \n\t/** F12 key. */\n\tVK_F12: 123, \n\t/** F13 key. */\n\tVK_F13: 124, \n\t/** F14 key. */\n\tVK_F14: 125, \n\t/** F15 key. */\n\tVK_F15: 126, \n\t/** F16 key. */\n\tVK_F16: 127, \n\t/** F17 key. */\n\tVK_F17: 128, \n\t/** F18 key. */\n\tVK_F18: 129, \n\t/** F19 key. */\n\tVK_F19: 130, \n\t/** F20 key. */\n\tVK_F20: 131, \n\t/** F21 key. */\n\tVK_F21: 132, \n\t/** F22 key. */\n\tVK_F22: 133, \n\t/** F23 key. */\n\tVK_F23: 134, \n\t/** F24 key. */\n\tVK_F24: 135, \n\t/** Num Lock key. */\n\tVK_NUM_LOCK: 144, \n\t/** Scroll Lock key. */\n\tVK_SCROLL_LOCK: 145, \n\t/** Circumflex (^) key. Requires Gecko 15.0 */\n\tVK_CIRCUMFLEX: 160, \n\t/** Exclamation (!) key. Requires Gecko 15.0 */\n\tVK_EXCLAMATION: 161, \n\t/** Double quote () key. Requires Gecko 15.0 */\n\tVK_DOUBLE_QUOTE: 162, \n\t/** Hash (#) key. Requires Gecko 15.0 */\n\tVK_HASH: 163, \n\t/** Dollar sign ($) key. Requires Gecko 15.0 */\n\tVK_DOLLAR: 164, \n\t/** Percent (%) key. Requires Gecko 15.0 */\n\tVK_PERCENT: 165, \n\t/** Ampersand (&) key. Requires Gecko 15.0 */\n\tVK_AMPERSAND: 166, \n\t/** Underscore (_) key. Requires Gecko 15.0 */\n\tVK_UNDERSCORE: 167, \n\t/** Open parenthesis (() key. Requires Gecko 15.0 */\n\tVK_OPEN_PAREN: 168, \n\t/** Close parenthesis ()) key. Requires Gecko 15.0 */\n\tVK_CLOSE_PAREN: 169, \n\t/* Asterisk (*) key. Requires Gecko 15.0 */\n\tVK_ASTERISK: 170,\n\t/** Plus (+) key. Requires Gecko 15.0 */\n\tVK_PLUS: 171, \n\t/** Pipe (|) key. Requires Gecko 15.0 */\n\tVK_PIPE: 172, \n\t/** Hyphen-US/docs/Minus (-) key. Requires Gecko 15.0 */\n\tVK_HYPHEN_MINUS: 173, \n\t/** Open curly bracket ({) key. Requires Gecko 15.0 */\n\tVK_OPEN_CURLY_BRACKET: 174, \n\t/** Close curly bracket (}) key. Requires Gecko 15.0 */\n\tVK_CLOSE_CURLY_BRACKET: 175, \n\t/** Tilde (~) key. Requires Gecko 15.0 */\n\tVK_TILDE: 176, \n\t/** Comma (,) key. */\n\tVK_COMMA: 188, \n\t/** Period (.) key. */\n\tVK_PERIOD: 190, \n\t/** Slash (/) key. */\n\tVK_SLASH: 191, \n\t/** Back tick (`) key. */\n\tVK_BACK_QUOTE: 192, \n\t/** Open square bracket ([) key. */\n\tVK_OPEN_BRACKET: 219, \n\t/** Back slash (\\) key. */\n\tVK_BACK_SLASH: 220, \n\t/** Close square bracket (]) key. */\n\tVK_CLOSE_BRACKET: 221, \n\t/** Quote (''') key. */\n\tVK_QUOTE: 222, \n\t/** Meta key on Linux, Command key on Mac. */\n\tVK_META: 224, \n\t/** AltGr key on Linux. Requires Gecko 15.0 */\n\tVK_ALTGR: 225, \n\t/** Windows logo key on Windows. Or Super or Hyper key on Linux. Requires Gecko 15.0 */\n\tVK_WIN: 91, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANA: 21, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANGUL: 21, \n\t/** 英数 key on Japanese Mac keyboard. Requires Gecko 15.0 */\n\tVK_EISU: 22, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_JUNJA: 23, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_FINAL: 24, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_HANJA: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_KANJI: 25, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_CONVERT: 28, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_NONCONVERT: 29, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_ACCEPT: 30, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_MODECHANGE: 31, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_SELECT: 41, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_PRINT: 42, \n\t/** Linux support for this keycode was added in Gecko 4.0. */\n\tVK_EXECUTE: 43, \n\t/** Linux support for this keycode was added in Gecko 4.0.\t */\n\tVK_SLEEP: 95 \n};\n/**\n * @namespace\n * Contains text tokenization and breaking routines\n */\nROT.Text = {\n\tRE_COLORS: /%([bc]){([^}]*)}/g,\n\n\t/* token types */\n\tTYPE_TEXT:\t\t0,\n\tTYPE_NEWLINE:\t1,\n\tTYPE_FG:\t\t2,\n\tTYPE_BG:\t\t3,\n\n\t/**\n\t * Measure size of a resulting text block\n\t */\n\tmeasure: function(str, maxWidth) {\n\t\tvar result = {width:0, height:1};\n\t\tvar tokens = this.tokenize(str, maxWidth);\n\t\tvar lineWidth = 0;\n\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase this.TYPE_TEXT:\n\t\t\t\t\tlineWidth += token.value.length;\n\t\t\t\tbreak;\n\n\t\t\t\tcase this.TYPE_NEWLINE:\n\t\t\t\t\tresult.height++;\n\t\t\t\t\tresult.width = Math.max(result.width, lineWidth);\n\t\t\t\t\tlineWidth = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult.width = Math.max(result.width, lineWidth);\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Convert string to a series of a formatting commands\n\t */\n\ttokenize: function(str, maxWidth) {\n\t\tvar result = [];\n\n\t\t/* first tokenization pass - split texts and color formatting commands */\n\t\tvar offset = 0;\n\t\tstr.replace(this.RE_COLORS, function(match, type, name, index) {\n\t\t\t/* string before */\n\t\t\tvar part = str.substring(offset, index);\n\t\t\tif (part.length) {\n\t\t\t\tresult.push({\n\t\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\t\tvalue: part\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* color command */\n\t\t\tresult.push({\n\t\t\t\ttype: (type == \"c\" ? ROT.Text.TYPE_FG : ROT.Text.TYPE_BG),\n\t\t\t\tvalue: name.trim()\n\t\t\t});\n\n\t\t\toffset = index + match.length;\n\t\t\treturn \"\";\n\t\t});\n\n\t\t/* last remaining part */\n\t\tvar part = str.substring(offset);\n\t\tif (part.length) {\n\t\t\tresult.push({\n\t\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\t\tvalue: part\n\t\t\t});\n\t\t}\n\n\t\treturn this._breakLines(result, maxWidth);\n\t},\n\n\t/* insert line breaks into first-pass tokenized data */\n\t_breakLines: function(tokens, maxWidth) {\n\t\tif (!maxWidth) { maxWidth = Infinity; };\n\n\t\tvar i = 0;\n\t\tvar lineLength = 0;\n\t\tvar lastTokenWithSpace = -1;\n\n\t\twhile (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n\t\t\tvar token = tokens[i];\n\t\t\tif (token.type == ROT.Text.TYPE_NEWLINE) { /* reset */\n\t\t\t\tlineLength = 0; \n\t\t\t\tlastTokenWithSpace = -1;\n\t\t\t}\n\t\t\tif (token.type != ROT.Text.TYPE_TEXT) { /* skip non-text tokens */\n\t\t\t\ti++;\n\t\t\t\tcontinue; \n\t\t\t}\n\n\t\t\t/* remove spaces at the beginning of line */\n\t\t\twhile (lineLength == 0 && token.value.charAt(0) == \" \") { token.value = token.value.substring(1); }\n\n\t\t\t/* forced newline? insert two new tokens after this one */\n\t\t\tvar index = token.value.indexOf(\"\\n\");\n\t\t\tif (index != -1) { \n\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true); \n\n\t\t\t\t/* if there are spaces at the end, we must remove them (we do not want the line too long) */\n\t\t\t\tvar arr = token.value.split(\"\");\n\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\ttoken.value = arr.join(\"\");\n\t\t\t}\n\n\t\t\t/* token degenerated? */\n\t\t\tif (!token.value.length) {\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n\n\t\t\t\t/* is it possible to break within this token? */\n\t\t\t\tvar index = -1;\n\t\t\t\twhile (1) {\n\t\t\t\t\tvar nextIndex = token.value.indexOf(\" \", index+1);\n\t\t\t\t\tif (nextIndex == -1) { break; }\n\t\t\t\t\tif (lineLength + nextIndex > maxWidth) { break; }\n\t\t\t\t\tindex = nextIndex;\n\t\t\t\t}\n\n\t\t\t\tif (index != -1) { /* break at space within this one */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, index, true);\n\t\t\t\t} else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n\t\t\t\t\tvar token = tokens[lastTokenWithSpace];\n\t\t\t\t\tvar breakIndex = token.value.lastIndexOf(\" \");\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n\t\t\t\t\ti = lastTokenWithSpace;\n\t\t\t\t} else { /* force break in this token */\n\t\t\t\t\ttoken.value = this._breakInsideToken(tokens, i, maxWidth-lineLength, false);\n\t\t\t\t}\n\n\t\t\t} else { /* line not long, continue */\n\t\t\t\tlineLength += token.value.length;\n\t\t\t\tif (token.value.indexOf(\" \") != -1) { lastTokenWithSpace = i; }\n\t\t\t}\n\t\t\t\n\t\t\ti++; /* advance to next token */\n\t\t}\n\n\n\t\ttokens.push({type: ROT.Text.TYPE_NEWLINE}); /* insert fake newline to fix the last text line */\n\n\t\t/* remove trailing space from text tokens before newlines */\n\t\tvar lastTextToken = null;\n\t\tfor (var i=0;i<tokens.length;i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tswitch (token.type) {\n\t\t\t\tcase ROT.Text.TYPE_TEXT: lastTextToken = token; break;\n\t\t\t\tcase ROT.Text.TYPE_NEWLINE: \n\t\t\t\t\tif (lastTextToken) { /* remove trailing space */\n\t\t\t\t\t\tvar arr = lastTextToken.value.split(\"\");\n\t\t\t\t\t\twhile (arr.length && arr[arr.length-1] == \" \") { arr.pop(); }\n\t\t\t\t\t\tlastTextToken.value = arr.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tlastTextToken = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttokens.pop(); /* remove fake token */\n\n\t\treturn tokens;\n\t},\n\n\t/**\n\t * Create new tokens and insert them into the stream\n\t * @param {object[]} tokens\n\t * @param {int} tokenIndex Token being processed\n\t * @param {int} breakIndex Index within current token's value\n\t * @param {bool} removeBreakChar Do we want to remove the breaking character?\n\t * @returns {string} remaining unbroken token value\n\t */\n\t_breakInsideToken: function(tokens, tokenIndex, breakIndex, removeBreakChar) {\n\t\tvar newBreakToken = {\n\t\t\ttype: ROT.Text.TYPE_NEWLINE\n\t\t}\n\t\tvar newTextToken = {\n\t\t\ttype: ROT.Text.TYPE_TEXT,\n\t\t\tvalue: tokens[tokenIndex].value.substring(breakIndex + (removeBreakChar ? 1 : 0))\n\t\t}\n\t\ttokens.splice(tokenIndex+1, 0, newBreakToken, newTextToken);\n\t\treturn tokens[tokenIndex].value.substring(0, breakIndex);\n\t}\n}\n/**\n * @returns {any} Randomly picked item, null when length=0\n */\nArray.prototype.random = Array.prototype.random || function() {\n\tif (!this.length) { return null; }\n\treturn this[Math.floor(ROT.RNG.getUniform() * this.length)];\n}\n\n/**\n * @returns {array} New array with randomized items\n * FIXME destroys this!\n */\nArray.prototype.randomize = Array.prototype.randomize || function() {\n\tvar result = [];\n\twhile (this.length) {\n\t\tvar index = this.indexOf(this.random());\n\t\tresult.push(this.splice(index, 1)[0]);\n\t}\n\treturn result;\n}\n/**\n * Always positive modulus\n * @param {int} n Modulus\n * @returns {int} this modulo n\n */\nNumber.prototype.mod = Number.prototype.mod || function(n) {\n\treturn ((this%n)+n)%n;\n}\n/**\n * @returns {string} First letter capitalized\n */\nString.prototype.capitalize = String.prototype.capitalize || function() {\n\treturn this.charAt(0).toUpperCase() + this.substring(1);\n}\n\n/** \n * Left pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.lpad = String.prototype.lpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn s+this;\n}\n\n/** \n * Right pad\n * @param {string} [character=\"0\"]\n * @param {int} [count=2]\n */\nString.prototype.rpad = String.prototype.rpad || function(character, count) {\n\tvar ch = character || \"0\";\n\tvar cnt = count || 2;\n\n\tvar s = \"\";\n\twhile (s.length < (cnt - this.length)) { s += ch; }\n\ts = s.substring(0, cnt-this.length);\n\treturn this+s;\n}\n\n/**\n * Format a string in a flexible way. Scans for %s strings and replaces them with arguments. List of patterns is modifiable via String.format.map.\n * @param {string} template\n * @param {any} [argv]\n */\nString.format = String.format || function(template) {\n\tvar map = String.format.map;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar replacer = function(match, group1, group2, index) {\n\t\tif (template.charAt(index-1) == \"%\") { return match.substring(1); }\n\t\tif (!args.length) { return match; }\n\t\tvar obj = args[0];\n\n\t\tvar group = group1 || group2;\n\t\tvar parts = group.split(\",\");\n\t\tvar name = parts.shift();\n\t\tvar method = map[name.toLowerCase()];\n\t\tif (!method) { return match; }\n\n\t\tvar obj = args.shift();\n\t\tvar replaced = obj[method].apply(obj, parts);\n\n\t\tvar first = name.charAt(0);\n\t\tif (first != first.toLowerCase()) { replaced = replaced.capitalize(); }\n\n\t\treturn replaced;\n\t}\n\treturn template.replace(/%(?:([a-z]+)|(?:{([^}]+)}))/gi, replacer);\n}\n\nString.format.map = String.format.map || {\n\t\"s\": \"toString\"\n}\n\n/**\n * Convenience shortcut to String.format(this)\n */\nString.prototype.format = String.prototype.format || function() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(this);\n\treturn String.format.apply(String, args);\n}\n\nif (!Object.create) {  \n\t/**\n\t * ES5 Object.create\n\t */\n\tObject.create = function(o) {  \n\t\tvar tmp = function() {};\n\t\ttmp.prototype = o;\n\t\treturn new tmp();\n\t};  \n}  \n/**\n * Sets prototype of this function to an instance of parent function\n * @param {function} parent\n */\nFunction.prototype.extend = Function.prototype.extend || function(parent) {\n\tthis.prototype = Object.create(parent.prototype);\n\tthis.prototype.constructor = this;\n\treturn this;\n}\nif (typeof window != \"undefined\") {\n\twindow.requestAnimationFrame =\n\t\twindow.requestAnimationFrame\n\t\t|| window.mozRequestAnimationFrame\n\t\t|| window.webkitRequestAnimationFrame\n\t\t|| window.oRequestAnimationFrame\n\t\t|| window.msRequestAnimationFrame\n\t\t|| function(cb) { return setTimeout(cb, 1000/60); };\n\n\twindow.cancelAnimationFrame =\n\t\twindow.cancelAnimationFrame\n\t\t|| window.mozCancelAnimationFrame\n\t\t|| window.webkitCancelAnimationFrame\n\t\t|| window.oCancelAnimationFrame\n\t\t|| window.msCancelAnimationFrame\n\t\t|| function(id) { return clearTimeout(id); };\n}\n/**\n * @class Visual map display\n * @param {object} [options]\n * @param {int} [options.width=ROT.DEFAULT_WIDTH]\n * @param {int} [options.height=ROT.DEFAULT_HEIGHT]\n * @param {int} [options.fontSize=15]\n * @param {string} [options.fontFamily=\"monospace\"]\n * @param {string} [options.fontStyle=\"\"] bold/italic/none/both\n * @param {string} [options.fg=\"#ccc\"]\n * @param {string} [options.bg=\"#000\"]\n * @param {float} [options.spacing=1]\n * @param {float} [options.border=0]\n * @param {string} [options.layout=\"rect\"]\n * @param {bool} [options.forceSquareRatio=false]\n * @param {int} [options.tileWidth=32]\n * @param {int} [options.tileHeight=32]\n * @param {object} [options.tileMap={}]\n * @param {image} [options.tileSet=null]\n * @param {image} [options.tileColorize=false]\n */\nROT.Display = function(options) {\n\tvar canvas = document.createElement(\"canvas\");\n\tthis._context = canvas.getContext(\"2d\");\n\tthis._data = {};\n\tthis._dirty = false; /* false = nothing, true = all, object = dirty cells */\n\tthis._options = {};\n\tthis._backend = null;\n\t\n\tvar defaultOptions = {\n\t\twidth: ROT.DEFAULT_WIDTH,\n\t\theight: ROT.DEFAULT_HEIGHT,\n\t\ttranspose: false,\n\t\tlayout: \"rect\",\n\t\tfontSize: 15,\n\t\tspacing: 1,\n\t\tborder: 0,\n\t\tforceSquareRatio: false,\n\t\tfontFamily: \"monospace\",\n\t\tfontStyle: \"\",\n\t\tfg: \"#ccc\",\n\t\tbg: \"#000\",\n\t\ttileWidth: 32,\n\t\ttileHeight: 32,\n\t\ttileMap: {},\n\t\ttileSet: null,\n\t\ttileColorize: false,\n\t\ttermColor: \"xterm\"\n\t};\n\tfor (var p in options) { defaultOptions[p] = options[p]; }\n\tthis.setOptions(defaultOptions);\n\tthis.DEBUG = this.DEBUG.bind(this);\n\n\tthis._tick = this._tick.bind(this);\n\trequestAnimationFrame(this._tick);\n}\n\n/**\n * Debug helper, ideal as a map generator callback. Always bound to this.\n * @param {int} x\n * @param {int} y\n * @param {int} what\n */\nROT.Display.prototype.DEBUG = function(x, y, what) {\n\tvar colors = [this._options.bg, this._options.fg];\n\tthis.draw(x, y, null, null, colors[what % colors.length]);\n}\n\n/**\n * Clear the whole display (cover it with background color)\n */\nROT.Display.prototype.clear = function() {\n\tthis._data = {};\n\tthis._dirty = true;\n}\n\n/**\n * @see ROT.Display\n */\nROT.Display.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options.width || options.height || options.fontSize || options.fontFamily || options.spacing || options.layout) {\n\t\tif (options.layout) { \n\t\t\tthis._backend = new ROT.Display[options.layout.capitalize()](this._context);\n\t\t}\n\n\t\tvar font = (this._options.fontStyle ? this._options.fontStyle + \" \" : \"\") + this._options.fontSize + \"px \" + this._options.fontFamily;\n\t\tthis._context.font = font;\n\t\tthis._backend.compute(this._options);\n\t\tthis._context.font = font;\n\t\tthis._context.textAlign = \"center\";\n\t\tthis._context.textBaseline = \"middle\";\n\t\tthis._dirty = true;\n\t}\n\treturn this;\n}\n\n/**\n * Returns currently set options\n * @returns {object} Current options object \n */\nROT.Display.prototype.getOptions = function() {\n\treturn this._options;\n}\n\n/**\n * Returns the DOM node of this display\n * @returns {node} DOM node\n */\nROT.Display.prototype.getContainer = function() {\n\treturn this._context.canvas;\n}\n\n/**\n * Compute the maximum width/height to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int[2]} cellWidth,cellHeight\n */\nROT.Display.prototype.computeSize = function(availWidth, availHeight) {\n\treturn this._backend.computeSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Compute the maximum font size to fit into a set of given constraints\n * @param {int} availWidth Maximum allowed pixel width\n * @param {int} availHeight Maximum allowed pixel height\n * @returns {int} fontSize\n */\nROT.Display.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn this._backend.computeFontSize(availWidth, availHeight, this._options);\n}\n\n/**\n * Convert a DOM event (mouse or touch) to map coordinates. Uses first touch for multi-touch.\n * @param {Event} e event\n * @returns {int[2]} -1 for values outside of the canvas\n */\nROT.Display.prototype.eventToPosition = function(e) {\n\tif (e.touches) {\n\t\tvar x = e.touches[0].clientX;\n\t\tvar y = e.touches[0].clientY;\n\t} else {\n\t\tvar x = e.clientX;\n\t\tvar y = e.clientY;\n\t}\n\n\tvar rect = this._context.canvas.getBoundingClientRect();\n\tx -= rect.left;\n\ty -= rect.top;\n\t\n\tif (x < 0 || y < 0 || x >= this._context.canvas.width || y >= this._context.canvas.height) { return [-1, -1]; }\n\n\treturn this._backend.eventToPosition(x, y);\n}\n\n/**\n * @param {int} x\n * @param {int} y\n * @param {string || string[]} ch One or more chars (will be overlapping themselves)\n * @param {string} [fg] foreground color\n * @param {string} [bg] background color\n */\nROT.Display.prototype.draw = function(x, y, ch, fg, bg) {\n\tif (!fg) { fg = this._options.fg; }\n\tif (!bg) { bg = this._options.bg; }\n\tthis._data[x+\",\"+y] = [x, y, ch, fg, bg];\n\t\n\tif (this._dirty === true) { return; } /* will already redraw everything */\n\tif (!this._dirty) { this._dirty = {}; } /* first! */\n\tthis._dirty[x+\",\"+y] = true;\n}\n\n/**\n * Draws a text at given position. Optionally wraps at a maximum length. Currently does not work with hex layout.\n * @param {int} x\n * @param {int} y\n * @param {string} text May contain color/background format specifiers, %c{name}/%b{name}, both optional. %c{}/%b{} resets to default.\n * @param {int} [maxWidth] wrap at what width?\n * @returns {int} lines drawn\n */\nROT.Display.prototype.drawText = function(x, y, text, maxWidth) {\n\tvar fg = null;\n\tvar bg = null;\n\tvar cx = x;\n\tvar cy = y;\n\tvar lines = 1;\n\tif (!maxWidth) { maxWidth = this._options.width-x; }\n\n\tvar tokens = ROT.Text.tokenize(text, maxWidth);\n\n\twhile (tokens.length) { /* interpret tokenized opcode stream */\n\t\tvar token = tokens.shift();\n\t\tswitch (token.type) {\n\t\t\tcase ROT.Text.TYPE_TEXT:\n\t\t\t\tvar isSpace = false, isPrevSpace = false, isFullWidth = false, isPrevFullWidth = false;\n\t\t\t\tfor (var i=0;i<token.value.length;i++) {\n\t\t\t\t\tvar cc = token.value.charCodeAt(i);\n\t\t\t\t\tvar c = token.value.charAt(i);\n\t\t\t\t\t// Assign to `true` when the current char is full-width.\n\t\t\t\t\tisFullWidth = (cc > 0xff && cc < 0xff61) || (cc > 0xffdc && cc < 0xffe8) && cc > 0xffee;\n\t\t\t\t\t// Current char is space, whatever full-width or half-width both are OK.\n\t\t\t\t\tisSpace = (c.charCodeAt(0) == 0x20 || c.charCodeAt(0) == 0x3000);\n\t\t\t\t\t// The previous char is full-width and\n\t\t\t\t\t// current char is nether half-width nor a space.\n\t\t\t\t\tif (isPrevFullWidth && !isFullWidth && !isSpace) { cx++; } // add an extra position\n\t\t\t\t\t// The current char is full-width and\n\t\t\t\t\t// the previous char is not a space.\n\t\t\t\t\tif(isFullWidth && !isPrevSpace) { cx++; } // add an extra position\n\t\t\t\t\tthis.draw(cx++, cy, c, fg, bg);\n\t\t\t\t\tisPrevSpace = isSpace;\n\t\t\t\t\tisPrevFullWidth = isFullWidth;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_FG:\n\t\t\t\tfg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_BG:\n\t\t\t\tbg = token.value || null;\n\t\t\tbreak;\n\n\t\t\tcase ROT.Text.TYPE_NEWLINE:\n\t\t\t\tcx = x;\n\t\t\t\tcy++;\n\t\t\t\tlines++\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n/**\n * Timer tick: update dirty parts\n */\nROT.Display.prototype._tick = function() {\n\trequestAnimationFrame(this._tick);\n\n\tif (!this._dirty) { return; }\n\n\tif (this._dirty === true) { /* draw all */\n\t\tthis._context.fillStyle = this._options.bg;\n\t\tthis._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n\t\tfor (var id in this._data) { /* redraw cached data */\n\t\t\tthis._draw(id, false);\n\t\t}\n\n\t} else { /* draw only dirty */\n\t\tfor (var key in this._dirty) {\n\t\t\tthis._draw(key, true);\n\t\t}\n\t}\n\n\tthis._dirty = false;\n}\n\n/**\n * @param {string} key What to draw\n * @param {bool} clearBefore Is it necessary to clean before?\n */\nROT.Display.prototype._draw = function(key, clearBefore) {\n\tvar data = this._data[key];\n\tif (data[4] != this._options.bg) { clearBefore = true; }\n\n\tthis._backend.draw(data, clearBefore);\n}\n/**\n * @class Abstract display backend module\n * @private\n */\nROT.Display.Backend = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Backend.prototype.compute = function(options) {\n}\n\nROT.Display.Backend.prototype.draw = function(data, clearBefore) {\n}\n\nROT.Display.Backend.prototype.computeSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.computeFontSize = function(availWidth, availHeight) {\n}\n\nROT.Display.Backend.prototype.eventToPosition = function(x, y) {\n}\n/**\n * @class Rectangular backend\n * @private\n */\nROT.Display.Rect = function(context) {\n\tROT.Display.Backend.call(this, context);\n\t\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._canvasCache = {};\n\tthis._options = {};\n}\nROT.Display.Rect.extend(ROT.Display.Backend);\n\nROT.Display.Rect.cache = false;\n\nROT.Display.Rect.prototype.compute = function(options) {\n\tthis._canvasCache = {};\n\tthis._options = options;\n\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._spacingX = Math.ceil(options.spacing * charWidth);\n\tthis._spacingY = Math.ceil(options.spacing * options.fontSize);\n\n\tif (this._options.forceSquareRatio) {\n\t\tthis._spacingX = this._spacingY = Math.max(this._spacingX, this._spacingY);\n\t}\n\n\tthis._context.canvas.width = options.width * this._spacingX;\n\tthis._context.canvas.height = options.height * this._spacingY;\n}\n\nROT.Display.Rect.prototype.draw = function(data, clearBefore) {\n\tif (this.constructor.cache) {\n\t\tthis._drawWithCache(data, clearBefore);\n\t} else {\n\t\tthis._drawNoCache(data, clearBefore);\n\t}\n}\n\nROT.Display.Rect.prototype._drawWithCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar hash = \"\"+ch+fg+bg;\n\tif (hash in this._canvasCache) {\n\t\tvar canvas = this._canvasCache[hash];\n\t} else {\n\t\tvar b = this._options.border;\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tcanvas.width = this._spacingX;\n\t\tcanvas.height = this._spacingY;\n\t\tctx.fillStyle = bg;\n\t\tctx.fillRect(b, b, canvas.width-b, canvas.height-b);\n\t\t\n\t\tif (ch) {\n\t\t\tctx.fillStyle = fg;\n\t\t\tctx.font = this._context.font;\n\t\t\tctx.textAlign = \"center\";\n\t\t\tctx.textBaseline = \"middle\";\n\n\t\t\tvar chars = [].concat(ch);\n\t\t\tfor (var i=0;i<chars.length;i++) {\n\t\t\t\tctx.fillText(chars[i], this._spacingX/2, Math.ceil(this._spacingY/2));\n\t\t\t}\n\t\t}\n\t\tthis._canvasCache[hash] = canvas;\n\t}\n\t\n\tthis._context.drawImage(canvas, x*this._spacingX, y*this._spacingY);\n}\n\nROT.Display.Rect.prototype._drawNoCache = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tif (clearBefore) { \n\t\tvar b = this._options.border;\n\t\tthis._context.fillStyle = bg;\n\t\tthis._context.fillRect(x*this._spacingX + b, y*this._spacingY + b, this._spacingX - b, this._spacingY - b);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], (x+0.5) * this._spacingX, Math.ceil((y+0.5) * this._spacingY));\n\t}\n}\n\nROT.Display.Rect.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._spacingX);\n\tvar height = Math.floor(availHeight / this._spacingY);\n\treturn [width, height];\n}\n\nROT.Display.Rect.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar boxWidth = Math.floor(availWidth / this._options.width);\n\tvar boxHeight = Math.floor(availHeight / this._options.height);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\t\t\n\tvar widthFraction = ratio * boxHeight / boxWidth;\n\tif (widthFraction > 1) { /* too wide with current aspect ratio */\n\t\tboxHeight = Math.floor(boxHeight / widthFraction);\n\t}\n\treturn Math.floor(boxHeight / this._options.spacing);\n}\n\nROT.Display.Rect.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._spacingX), Math.floor(y/this._spacingY)];\n}\n/**\n * @class Hexagonal backend\n * @private\n */\nROT.Display.Hex = function(context) {\n\tROT.Display.Backend.call(this, context);\n\n\tthis._spacingX = 0;\n\tthis._spacingY = 0;\n\tthis._hexSize = 0;\n\tthis._options = {};\n}\nROT.Display.Hex.extend(ROT.Display.Backend);\n\nROT.Display.Hex.prototype.compute = function(options) {\n\tthis._options = options;\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar charWidth = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._hexSize = Math.floor(options.spacing * (options.fontSize + charWidth/Math.sqrt(3)) / 2);\n\tthis._spacingX = this._hexSize * Math.sqrt(3) / 2;\n\tthis._spacingY = this._hexSize * 1.5;\n\n\tif (options.transpose) {\n\t\tvar xprop = \"height\";\n\t\tvar yprop = \"width\";\n\t} else {\n\t\tvar xprop = \"width\";\n\t\tvar yprop = \"height\";\n\t}\n\tthis._context.canvas[xprop] = Math.ceil( (options.width + 1) * this._spacingX );\n\tthis._context.canvas[yprop] = Math.ceil( (options.height - 1) * this._spacingY + 2*this._hexSize );\n}\n\nROT.Display.Hex.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar px = [\n\t\t(x+1) * this._spacingX,\n\t\ty * this._spacingY + this._hexSize\n\t];\n\tif (this._options.transpose) { px.reverse(); }\n\n\tif (clearBefore) { \n\t\tthis._context.fillStyle = bg;\n\t\tthis._fill(px[0], px[1]);\n\t}\n\t\n\tif (!ch) { return; }\n\n\tthis._context.fillStyle = fg;\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tthis._context.fillText(chars[i], px[0], Math.ceil(px[1]));\n\t}\n}\n\nROT.Display.Hex.prototype.computeSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar width = Math.floor(availWidth / this._spacingX) - 1;\n\tvar height = Math.floor((availHeight - 2*this._hexSize) / this._spacingY + 1);\n\treturn [width, height];\n}\n\nROT.Display.Hex.prototype.computeFontSize = function(availWidth, availHeight) {\n\tif (this._options.transpose) {\n\t\tavailWidth += availHeight;\n\t\tavailHeight = availWidth - availHeight;\n\t\tavailWidth -= availHeight;\n\t}\n\n\tvar hexSizeWidth = 2*availWidth / ((this._options.width+1) * Math.sqrt(3)) - 1;\n\tvar hexSizeHeight = availHeight / (2 + 1.5*(this._options.height-1));\n\tvar hexSize = Math.min(hexSizeWidth, hexSizeHeight);\n\n\t/* compute char ratio */\n\tvar oldFont = this._context.font;\n\tthis._context.font = \"100px \" + this._options.fontFamily;\n\tvar width = Math.ceil(this._context.measureText(\"W\").width);\n\tthis._context.font = oldFont;\n\tvar ratio = width / 100;\n\n\thexSize = Math.floor(hexSize)+1; /* closest larger hexSize */\n\n\t/* FIXME char size computation does not respect transposed hexes */\n\tvar fontSize = 2*hexSize / (this._options.spacing * (1 + ratio / Math.sqrt(3)));\n\n\t/* closest smaller fontSize */\n\treturn Math.ceil(fontSize)-1;\n}\n\nROT.Display.Hex.prototype.eventToPosition = function(x, y) {\n\tif (this._options.transpose) {\n\t\tx += y;\n\t\ty = x-y;\n\t\tx -= y;\n\t\tvar prop = \"width\";\n\t} else {\n\t\tvar prop = \"height\";\n\t}\n\tvar size = this._context.canvas[prop] / this._options[prop];\n\ty = Math.floor(y/size);\n\n\tif (y.mod(2)) { /* odd row */\n\t\tx -= this._spacingX;\n\t\tx = 1 + 2*Math.floor(x/(2*this._spacingX));\n\t} else {\n\t\tx = 2*Math.floor(x/(2*this._spacingX));\n\t}\n\t\n\treturn [x, y];\n}\n\n/**\n * Arguments are pixel values. If \"transposed\" mode is enabled, then these two are already swapped.\n */\nROT.Display.Hex.prototype._fill = function(cx, cy) {\n\tvar a = this._hexSize;\n\tvar b = this._options.border;\n\t\n\tthis._context.beginPath();\n\n\tif (this._options.transpose) {\n\t\tthis._context.moveTo(cx-a+b,\tcy);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy+this._spacingX-b);\n\t\tthis._context.lineTo(cx+a-b,\tcy);\n\t\tthis._context.lineTo(cx+a/2-b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a/2+b,\tcy-this._spacingX+b);\n\t\tthis._context.lineTo(cx-a+b,\tcy);\n\t} else {\n\t\tthis._context.moveTo(cx,\t\t\t\t\tcy-a+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx+this._spacingX-b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy+a-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy+a/2-b);\n\t\tthis._context.lineTo(cx-this._spacingX+b,\tcy-a/2+b);\n\t\tthis._context.lineTo(cx,\t\t\t\t\tcy-a+b);\n\t}\n\tthis._context.fill();\n}\n/**\n * @class Tile backend\n * @private\n */\nROT.Display.Tile = function(context) {\n\tROT.Display.Rect.call(this, context);\n\t\n\tthis._options = {};\n\tthis._colorCanvas = document.createElement(\"canvas\");\n}\nROT.Display.Tile.extend(ROT.Display.Rect);\n\nROT.Display.Tile.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._context.canvas.width = options.width * options.tileWidth;\n\tthis._context.canvas.height = options.height * options.tileHeight;\n\tthis._colorCanvas.width = options.tileWidth;\n\tthis._colorCanvas.height = options.tileHeight;\n}\n\nROT.Display.Tile.prototype.draw = function(data, clearBefore) {\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\tvar tileWidth = this._options.tileWidth;\n\tvar tileHeight = this._options.tileHeight;\n\n\tif (clearBefore) {\n\t\tif (this._options.tileColorize) {\n\t\t\tthis._context.clearRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t} else {\n\t\t\tthis._context.fillStyle = bg;\n\t\t\tthis._context.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\t\t}\n\t}\n\n\tif (!ch) { return; }\n\n\tvar chars = [].concat(ch);\n\tfor (var i=0;i<chars.length;i++) {\n\t\tvar tile = this._options.tileMap[chars[i]];\n\t\tif (!tile) { throw new Error(\"Char '\" + chars[i] + \"' not found in tileMap\"); }\n\t\t\n\t\tif (this._options.tileColorize) { /* apply colorization */\n\t\t\tvar canvas = this._colorCanvas;\n\t\t\tvar context = canvas.getContext(\"2d\");\n\t\t\tcontext.clearRect(0, 0, tileWidth, tileHeight);\n\n\t\t\tcontext.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\t0, 0, tileWidth, tileHeight\n\t\t\t);\n\n\t\t\tif (fg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = fg;\n\t\t\t\tcontext.globalCompositeOperation = \"source-atop\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tif (bg != \"transparent\") {\n\t\t\t\tcontext.fillStyle = bg;\n\t\t\t\tcontext.globalCompositeOperation = \"destination-over\";\n\t\t\t\tcontext.fillRect(0, 0, tileWidth, tileHeight);\n\t\t\t}\n\n\t\t\tthis._context.drawImage(canvas, x*tileWidth, y*tileHeight, tileWidth, tileHeight);\n\n\t\t} else { /* no colorizing, easy */\n\t\t\tthis._context.drawImage(\n\t\t\t\tthis._options.tileSet,\n\t\t\t\ttile[0], tile[1], tileWidth, tileHeight,\n\t\t\t\tx*tileWidth, y*tileHeight, tileWidth, tileHeight\n\t\t\t);\n\t\t}\n\t}\n}\n\nROT.Display.Tile.prototype.computeSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.tileWidth);\n\tvar height = Math.floor(availHeight / this._options.tileHeight);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.computeFontSize = function(availWidth, availHeight) {\n\tvar width = Math.floor(availWidth / this._options.width);\n\tvar height = Math.floor(availHeight / this._options.height);\n\treturn [width, height];\n}\n\nROT.Display.Tile.prototype.eventToPosition = function(x, y) {\n\treturn [Math.floor(x/this._options.tileWidth), Math.floor(y/this._options.tileHeight)];\n}\n/**\n * @namespace\n * This code is an implementation of Alea algorithm; (C) 2010 Johannes Baagøe.\n * Alea is licensed according to the http://en.wikipedia.org/wiki/MIT_License.\n */\nROT.RNG = {\n\t/**\n\t * @returns {number} \n\t */\n\tgetSeed: function() {\n\t\treturn this._seed;\n\t},\n\n\t/**\n\t * @param {number} seed Seed the number generator\n\t */\n\tsetSeed: function(seed) {\n\t\tseed = (seed < 1 ? 1/seed : seed);\n\n\t\tthis._seed = seed;\n\t\tthis._s0 = (seed >>> 0) * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s1 = seed * this._frac;\n\n\t\tseed = (seed*69069 + 1) >>> 0;\n\t\tthis._s2 = seed * this._frac;\n\n\t\tthis._c = 1;\n\t\treturn this;\n\t},\n\n\t/**\n\t * @returns {float} Pseudorandom value [0,1), uniformly distributed\n\t */\n\tgetUniform: function() {\n\t\tvar t = 2091639 * this._s0 + this._c * this._frac;\n\t\tthis._s0 = this._s1;\n\t\tthis._s1 = this._s2;\n\t\tthis._c = t | 0;\n\t\tthis._s2 = t - this._c;\n\t\treturn this._s2;\n\t},\n\n\t/**\n\t * @param {int} lowerBound The lower end of the range to return a value from, inclusive\n\t * @param {int} upperBound The upper end of the range to return a value from, inclusive\n\t * @returns {int} Pseudorandom value [lowerBound, upperBound], using ROT.RNG.getUniform() to distribute the value\n\t */\n\tgetUniformInt: function(lowerBound, upperBound) {\n\t\tvar max = Math.max(lowerBound, upperBound);\n\t\tvar min = Math.min(lowerBound, upperBound);\n\t\treturn Math.floor(this.getUniform() * (max - min + 1)) + min;\n\t},\n\n\t/**\n\t * @param {float} [mean=0] Mean value\n\t * @param {float} [stddev=1] Standard deviation. ~95% of the absolute values will be lower than 2*stddev.\n\t * @returns {float} A normally distributed pseudorandom value\n\t */\n\tgetNormal: function(mean, stddev) {\n\t\tdo {\n\t\t\tvar u = 2*this.getUniform()-1;\n\t\t\tvar v = 2*this.getUniform()-1;\n\t\t\tvar r = u*u + v*v;\n\t\t} while (r > 1 || r == 0);\n\n\t\tvar gauss = u * Math.sqrt(-2*Math.log(r)/r);\n\t\treturn (mean || 0) + gauss*(stddev || 1);\n\t},\n\n\t/**\n\t * @returns {int} Pseudorandom value [1,100] inclusive, uniformly distributed\n\t */\n\tgetPercentage: function() {\n\t\treturn 1 + Math.floor(this.getUniform()*100);\n\t},\n\t\n\t/**\n\t * @param {object} data key=whatever, value=weight (relative probability)\n\t * @returns {string} whatever\n\t */\n\tgetWeightedValue: function(data) {\n\t\tvar total = 0;\n\t\t\n\t\tfor (var id in data) {\n\t\t\ttotal += data[id];\n\t\t}\n\t\tvar random = this.getUniform()*total;\n\t\t\n\t\tvar part = 0;\n\t\tfor (var id in data) {\n\t\t\tpart += data[id];\n\t\t\tif (random < part) { return id; }\n\t\t}\n\n\t\t// If by some floating-point annoyance we have\n\t\t// random >= total, just return the last id.\n\t\treturn id;\n\t},\n\n\t/**\n\t * Get RNG state. Useful for storing the state and re-setting it via setState.\n\t * @returns {?} Internal state\n\t */\n\tgetState: function() {\n\t\treturn [this._s0, this._s1, this._s2, this._c];\n\t},\n\n\t/**\n\t * Set a previously retrieved state.\n\t * @param {?} state\n\t */\n\tsetState: function(state) {\n\t\tthis._s0 = state[0];\n\t\tthis._s1 = state[1];\n\t\tthis._s2 = state[2];\n\t\tthis._c  = state[3];\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns a cloned RNG\n\t */\n\tclone: function() {\n\t\tvar clone = Object.create(this);\n\t\tclone.setState(this.getState());\n\t\treturn clone;\n\t},\n\n\t_s0: 0,\n\t_s1: 0,\n\t_s2: 0,\n\t_c: 0,\n\t_frac: 2.3283064365386963e-10 /* 2^-32 */\n}\n\nROT.RNG.setSeed(Date.now());\n/**\n * @class (Markov process)-based string generator. \n * Copied from a <a href=\"http://www.roguebasin.roguelikedevelopment.org/index.php?title=Names_from_a_high_order_Markov_Process_and_a_simplified_Katz_back-off_scheme\">RogueBasin article</a>. \n * Offers configurable order and prior.\n * @param {object} [options]\n * @param {bool} [options.words=false] Use word mode?\n * @param {int} [options.order=3]\n * @param {float} [options.prior=0.001]\n */\nROT.StringGenerator = function(options) {\n\tthis._options = {\n\t\twords: false,\n\t\torder: 3,\n\t\tprior: 0.001\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._boundary = String.fromCharCode(0);\n\tthis._suffix = this._boundary;\n\tthis._prefix = [];\n\tfor (var i=0;i<this._options.order;i++) { this._prefix.push(this._boundary); }\n\n\tthis._priorValues = {};\n\tthis._priorValues[this._boundary] = this._options.prior;\n\n\tthis._data = {};\n}\n\n/**\n * Remove all learning data\n */\nROT.StringGenerator.prototype.clear = function() {\n\tthis._data = {};\n\tthis._priorValues = {};\n}\n\n/**\n * @returns {string} Generated string\n */\nROT.StringGenerator.prototype.generate = function() {\n\tvar result = [this._sample(this._prefix)];\n\twhile (result[result.length-1] != this._boundary) {\n\t\tresult.push(this._sample(result));\n\t}\n\treturn this._join(result.slice(0, -1));\n}\n\n/**\n * Observe (learn) a string from a training set\n */\nROT.StringGenerator.prototype.observe = function(string) {\n\tvar tokens = this._split(string);\n\n\tfor (var i=0; i<tokens.length; i++) {\n\t\tthis._priorValues[tokens[i]] = this._options.prior;\n\t}\n\n\ttokens = this._prefix.concat(tokens).concat(this._suffix); /* add boundary symbols */\n\n\tfor (var i=this._options.order; i<tokens.length; i++) {\n\t\tvar context = tokens.slice(i-this._options.order, i);\n\t\tvar event = tokens[i];\n\t\tfor (var j=0; j<context.length; j++) {\n\t\t\tvar subcontext = context.slice(j);\n\t\t\tthis._observeEvent(subcontext, event);\n\t\t}\n\t}\n}\n\nROT.StringGenerator.prototype.getStats = function() {\n\tvar parts = [];\n\n\tvar priorCount = 0;\n\tfor (var p in this._priorValues) { priorCount++; }\n\tpriorCount--; /* boundary */\n\tparts.push(\"distinct samples: \" + priorCount);\n\n\tvar dataCount = 0;\n\tvar eventCount = 0;\n\tfor (var p in this._data) { \n\t\tdataCount++; \n\t\tfor (var key in this._data[p]) {\n\t\t\teventCount++;\n\t\t}\n\t}\n\tparts.push(\"dictionary size (contexts): \" + dataCount);\n\tparts.push(\"dictionary size (events): \" + eventCount);\n\n\treturn parts.join(\", \");\n}\n\n/**\n * @param {string}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._split = function(str) {\n\treturn str.split(this._options.words ? /\\s+/ : \"\");\n}\n\n/**\n * @param {string[]}\n * @returns {string} \n */\nROT.StringGenerator.prototype._join = function(arr) {\n\treturn arr.join(this._options.words ? \" \" : \"\");\n}\n\n/**\n * @param {string[]} context\n * @param {string} event\n */\nROT.StringGenerator.prototype._observeEvent = function(context, event) {\n\tvar key = this._join(context);\n\tif (!(key in this._data)) { this._data[key] = {}; }\n\tvar data = this._data[key];\n\n\tif (!(event in data)) { data[event] = 0; }\n\tdata[event]++;\n}\n\n/**\n * @param {string[]}\n * @returns {string}\n */\nROT.StringGenerator.prototype._sample = function(context) {\n\tcontext = this._backoff(context);\n\tvar key = this._join(context);\n\tvar data = this._data[key];\n\n\tvar available = {};\n\n\tif (this._options.prior) {\n\t\tfor (var event in this._priorValues) { available[event] = this._priorValues[event]; }\n\t\tfor (var event in data) { available[event] += data[event]; }\n\t} else { \n\t\tavailable = data;\n\t}\n\n\treturn ROT.RNG.getWeightedValue(available);\n}\n\n/**\n * @param {string[]}\n * @returns {string[]}\n */\nROT.StringGenerator.prototype._backoff = function(context) {\n\tif (context.length > this._options.order) {\n\t\tcontext = context.slice(-this._options.order);\n\t} else if (context.length < this._options.order) {\n\t\tcontext = this._prefix.slice(0, this._options.order - context.length).concat(context);\n\t}\n\n\twhile (!(this._join(context) in this._data) && context.length > 0) { context = context.slice(1); }\n\n\treturn context;\n}\n/**\n * @class Generic event queue: stores events and retrieves them based on their time\n */\nROT.EventQueue = function() {\n\tthis._time = 0;\n\tthis._events = [];\n\tthis._eventTimes = [];\n}\n\n/**\n * @returns {number} Elapsed time\n */\nROT.EventQueue.prototype.getTime = function() {\n\treturn this._time;\n}\n\n/**\n * Clear all scheduled events\n */\nROT.EventQueue.prototype.clear = function() {\n\tthis._events = [];\n\tthis._eventTimes = [];\n\treturn this;\n}\n\n/**\n * @param {?} event\n * @param {number} time\n */\nROT.EventQueue.prototype.add = function(event, time) {\n\tvar index = this._events.length;\n\tfor (var i=0;i<this._eventTimes.length;i++) {\n\t\tif (this._eventTimes[i] > time) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis._events.splice(index, 0, event);\n\tthis._eventTimes.splice(index, 0, time);\n}\n\n/**\n * Locates the nearest event, advances time if necessary. Returns that event and removes it from the queue.\n * @returns {? || null} The event previously added by addEvent, null if no event available\n */\nROT.EventQueue.prototype.get = function() {\n\tif (!this._events.length) { return null; }\n\n\tvar time = this._eventTimes.splice(0, 1)[0];\n\tif (time > 0) { /* advance */\n\t\tthis._time += time;\n\t\tfor (var i=0;i<this._eventTimes.length;i++) { this._eventTimes[i] -= time; }\n\t}\n\n\treturn this._events.splice(0, 1)[0];\n}\n\n/**\n * Remove an event from the queue\n * @param {?} event\n * @returns {bool} success?\n */\nROT.EventQueue.prototype.remove = function(event) {\n\tvar index = this._events.indexOf(event);\n\tif (index == -1) { return false }\n\tthis._remove(index);\n\treturn true;\n}\n\n/**\n * Remove an event from the queue\n * @param {int} index\n */\nROT.EventQueue.prototype._remove = function(index) {\n\tthis._events.splice(index, 1);\n\tthis._eventTimes.splice(index, 1);\n}\n/**\n * @class Abstract scheduler\n */\nROT.Scheduler = function() {\n\tthis._queue = new ROT.EventQueue();\n\tthis._repeat = [];\n\tthis._current = null;\n}\n\n/**\n * @see ROT.EventQueue#getTime\n */\nROT.Scheduler.prototype.getTime = function() {\n\treturn this._queue.getTime();\n}\n\n/**\n * @param {?} item\n * @param {bool} repeat\n */\nROT.Scheduler.prototype.add = function(item, repeat) {\n\tif (repeat) { this._repeat.push(item); }\n\treturn this;\n}\n\n/**\n * Clear all items\n */\nROT.Scheduler.prototype.clear = function() {\n\tthis._queue.clear();\n\tthis._repeat = [];\n\tthis._current = null;\n\treturn this;\n}\n\n/**\n * Remove a previously added item\n * @param {?} item\n * @returns {bool} successful?\n */\nROT.Scheduler.prototype.remove = function(item) {\n\tvar result = this._queue.remove(item);\n\n\tvar index = this._repeat.indexOf(item);\n\tif (index != -1) { this._repeat.splice(index, 1); }\n\n\tif (this._current == item) { this._current = null; }\n\n\treturn result;\n}\n\n/**\n * Schedule next item\n * @returns {?}\n */\nROT.Scheduler.prototype.next = function() {\n\tthis._current = this._queue.get();\n\treturn this._current;\n}\n/**\n * @class Simple fair scheduler (round-robin style)\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Simple = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Simple.extend(ROT.Scheduler);\n\n/**\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Simple.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 0);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Simple.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 0);\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Speed-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Speed = function() {\n\tROT.Scheduler.call(this);\n}\nROT.Scheduler.Speed.extend(ROT.Scheduler);\n\n/**\n * @param {object} item anything with \"getSpeed\" method\n * @param {bool} repeat\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Speed.prototype.add = function(item, repeat) {\n\tthis._queue.add(item, 1/item.getSpeed());\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Speed.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, 1/this._current.getSpeed());\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n/**\n * @class Action-based scheduler\n * @augments ROT.Scheduler\n */\nROT.Scheduler.Action = function() {\n\tROT.Scheduler.call(this);\n\tthis._defaultDuration = 1; /* for newly added */\n\tthis._duration = this._defaultDuration; /* for this._current */\n}\nROT.Scheduler.Action.extend(ROT.Scheduler);\n\n/**\n * @param {object} item\n * @param {bool} repeat\n * @param {number} [time=1]\n * @see ROT.Scheduler#add\n */\nROT.Scheduler.Action.prototype.add = function(item, repeat, time) {\n\tthis._queue.add(item, time || this._defaultDuration);\n\treturn ROT.Scheduler.prototype.add.call(this, item, repeat);\n}\n\nROT.Scheduler.Action.prototype.clear = function() {\n\tthis._duration = this._defaultDuration;\n\treturn ROT.Scheduler.prototype.clear.call(this);\n}\n\nROT.Scheduler.Action.prototype.remove = function(item) {\n\tif (item == this._current) { this._duration = this._defaultDuration; }\n\treturn ROT.Scheduler.prototype.remove.call(this, item);\n}\n\n/**\n * @see ROT.Scheduler#next\n */\nROT.Scheduler.Action.prototype.next = function() {\n\tif (this._current && this._repeat.indexOf(this._current) != -1) {\n\t\tthis._queue.add(this._current, this._duration || this._defaultDuration);\n\t\tthis._duration = this._defaultDuration;\n\t}\n\treturn ROT.Scheduler.prototype.next.call(this);\n}\n\n/**\n * Set duration for the active item\n */\nROT.Scheduler.Action.prototype.setDuration = function(time) {\n\tif (this._current) { this._duration = time; }\n\treturn this;\n}\n/**\n * @class Asynchronous main loop\n * @param {ROT.Scheduler} scheduler\n */\nROT.Engine = function(scheduler) {\n\tthis._scheduler = scheduler;\n\tthis._lock = 1;\n}\n\n/**\n * Start the main loop. When this call returns, the loop is locked.\n */\nROT.Engine.prototype.start = function() {\n\treturn this.unlock();\n}\n\n/**\n * Interrupt the engine by an asynchronous action\n */\nROT.Engine.prototype.lock = function() {\n\tthis._lock++;\n\treturn this;\n}\n\n/**\n * Resume execution (paused by a previous lock)\n */\nROT.Engine.prototype.unlock = function() {\n\tif (!this._lock) { throw new Error(\"Cannot unlock unlocked engine\"); }\n\tthis._lock--;\n\n\twhile (!this._lock) {\n\t\tvar actor = this._scheduler.next();\n\t\tif (!actor) { return this.lock(); } /* no actors */\n\t\tvar result = actor.act();\n\t\tif (result && result.then) { /* actor returned a \"thenable\", looks like a Promise */\n\t\t\tthis.lock();\n\t\t\tresult.then(this.unlock.bind(this));\n\t\t}\n\t}\n\n\treturn this;\n}\n/**\n * @class Base map generator\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n */\nROT.Map = function(width, height) {\n\tthis._width = width || ROT.DEFAULT_WIDTH;\n\tthis._height = height || ROT.DEFAULT_HEIGHT;\n};\n\nROT.Map.prototype.create = function(callback) {}\n\nROT.Map.prototype._fillMap = function(value) {\n\tvar map = [];\n\tfor (var i=0;i<this._width;i++) {\n\t\tmap.push([]);\n\t\tfor (var j=0;j<this._height;j++) { map[i].push(value); }\n\t}\n\treturn map;\n}\n/**\n * @class Simple empty rectangular room\n * @augments ROT.Map\n */\nROT.Map.Arena = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.Arena.extend(ROT.Map);\n\nROT.Map.Arena.prototype.create = function(callback) {\n\tvar w = this._width-1;\n\tvar h = this._height-1;\n\tfor (var i=0;i<=w;i++) {\n\t\tfor (var j=0;j<=h;j++) {\n\t\t\tvar empty = (i && j && i<w && j<h);\n\t\t\tcallback(i, j, empty ? 0 : 1);\n\t\t}\n\t}\n\treturn this;\n}\n/**\n * @class Recursively divided maze, http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method\n * @augments ROT.Map\n */\nROT.Map.DividedMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._stack = [];\n}\nROT.Map.DividedMaze.extend(ROT.Map);\n\nROT.Map.DividedMaze.prototype.create = function(callback) {\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tthis._map = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tthis._map.push([]);\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tvar border = (i == 0 || j == 0 || i+1 == w || j+1 == h);\n\t\t\tthis._map[i].push(border ? 1 : 0);\n\t\t}\n\t}\n\t\n\tthis._stack = [\n\t\t[1, 1, w-2, h-2]\n\t];\n\tthis._process();\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tfor (var j=0;j<h;j++) {\n\t\t\tcallback(i, j, this._map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.DividedMaze.prototype._process = function() {\n\twhile (this._stack.length) {\n\t\tvar room = this._stack.shift(); /* [left, top, right, bottom] */\n\t\tthis._partitionRoom(room);\n\t}\n}\n\nROT.Map.DividedMaze.prototype._partitionRoom = function(room) {\n\tvar availX = [];\n\tvar availY = [];\n\t\n\tfor (var i=room[0]+1;i<room[2];i++) {\n\t\tvar top = this._map[i][room[1]-1];\n\t\tvar bottom = this._map[i][room[3]+1];\n\t\tif (top && bottom && !(i % 2)) { availX.push(i); }\n\t}\n\t\n\tfor (var j=room[1]+1;j<room[3];j++) {\n\t\tvar left = this._map[room[0]-1][j];\n\t\tvar right = this._map[room[2]+1][j];\n\t\tif (left && right && !(j % 2)) { availY.push(j); }\n\t}\n\n\tif (!availX.length || !availY.length) { return; }\n\n\tvar x = availX.random();\n\tvar y = availY.random();\n\t\n\tthis._map[x][y] = 1;\n\t\n\tvar walls = [];\n\t\n\tvar w = []; walls.push(w); /* left part */\n\tfor (var i=room[0]; i<x; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* right part */\n\tfor (var i=x+1; i<=room[2]; i++) { \n\t\tthis._map[i][y] = 1;\n\t\tw.push([i, y]); \n\t}\n\n\tvar w = []; walls.push(w); /* top part */\n\tfor (var j=room[1]; j<y; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\n\tvar w = []; walls.push(w); /* bottom part */\n\tfor (var j=y+1; j<=room[3]; j++) { \n\t\tthis._map[x][j] = 1;\n\t\tw.push([x, j]); \n\t}\n\t\t\n\tvar solid = walls.random();\n\tfor (var i=0;i<walls.length;i++) {\n\t\tvar w = walls[i];\n\t\tif (w == solid) { continue; }\n\t\t\n\t\tvar hole = w.random();\n\t\tthis._map[hole[0]][hole[1]] = 0;\n\t}\n\n\tthis._stack.push([room[0], room[1], x-1, y-1]); /* left top */\n\tthis._stack.push([x+1, room[1], room[2], y-1]); /* right top */\n\tthis._stack.push([room[0], y+1, x-1, room[3]]); /* left bottom */\n\tthis._stack.push([x+1, y+1, room[2], room[3]]); /* right bottom */\n}\n/**\n * @class Icey's Maze generator\n * See http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze for explanation\n * @augments ROT.Map\n */\nROT.Map.IceyMaze = function(width, height, regularity) {\n\tROT.Map.call(this, width, height);\n\tthis._regularity = regularity || 0;\n}\nROT.Map.IceyMaze.extend(ROT.Map);\n\nROT.Map.IceyMaze.prototype.create = function(callback) {\n\tvar width = this._width;\n\tvar height = this._height;\n\t\n\tvar map = this._fillMap(1);\n\t\n\twidth -= (width % 2 ? 1 : 2);\n\theight -= (height % 2 ? 1 : 2);\n\n\tvar cx = 0;\n\tvar cy = 0;\n\tvar nx = 0;\n\tvar ny = 0;\n\n\tvar done = 0;\n\tvar blocked = false;\n\tvar dirs = [\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0],\n\t\t[0, 0]\n\t];\n\tdo {\n\t\tcx = 1 + 2*Math.floor(ROT.RNG.getUniform()*(width-1) / 2);\n\t\tcy = 1 + 2*Math.floor(ROT.RNG.getUniform()*(height-1) / 2);\n\n\t\tif (!done) { map[cx][cy] = 0; }\n\t\t\n\t\tif (!map[cx][cy]) {\n\t\t\tthis._randomize(dirs);\n\t\t\tdo {\n\t\t\t\tif (Math.floor(ROT.RNG.getUniform()*(this._regularity+1)) == 0) { this._randomize(dirs); }\n\t\t\t\tblocked = true;\n\t\t\t\tfor (var i=0;i<4;i++) {\n\t\t\t\t\tnx = cx + dirs[i][0]*2;\n\t\t\t\t\tny = cy + dirs[i][1]*2;\n\t\t\t\t\tif (this._isFree(map, nx, ny, width, height)) {\n\t\t\t\t\t\tmap[nx][ny] = 0;\n\t\t\t\t\t\tmap[cx + dirs[i][0]][cy + dirs[i][1]] = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcx = nx;\n\t\t\t\t\t\tcy = ny;\n\t\t\t\t\t\tblocked = false;\n\t\t\t\t\t\tdone++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!blocked);\n\t\t}\n\t} while (done+1 < width*height/4);\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\tthis._map = null;\n\treturn this;\n}\n\nROT.Map.IceyMaze.prototype._randomize = function(dirs) {\n\tfor (var i=0;i<4;i++) {\n\t\tdirs[i][0] = 0;\n\t\tdirs[i][1] = 0;\n\t}\n\t\n\tswitch (Math.floor(ROT.RNG.getUniform()*4)) {\n\t\tcase 0:\n\t\t\tdirs[0][0] = -1; dirs[1][0] = 1;\n\t\t\tdirs[2][1] = -1; dirs[3][1] = 1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdirs[3][0] = -1; dirs[2][0] = 1;\n\t\t\tdirs[1][1] = -1; dirs[0][1] = 1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdirs[2][0] = -1; dirs[3][0] = 1;\n\t\t\tdirs[0][1] = -1; dirs[1][1] = 1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdirs[1][0] = -1; dirs[0][0] = 1;\n\t\t\tdirs[3][1] = -1; dirs[2][1] = 1;\n\t\tbreak;\n\t}\n}\n\nROT.Map.IceyMaze.prototype._isFree = function(map, x, y, width, height) {\n\tif (x < 1 || y < 1 || x >= width || y >= height) { return false; }\n\treturn map[x][y];\n}\n/**\n * @class Maze generator - Eller's algorithm\n * See http://homepages.cwi.nl/~tromp/maze.html for explanation\n * @augments ROT.Map\n */\nROT.Map.EllerMaze = function(width, height) {\n\tROT.Map.call(this, width, height);\n}\nROT.Map.EllerMaze.extend(ROT.Map);\n\nROT.Map.EllerMaze.prototype.create = function(callback) {\n\tvar map = this._fillMap(1);\n\tvar w = Math.ceil((this._width-2)/2);\n\t\n\tvar rand = 9/24;\n\t\n\tvar L = [];\n\tvar R = [];\n\t\n\tfor (var i=0;i<w;i++) {\n\t\tL.push(i);\n\t\tR.push(i);\n\t}\n\tL.push(w-1); /* fake stop-block at the right side */\n\n\tfor (var j=1;j+3<this._height;j+=2) {\n\t\t/* one row */\n\t\tfor (var i=0;i<w;i++) {\n\t\t\t/* cell coords (will be always empty) */\n\t\t\tvar x = 2*i+1;\n\t\t\tvar y = j;\n\t\t\tmap[x][y] = 0;\n\t\t\t\n\t\t\t/* right connection */\n\t\t\tif (i != L[i+1] && ROT.RNG.getUniform() > rand) {\n\t\t\t\tthis._addToList(i, L, R);\n\t\t\t\tmap[x+1][y] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t/* bottom connection */\n\t\t\tif (i != L[i] && ROT.RNG.getUniform() > rand) {\n\t\t\t\t/* remove connection */\n\t\t\t\tthis._removeFromList(i, L, R);\n\t\t\t} else {\n\t\t\t\t/* create connection */\n\t\t\t\tmap[x][y+1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* last row */\n\tfor (var i=0;i<w;i++) {\n\t\t/* cell coords (will be always empty) */\n\t\tvar x = 2*i+1;\n\t\tvar y = j;\n\t\tmap[x][y] = 0;\n\t\t\n\t\t/* right connection */\n\t\tif (i != L[i+1] && (i == L[i] || ROT.RNG.getUniform() > rand)) {\n\t\t\t/* dig right also if the cell is separated, so it gets connected to the rest of maze */\n\t\t\tthis._addToList(i, L, R);\n\t\t\tmap[x+1][y] = 0;\n\t\t}\n\t\t\n\t\tthis._removeFromList(i, L, R);\n\t}\n\t\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tcallback(i, j, map[i][j]);\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Remove \"i\" from its list\n */\nROT.Map.EllerMaze.prototype._removeFromList = function(i, L, R) {\n\tR[L[i]] = R[i];\n\tL[R[i]] = L[i];\n\tR[i] = i;\n\tL[i] = i;\n}\n\n/**\n * Join lists with \"i\" and \"i+1\"\n */\nROT.Map.EllerMaze.prototype._addToList = function(i, L, R) {\n\tR[L[i+1]] = R[i];\n\tL[R[i]] = L[i+1];\n\tR[i] = i+1;\n\tL[i+1] = i;\n}\n/**\n * @class Cellular automaton map generator\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.born] List of neighbor counts for a new cell to be born in empty space\n * @param {int[]} [options.survive] List of neighbor counts for an existing  cell to survive\n * @param {int} [options.topology] Topology 4 or 6 or 8\n */\nROT.Map.Cellular = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\tthis._options = {\n\t\tborn: [5, 6, 7, 8],\n\t\tsurvive: [4, 5, 6, 7, 8],\n\t\ttopology: 8,\n\t\tconnected: false\n\t};\n\tthis.setOptions(options);\n\t\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tthis._map = this._fillMap(0);\n}\nROT.Map.Cellular.extend(ROT.Map);\n\n/**\n * Fill the map with random values\n * @param {float} probability Probability for a cell to become alive; 0 = all empty, 1 = all full\n */\nROT.Map.Cellular.prototype.randomize = function(probability) {\n\tfor (var i=0;i<this._width;i++) {\n\t\tfor (var j=0;j<this._height;j++) {\n\t\t\tthis._map[i][j] = (ROT.RNG.getUniform() < probability ? 1 : 0);\n\t\t}\n\t}\n\treturn this;\n}\n\n/**\n * Change options.\n * @see ROT.Map.Cellular\n */\nROT.Map.Cellular.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n}\n\nROT.Map.Cellular.prototype.set = function(x, y, value) {\n\tthis._map[x][y] = value;\n}\n\nROT.Map.Cellular.prototype.create = function(callback) {\n\tvar newMap = this._fillMap(0);\n\tvar born = this._options.born;\n\tvar survive = this._options.survive;\n\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\n\t\t\tvar cur = this._map[i][j];\n\t\t\tvar ncount = this._getNeighbors(i, j);\n\t\t\t\n\t\t\tif (cur && survive.indexOf(ncount) != -1) { /* survive */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t} else if (!cur && born.indexOf(ncount) != -1) { /* born */\n\t\t\t\tnewMap[i][j] = 1;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tthis._map = newMap;\n\n\tif (this._options.connected) { this._completeMaze(); } // optionally connect every space\n\n\tif (!callback) { return; }\n\n\tfor (var j=0;j<this._height;j++) {\n\t\tvar widthStep = 1;\n\t\tvar widthStart = 0;\n\t\tif (this._options.topology == 6) { \n\t\t\twidthStep = 2;\n\t\t\twidthStart = j%2;\n\t\t}\n\t\tfor (var i=widthStart; i<this._width; i+=widthStep) {\n\t\t\tcallback(i, j, newMap[i][j]);\n\t\t}\n\t}\n}\n\n/**\n * Get neighbor count at [i,j] in this._map\n */\nROT.Map.Cellular.prototype._getNeighbors = function(cx, cy) {\n\tvar result = 0;\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (x < 0 || x >= this._width || x < 0 || y >= this._width) { continue; }\n\t\tresult += (this._map[x][y] == 1 ? 1 : 0);\n\t}\n\t\n\treturn result;\n}\n\n/**\n * Make sure every non-wall space is accessible.\n */\nROT.Map.Cellular.prototype._completeMaze = function() {\n\tvar allFreeSpace = [];\n\tvar notConnected = {};\n\t// find all free space\n\tfor (var x = 0; x < this._width; x++) {\n\t\tfor (var y = 0; y < this._height; y++) {\n\t\t\tif (this._freeSpace(x, y)) {\n\t\t\t\tvar p = [x, y];\n\t\t\t\tnotConnected[this._pointKey(p)] = p;\n\t\t\t\tallFreeSpace.push([x, y]);\n\t\t\t}\n\t\t}\n\t}\n\tvar start = allFreeSpace[ROT.RNG.getUniformInt(0, allFreeSpace.length - 1)];\n\n\tvar key = this._pointKey(start);\n\tvar connected = {};\n\tconnected[key] = start;\n\tdelete notConnected[key]\n\n\t// find what's connected to the starting point\n\tthis._findConnected(connected, notConnected, [start]);\n\n\twhile (Object.keys(notConnected).length > 0) {\n\n\t\t// find two points from notConnected to connected\n\t\tvar p = this._getFromTo(connected, notConnected);\n\t\tvar from = p[0]; // notConnected\n\t\tvar to = p[1]; // connected\n\n\t\t// find everything connected to the starting point\n\t\tvar local = {};\n\t\tlocal[this._pointKey(from)] = from;\n\t\tthis._findConnected(local, notConnected, [from], true);\n\n\t\t// connect to a connected square\n\t\tthis._tunnelToConnected(to, from, connected, notConnected);\n\n\t\t// now all of local is connected\n\t\tfor (var k in local) {\n\t\t\tvar pp = local[k];\n\t\t\tthis._map[pp[0]][pp[1]] = 0;\n\t\t\tconnected[k] = pp;\n\t\t\tdelete notConnected[k];\n\t\t}\n\t}\n}\n\n/**\n * Find random points to connect. Search for the closest point in the larger space. \n * This is to minimize the length of the passage while maintaining good performance.\n */\nROT.Map.Cellular.prototype._getFromTo = function(connected, notConnected) {\n\tvar from, to, d;\n\tvar connectedKeys = Object.keys(connected);\n\tvar notConnectedKeys = Object.keys(notConnected);\n\tfor (var i = 0; i < 5; i++) {\n\t\tif (connectedKeys.length < notConnectedKeys.length) {\n\t\t\tvar keys = connectedKeys;\n\t\t\tto = connected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tfrom = this._getClosest(to, notConnected);\n\t\t} else {\n\t\t\tvar keys = notConnectedKeys;\n\t\t\tfrom = notConnected[keys[ROT.RNG.getUniformInt(0, keys.length - 1)]]\n\t\t\tto = this._getClosest(from, connected);\n\t\t}\n\t\td = (from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]);\n\t\tif (d < 64) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// console.log(\">>> connected=\" + to + \" notConnected=\" + from + \" dist=\" + d);\n\treturn [from, to];\n}\n\nROT.Map.Cellular.prototype._getClosest = function(point, space) {\n\tvar minPoint = null;\n\tvar minDist = null;\n\tfor (k in space) {\n\t\tvar p = space[k];\n\t\tvar d = (p[0] - point[0]) * (p[0] - point[0]) + (p[1] - point[1]) * (p[1] - point[1]);\n\t\tif (minDist == null || d < minDist) {\n\t\t\tminDist = d;\n\t\t\tminPoint = p;\n\t\t}\n\t}\n\treturn minPoint;\n}\n\nROT.Map.Cellular.prototype._findConnected = function(connected, notConnected, stack, keepNotConnected) {\n\twhile(stack.length > 0) {\n\t\tvar p = stack.splice(0, 1)[0];\n\t\tvar tests = [\n\t\t\t[p[0] + 1, p[1]],\n\t\t\t[p[0] - 1, p[1]],\n\t\t\t[p[0],     p[1] + 1],\n\t\t\t[p[0],     p[1] - 1]\n\t\t];\n\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\tvar key = this._pointKey(tests[i]);\n\t\t\tif (connected[key] == null && this._freeSpace(tests[i][0], tests[i][1])) {\n\t\t\t\tconnected[key] = tests[i];\n\t\t\t\tif (!keepNotConnected) {\n\t\t\t\t\tdelete notConnected[key];\n\t\t\t\t}\n\t\t\t\tstack.push(tests[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Cellular.prototype._tunnelToConnected = function(to, from, connected, notConnected) {\n\tvar key = this._pointKey(from);\n\tvar a, b;\n\tif (from[0] < to[0]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var xx = a[0]; xx <= b[0]; xx++) {\n\t\tthis._map[xx][a[1]] = 0;\n\t\tvar p = [xx, a[1]];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n\n\t// x is now fixed\n\tvar x = b[0];\n\n\tif (from[1] < to[1]) {\n\t\ta = from;\n\t\tb = to;\n\t} else {\n\t\ta = to;\n\t\tb = from;\n\t}\n\tfor (var yy = a[1]; yy < b[1]; yy++) {\n\t\tthis._map[x][yy] = 0;\n\t\tvar p = [x, yy];\n\t\tvar pkey = this._pointKey(p);\n\t\tconnected[pkey] = p;\n\t\tdelete notConnected[pkey];\n\t}\n}\n\nROT.Map.Cellular.prototype._freeSpace = function(x, y) {\n\treturn x >= 0 && x < this._width && y >= 0 && y < this._height && this._map[x][y] != 1;\n}\n\nROT.Map.Cellular.prototype._pointKey = function(p) {\n\treturn p[0] + \".\" + p[1];\n}\n\n/**\n * @class Dungeon map: has rooms and corridors\n * @augments ROT.Map\n */\nROT.Map.Dungeon = function(width, height) {\n\tROT.Map.call(this, width, height);\n\tthis._rooms = []; /* list of all rooms */\n\tthis._corridors = [];\n}\nROT.Map.Dungeon.extend(ROT.Map);\n\n/**\n * Get all generated rooms\n * @returns {ROT.Map.Feature.Room[]}\n */\nROT.Map.Dungeon.prototype.getRooms = function() {\n\treturn this._rooms;\n}\n\n/**\n * Get all generated corridors\n * @returns {ROT.Map.Feature.Corridor[]}\n */\nROT.Map.Dungeon.prototype.getCorridors = function() {\n\treturn this._corridors;\n}\n/**\n * @class Random dungeon generator using human-like digging patterns.\n * Heavily based on Mike Anderson's ideas from the \"Tyrant\" algo, mentioned at \n * http://www.roguebasin.roguelikedevelopment.org/index.php?title=Dungeon-Building_Algorithm.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Digger = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\t\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\tcorridorLength: [3, 10], /* corridor minimum and maximum length */\n\t\tdugPercentage: 0.2, /* we stop after this percentage of level area has been dug out */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\tthis._features = {\n\t\t\"Room\": 4,\n\t\t\"Corridor\": 4\n\t}\n\tthis._featureAttempts = 20; /* how many times do we try to create a feature on a suitable wall */\n\tthis._walls = {}; /* these are available for digging */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n\tthis._priorityWallCallback = this._priorityWallCallback.bind(this);\n}\nROT.Map.Digger.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map\n * @see ROT.Map#create\n */\nROT.Map.Digger.prototype.create = function(callback) {\n\tthis._rooms = [];\n\tthis._corridors = [];\n\tthis._map = this._fillMap(1);\n\tthis._walls = {};\n\tthis._dug = 0;\n\tvar area = (this._width-2) * (this._height-2);\n\n\tthis._firstRoom();\n\t\n\tvar t1 = Date.now();\n\n\tdo {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { break; }\n\n\t\t/* find a good wall */\n\t\tvar wall = this._findWall();\n\t\tif (!wall) { break; } /* no more walls */\n\t\t\n\t\tvar parts = wall.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tvar dir = this._getDiggingDirection(x, y);\n\t\tif (!dir) { continue; } /* this wall is not suitable */\n\t\t\n//\t\tconsole.log(\"wall\", x, y);\n\n\t\t/* try adding a feature */\n\t\tvar featureAttempts = 0;\n\t\tdo {\n\t\t\tfeatureAttempts++;\n\t\t\tif (this._tryFeature(x, y, dir[0], dir[1])) { /* feature added */\n\t\t\t\t//if (this._rooms.length + this._corridors.length == 2) { this._rooms[0].addDoor(x, y); } /* first room oficially has doors */\n\t\t\t\tthis._removeSurroundingWalls(x, y);\n\t\t\t\tthis._removeSurroundingWalls(x-dir[0], y-dir[1]);\n\t\t\t\tbreak; \n\t\t\t}\n\t\t} while (featureAttempts < this._featureAttempts);\n\t\t\n\t\tvar priorityWalls = 0;\n\t\tfor (var id in this._walls) { \n\t\t\tif (this._walls[id] > 1) { priorityWalls++; }\n\t\t}\n\n\t} while (this._dug/area < this._options.dugPercentage || priorityWalls); /* fixme number of priority walls */\n\n\tthis._addDoors();\n\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis._walls = {};\n\tthis._map = null;\n\n\treturn this;\n}\n\nROT.Map.Digger.prototype._digCallback = function(x, y, value) {\n\tif (value == 0 || value == 2) { /* empty */\n\t\tthis._map[x][y] = 0;\n\t\tthis._dug++;\n\t} else { /* wall */\n\t\tthis._walls[x+\",\"+y] = 1;\n\t}\n}\n\nROT.Map.Digger.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Digger.prototype._priorityWallCallback = function(x, y) {\n\tthis._walls[x+\",\"+y] = 2;\n}\n\nROT.Map.Digger.prototype._firstRoom = function() {\n\tvar cx = Math.floor(this._width/2);\n\tvar cy = Math.floor(this._height/2);\n\tvar room = ROT.Map.Feature.Room.createRandomCenter(cx, cy, this._options);\n\tthis._rooms.push(room);\n\troom.create(this._digCallback);\n}\n\n/**\n * Get a suitable wall\n */\nROT.Map.Digger.prototype._findWall = function() {\n\tvar prio1 = [];\n\tvar prio2 = [];\n\tfor (var id in this._walls) {\n\t\tvar prio = this._walls[id];\n\t\tif (prio == 2) { \n\t\t\tprio2.push(id); \n\t\t} else {\n\t\t\tprio1.push(id);\n\t\t}\n\t}\n\t\n\tvar arr = (prio2.length ? prio2 : prio1);\n\tif (!arr.length) { return null; } /* no walls :/ */\n\t\n\tvar id = arr.random();\n\tdelete this._walls[id];\n\n\treturn id;\n}\n\n/**\n * Tries adding a feature\n * @returns {bool} was this a successful try?\n */\nROT.Map.Digger.prototype._tryFeature = function(x, y, dx, dy) {\n\tvar feature = ROT.RNG.getWeightedValue(this._features);\n\tfeature = ROT.Map.Feature[feature].createRandomAt(x, y, dx, dy, this._options);\n\t\n\tif (!feature.isValid(this._isWallCallback, this._canBeDugCallback)) {\n//\t\tconsole.log(\"not valid\");\n//\t\tfeature.debug();\n\t\treturn false;\n\t}\n\t\n\tfeature.create(this._digCallback);\n//\tfeature.debug();\n\n\tif (feature instanceof ROT.Map.Feature.Room) { this._rooms.push(feature); }\n\tif (feature instanceof ROT.Map.Feature.Corridor) { \n\t\tfeature.createPriorityWalls(this._priorityWallCallback);\n\t\tthis._corridors.push(feature); \n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Digger.prototype._removeSurroundingWalls = function(cx, cy) {\n\tvar deltas = ROT.DIRS[4];\n\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t\tvar x = cx + 2*delta[0];\n\t\tvar y = cy + 2*delta[1];\n\t\tdelete this._walls[x+\",\"+y];\n\t}\n}\n\n/**\n * Returns vector in \"digging\" direction, or false, if this does not exist (or is not unique)\n */\nROT.Map.Digger.prototype._getDiggingDirection = function(cx, cy) {\n\tif (cx <= 0 || cy <= 0 || cx >= this._width - 1 || cy >= this._height - 1) { return null; }\n\n\tvar result = null;\n\tvar deltas = ROT.DIRS[4];\n\t\n\tfor (var i=0;i<deltas.length;i++) {\n\t\tvar delta = deltas[i];\n\t\tvar x = cx + delta[0];\n\t\tvar y = cy + delta[1];\n\t\t\n\t\tif (!this._map[x][y]) { /* there already is another empty neighbor! */\n\t\t\tif (result) { return null; }\n\t\t\tresult = delta;\n\t\t}\n\t}\n\t\n\t/* no empty neighbor */\n\tif (!result) { return null; }\n\t\n\treturn [-result[0], -result[1]];\n}\n\n/**\n * Find empty spaces surrounding rooms, and apply doors.\n */\nROT.Map.Digger.prototype._addDoors = function() {\n\tvar data = this._map;\n\tvar isWallCallback = function(x, y) {\n\t\treturn (data[x][y] == 1);\n\t}\n\tfor (var i = 0; i < this._rooms.length; i++ ) {\n\t\tvar room = this._rooms[i];\n\t\troom.clearDoors();\n\t\troom.addDoors(isWallCallback);\n\t}\n}\n/**\n * @class Dungeon generator which tries to fill the space evenly. Generates independent rooms and tries to connect them.\n * @augments ROT.Map.Dungeon\n */\nROT.Map.Uniform = function(width, height, options) {\n\tROT.Map.Dungeon.call(this, width, height);\n\n\tthis._options = {\n\t\troomWidth: [3, 9], /* room minimum and maximum width */\n\t\troomHeight: [3, 5], /* room minimum and maximum height */\n\t\troomDugPercentage: 0.1, /* we stop after this percentage of level area has been dug out by rooms */\n\t\ttimeLimit: 1000 /* we stop after this much time has passed (msec) */\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._roomAttempts = 20; /* new room is created N-times until is considered as impossible to generate */\n\tthis._corridorAttempts = 20; /* corridors are tried N-times until the level is considered as impossible to connect */\n\n\tthis._connected = []; /* list of already connected rooms */\n\tthis._unconnected = []; /* list of remaining unconnected rooms */\n\t\n\tthis._digCallback = this._digCallback.bind(this);\n\tthis._canBeDugCallback = this._canBeDugCallback.bind(this);\n\tthis._isWallCallback = this._isWallCallback.bind(this);\n}\nROT.Map.Uniform.extend(ROT.Map.Dungeon);\n\n/**\n * Create a map. If the time limit has been hit, returns null.\n * @see ROT.Map#create\n */\nROT.Map.Uniform.prototype.create = function(callback) {\n\tvar t1 = Date.now();\n\twhile (1) {\n\t\tvar t2 = Date.now();\n\t\tif (t2 - t1 > this._options.timeLimit) { return null; } /* time limit! */\n\t\n\t\tthis._map = this._fillMap(1);\n\t\tthis._dug = 0;\n\t\tthis._rooms = [];\n\t\tthis._unconnected = [];\n\t\tthis._generateRooms();\n\t\tif (this._rooms.length < 2) { continue; }\n\t\tif (this._generateCorridors()) { break; }\n\t}\n\t\n\tif (callback) {\n\t\tfor (var i=0;i<this._width;i++) {\n\t\t\tfor (var j=0;j<this._height;j++) {\n\t\t\t\tcallback(i, j, this._map[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\n/**\n * Generates a suitable amount of rooms\n */\nROT.Map.Uniform.prototype._generateRooms = function() {\n\tvar w = this._width-2;\n\tvar h = this._height-2;\n\n\tdo {\n\t\tvar room = this._generateRoom();\n\t\tif (this._dug/(w*h) > this._options.roomDugPercentage) { break; } /* achieved requested amount of free space */\n\t} while (room);\n\n\t/* either enough rooms, or not able to generate more of them :) */\n}\n\n/**\n * Try to generate one room\n */\nROT.Map.Uniform.prototype._generateRoom = function() {\n\tvar count = 0;\n\twhile (count < this._roomAttempts) {\n\t\tcount++;\n\t\t\n\t\tvar room = ROT.Map.Feature.Room.createRandom(this._width, this._height, this._options);\n\t\tif (!room.isValid(this._isWallCallback, this._canBeDugCallback)) { continue; }\n\t\t\n\t\troom.create(this._digCallback);\n\t\tthis._rooms.push(room);\n\t\treturn room;\n\t} \n\n\t/* no room was generated in a given number of attempts */\n\treturn null;\n}\n\n/**\n * Generates connectors beween rooms\n * @returns {bool} success Was this attempt successfull?\n */\nROT.Map.Uniform.prototype._generateCorridors = function() {\n\tvar cnt = 0;\n\twhile (cnt < this._corridorAttempts) {\n\t\tcnt++;\n\t\tthis._corridors = [];\n\n\t\t/* dig rooms into a clear map */\n\t\tthis._map = this._fillMap(1);\n\t\tfor (var i=0;i<this._rooms.length;i++) { \n\t\t\tvar room = this._rooms[i];\n\t\t\troom.clearDoors();\n\t\t\troom.create(this._digCallback); \n\t\t}\n\n\t\tthis._unconnected = this._rooms.slice().randomize();\n\t\tthis._connected = [];\n\t\tif (this._unconnected.length) { this._connected.push(this._unconnected.pop()); } /* first one is always connected */\n\t\t\n\t\twhile (1) {\n\t\t\t/* 1. pick random connected room */\n\t\t\tvar connected = this._connected.random();\n\t\t\t\n\t\t\t/* 2. find closest unconnected */\n\t\t\tvar room1 = this._closestRoom(this._unconnected, connected);\n\t\t\t\n\t\t\t/* 3. connect it to closest connected */\n\t\t\tvar room2 = this._closestRoom(this._connected, room1);\n\t\t\t\n\t\t\tvar ok = this._connectRooms(room1, room2);\n\t\t\tif (!ok) { break; } /* stop connecting, re-shuffle */\n\t\t\t\n\t\t\tif (!this._unconnected.length) { return true; } /* done; no rooms remain */\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * For a given room, find the closest one from the list\n */\nROT.Map.Uniform.prototype._closestRoom = function(rooms, room) {\n\tvar dist = Infinity;\n\tvar center = room.getCenter();\n\tvar result = null;\n\t\n\tfor (var i=0;i<rooms.length;i++) {\n\t\tvar r = rooms[i];\n\t\tvar c = r.getCenter();\n\t\tvar dx = c[0]-center[0];\n\t\tvar dy = c[1]-center[1];\n\t\tvar d = dx*dx+dy*dy;\n\t\t\n\t\tif (d < dist) {\n\t\t\tdist = d;\n\t\t\tresult = r;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nROT.Map.Uniform.prototype._connectRooms = function(room1, room2) {\n\t/*\n\t\troom1.debug();\n\t\troom2.debug();\n\t*/\n\n\tvar center1 = room1.getCenter();\n\tvar center2 = room2.getCenter();\n\n\tvar diffX = center2[0] - center1[0];\n\tvar diffY = center2[1] - center1[1];\n\n\tif (Math.abs(diffX) < Math.abs(diffY)) { /* first try connecting north-south walls */\n\t\tvar dirIndex1 = (diffY > 0 ? 2 : 0);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getLeft();\n\t\tvar max = room2.getRight();\n\t\tvar index = 0;\n\t} else { /* first try connecting east-west walls */\n\t\tvar dirIndex1 = (diffX > 0 ? 1 : 3);\n\t\tvar dirIndex2 = (dirIndex1 + 2) % 4;\n\t\tvar min = room2.getTop();\n\t\tvar max = room2.getBottom();\n\t\tvar index = 1;\n\t}\n\n\tvar start = this._placeInWall(room1, dirIndex1); /* corridor will start here */\n\tif (!start) { return false; }\n\n\tif (start[index] >= min && start[index] <= max) { /* possible to connect with straight line (I-like) */\n\t\tvar end = start.slice();\n\t\tvar value = null;\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0: value = room2.getTop()-1; break;\n\t\t\tcase 1: value = room2.getRight()+1; break;\n\t\t\tcase 2: value = room2.getBottom()+1; break;\n\t\t\tcase 3: value = room2.getLeft()-1; break;\n\t\t}\n\t\tend[(index+1)%2] = value;\n\t\tthis._digLine([start, end]);\n\t\t\n\t} else if (start[index] < min-1 || start[index] > max+1) { /* need to switch target wall (L-like) */\n\n\t\tvar diff = start[index] - center2[index];\n\t\tswitch (dirIndex2) {\n\t\t\tcase 0:\n\t\t\tcase 1:\tvar rotation = (diff < 0 ? 3 : 1); break;\n\t\t\tcase 2:\n\t\t\tcase 3:\tvar rotation = (diff < 0 ? 1 : 3); break;\n\t\t}\n\t\tdirIndex2 = (dirIndex2 + rotation) % 4;\n\t\t\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\n\t\tvar mid = [0, 0];\n\t\tmid[index] = start[index];\n\t\tvar index2 = (index+1)%2;\n\t\tmid[index2] = end[index2];\n\t\tthis._digLine([start, mid, end]);\n\t\t\n\t} else { /* use current wall pair, but adjust the line in the middle (S-like) */\n\t\n\t\tvar index2 = (index+1)%2;\n\t\tvar end = this._placeInWall(room2, dirIndex2);\n\t\tif (!end) { return false; }\n\t\tvar mid = Math.round((end[index2] + start[index2])/2);\n\n\t\tvar mid1 = [0, 0];\n\t\tvar mid2 = [0, 0];\n\t\tmid1[index] = start[index];\n\t\tmid1[index2] = mid;\n\t\tmid2[index] = end[index];\n\t\tmid2[index2] = mid;\n\t\tthis._digLine([start, mid1, mid2, end]);\n\t}\n\n\troom1.addDoor(start[0], start[1]);\n\troom2.addDoor(end[0], end[1]);\n\t\n\tvar index = this._unconnected.indexOf(room1);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room1);\n\t}\n\n\tvar index = this._unconnected.indexOf(room2);\n\tif (index != -1) {\n\t\tthis._unconnected.splice(index, 1);\n\t\tthis._connected.push(room2);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Uniform.prototype._placeInWall = function(room, dirIndex) {\n\tvar start = [0, 0];\n\tvar dir = [0, 0];\n\tvar length = 0;\n\t\n\tswitch (dirIndex) {\n\t\tcase 0:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getTop()-1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getRight()+1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = [1, 0];\n\t\t\tstart = [room.getLeft(), room.getBottom()+1];\n\t\t\tlength = room.getRight()-room.getLeft()+1;\n\t\tbreak;\n\t\tcase 3:\n\t\t\tdir = [0, 1];\n\t\t\tstart = [room.getLeft()-1, room.getTop()];\n\t\t\tlength = room.getBottom()-room.getTop()+1;\n\t\tbreak;\n\t}\n\t\n\tvar avail = [];\n\tvar lastBadIndex = -2;\n\n\tfor (var i=0;i<length;i++) {\n\t\tvar x = start[0] + i*dir[0];\n\t\tvar y = start[1] + i*dir[1];\n\t\tavail.push(null);\n\t\t\n\t\tvar isWall = (this._map[x][y] == 1);\n\t\tif (isWall) {\n\t\t\tif (lastBadIndex != i-1) { avail[i] = [x, y]; }\n\t\t} else {\n\t\t\tlastBadIndex = i;\n\t\t\tif (i) { avail[i-1] = null; }\n\t\t}\n\t}\n\t\n\tfor (var i=avail.length-1; i>=0; i--) {\n\t\tif (!avail[i]) { avail.splice(i, 1); }\n\t}\n\treturn (avail.length ? avail.random() : null);\n}\n\n/**\n * Dig a polyline.\n */\nROT.Map.Uniform.prototype._digLine = function(points) {\n\tfor (var i=1;i<points.length;i++) {\n\t\tvar start = points[i-1];\n\t\tvar end = points[i];\n\t\tvar corridor = new ROT.Map.Feature.Corridor(start[0], start[1], end[0], end[1]);\n\t\tcorridor.create(this._digCallback);\n\t\tthis._corridors.push(corridor);\n\t}\n}\n\nROT.Map.Uniform.prototype._digCallback = function(x, y, value) {\n\tthis._map[x][y] = value;\n\tif (value == 0) { this._dug++; }\n}\n\nROT.Map.Uniform.prototype._isWallCallback = function(x, y) {\n\tif (x < 0 || y < 0 || x >= this._width || y >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\nROT.Map.Uniform.prototype._canBeDugCallback = function(x, y) {\n\tif (x < 1 || y < 1 || x+1 >= this._width || y+1 >= this._height) { return false; }\n\treturn (this._map[x][y] == 1);\n}\n\n/**\n * @author hyakugei\n * @class Dungeon generator which uses the \"orginal\" Rogue dungeon generation algorithm. See http://kuoi.com/~kamikaze/GameDesign/art07_rogue_dungeon.php\n * @augments ROT.Map\n * @param {int} [width=ROT.DEFAULT_WIDTH]\n * @param {int} [height=ROT.DEFAULT_HEIGHT]\n * @param {object} [options] Options\n * @param {int[]} [options.cellWidth=3] Number of cells to create on the horizontal (number of rooms horizontally)\n * @param {int[]} [options.cellHeight=3] Number of cells to create on the vertical (number of rooms vertically) \n * @param {int} [options.roomWidth] Room min and max width - normally set auto-magically via the constructor.\n * @param {int} [options.roomHeight] Room min and max height - normally set auto-magically via the constructor. \n */\nROT.Map.Rogue = function(width, height, options) {\n\tROT.Map.call(this, width, height);\n\t\n\tthis._options = {\n\t\tcellWidth: 3,  // NOTE to self, these could probably work the same as the roomWidth/room Height values\n\t\tcellHeight: 3  //     ie. as an array with min-max values for each direction....\n\t}\n\t\n\tfor (var p in options) { this._options[p] = options[p]; }\n\t\n\t/*\n\tSet the room sizes according to the over-all width of the map, \n\tand the cell sizes. \n\t*/\n\t\n\tif (!this._options.hasOwnProperty(\"roomWidth\")) {\n\t\tthis._options[\"roomWidth\"] = this._calculateRoomSize(this._width, this._options[\"cellWidth\"]);\n\t}\n\tif (!this._options.hasOwnProperty(\"roomHeight\")) {\n\t\tthis._options[\"roomHeight\"] = this._calculateRoomSize(this._height, this._options[\"cellHeight\"]);\n\t}\n\t\n}\n\nROT.Map.Rogue.extend(ROT.Map); \n\n/**\n * @see ROT.Map#create\n */\nROT.Map.Rogue.prototype.create = function(callback) {\n\tthis.map = this._fillMap(1);\n\tthis.rooms = [];\n\tthis.connectedCells = [];\n\t\n\tthis._initRooms();\n\tthis._connectRooms();\n\tthis._connectUnconnectedRooms();\n\tthis._createRandomRoomConnections();\n\tthis._createRooms();\n\tthis._createCorridors();\n\t\n\tif (callback) {\n\t\tfor (var i = 0; i < this._width; i++) {\n\t\t\tfor (var j = 0; j < this._height; j++) {\n\t\t\t\tcallback(i, j, this.map[i][j]);   \n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn this;\n}\n\nROT.Map.Rogue.prototype._calculateRoomSize = function(size, cell) {\n\tvar max = Math.floor((size/cell) * 0.8);\n\tvar min = Math.floor((size/cell) * 0.25);\n\tif (min < 2) min = 2;\n\tif (max < 2) max = 2;\n\treturn [min, max];\n}\n\nROT.Map.Rogue.prototype._initRooms = function () { \n\t// create rooms array. This is the \"grid\" list from the algo.  \n\tfor (var i = 0; i < this._options.cellWidth; i++) {  \n\t\tthis.rooms.push([]);\n\t\tfor(var j = 0; j < this._options.cellHeight; j++) {\n\t\t\tthis.rooms[i].push({\"x\":0, \"y\":0, \"width\":0, \"height\":0, \"connections\":[], \"cellx\":i, \"celly\":j});\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._connectRooms = function() {\n\t//pick random starting grid\n\tvar cgx = ROT.RNG.getUniformInt(0, this._options.cellWidth-1);\n\tvar cgy = ROT.RNG.getUniformInt(0, this._options.cellHeight-1);\n\t\n\tvar idx;\n\tvar ncgx;\n\tvar ncgy;\n\t\n\tvar found = false;\n\tvar room;\n\tvar otherRoom;\n\t\n\t// find  unconnected neighbour cells\n\tdo {\n\t\n\t\t//var dirToCheck = [0,1,2,3,4,5,6,7];\n\t\tvar dirToCheck = [0,2,4,6];\n\t\tdirToCheck = dirToCheck.randomize();\n\t\t\n\t\tdo {\n\t\t\tfound = false;\n\t\t\tidx = dirToCheck.pop();\n\t\t\t\n\t\t\t\n\t\t\tncgx = cgx + ROT.DIRS[8][idx][0];\n\t\t\tncgy = cgy + ROT.DIRS[8][idx][1];\n\t\t\t\n\t\t\tif(ncgx < 0 || ncgx >= this._options.cellWidth) continue;\n\t\t\tif(ncgy < 0 || ncgy >= this._options.cellHeight) continue;\n\t\t\t\n\t\t\troom = this.rooms[cgx][cgy];\n\t\t\t\n\t\t\tif(room[\"connections\"].length > 0)\n\t\t\t{\n\t\t\t\t// as long as this room doesn't already coonect to me, we are ok with it. \n\t\t\t\tif(room[\"connections\"][0][0] == ncgx &&\n\t\t\t\troom[\"connections\"][0][1] == ncgy)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherRoom = this.rooms[ncgx][ncgy];\n\t\t\t\n\t\t\tif (otherRoom[\"connections\"].length == 0) { \n\t\t\t\totherRoom[\"connections\"].push([cgx,cgy]);\n\t\t\t\t\n\t\t\t\tthis.connectedCells.push([ncgx, ncgy]);\n\t\t\t\tcgx = ncgx;\n\t\t\t\tcgy = ncgy;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\t\t\t\n\t\t} while (dirToCheck.length > 0 && found == false)\n\t\t\n\t} while (dirToCheck.length > 0)\n\n}\n\nROT.Map.Rogue.prototype._connectUnconnectedRooms = function() {\n\t//While there are unconnected rooms, try to connect them to a random connected neighbor \n\t//(if a room has no connected neighbors yet, just keep cycling, you'll fill out to it eventually).\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar randomConnectedCell;\n\tthis.connectedCells = this.connectedCells.randomize();\n\tvar room;\n\tvar otherRoom;\n\tvar validRoom;\n\t\n\tfor (var i = 0; i < this._options.cellWidth; i++) {\n\t\tfor (var j = 0; j < this._options.cellHeight; j++)  {\n\t\t\t\t\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tif (room[\"connections\"].length == 0) {\n\t\t\t\tvar directions = [0,2,4,6];\n\t\t\t\tdirections = directions.randomize();\n\t\t\t\t\n\t\t\t\tvar validRoom = false;\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\tvar dirIdx = directions.pop();\n\t\t\t\t\tvar newI = i + ROT.DIRS[8][dirIdx][0];\n\t\t\t\t\tvar newJ = j + ROT.DIRS[8][dirIdx][1];\n\t\t\t\t\t\n\t\t\t\t\tif (newI < 0 || newI >= cw || \n\t\t\t\t\tnewJ < 0 || newJ >= ch) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\totherRoom = this.rooms[newI][newJ];\n\t\t\t\t\t\n\t\t\t\t\tvalidRoom = true;\n\t\t\t\t\t\n\t\t\t\t\tif (otherRoom[\"connections\"].length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (var k = 0; k < otherRoom[\"connections\"].length; k++) {\n\t\t\t\t\t\tif(otherRoom[\"connections\"][k][0] == i && \n\t\t\t\t\t\totherRoom[\"connections\"][k][1] == j) {\n\t\t\t\t\t\t\tvalidRoom = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (validRoom) break;\n\t\t\t\t\t\n\t\t\t\t} while (directions.length)\n\t\t\t\t\n\t\t\t\tif(validRoom) { \n\t\t\t\t\troom[\"connections\"].push( [otherRoom[\"cellx\"], otherRoom[\"celly\"]] );  \n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"-- Unable to connect room.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createRandomRoomConnections = function(connections) {\n\t// Empty for now. \n}\n\n\nROT.Map.Rogue.prototype._createRooms = function() {\n\t// Create Rooms \n\t\n\tvar w = this._width;\n\tvar h = this._height;\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\t\n\tvar cwp = Math.floor(this._width / cw);\n\tvar chp = Math.floor(this._height / ch);\n\t\n\tvar roomw;\n\tvar roomh;\n\tvar roomWidth = this._options[\"roomWidth\"];\n\tvar roomHeight = this._options[\"roomHeight\"];\n\tvar sx;\n\tvar sy;\n\tvar tx;\n\tvar ty;\n\tvar otherRoom;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\tsx = cwp * i;\n\t\t\tsy = chp * j;\n\t\t\t\n\t\t\tif (sx == 0) sx = 1;\n\t\t\tif (sy == 0) sy = 1;\n\t\t\t\n\t\t\troomw = ROT.RNG.getUniformInt(roomWidth[0], roomWidth[1]);\n\t\t\troomh = ROT.RNG.getUniformInt(roomHeight[0], roomHeight[1]);\n\t\t\t\n\t\t\tif (j > 0) {\n\t\t\t\totherRoom = this.rooms[i][j-1];\n\t\t\t\twhile (sy - (otherRoom[\"y\"] + otherRoom[\"height\"] ) < 3) {\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (i > 0) {\n\t\t\t\totherRoom = this.rooms[i-1][j];\n\t\t\t\twhile(sx - (otherRoom[\"x\"] + otherRoom[\"width\"]) < 3) {\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar sxOffset = Math.round(ROT.RNG.getUniformInt(0, cwp-roomw)/2);\n\t\t\tvar syOffset = Math.round(ROT.RNG.getUniformInt(0, chp-roomh)/2);\n\t\t\t\n\t\t\twhile (sx + sxOffset + roomw >= w) {\n\t\t\t\tif(sxOffset) {\n\t\t\t\t\tsxOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomw--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\twhile (sy + syOffset + roomh >= h) { \n\t\t\t\tif(syOffset) {\n\t\t\t\t\tsyOffset--;\n\t\t\t\t} else {\n\t\t\t\t\troomh--; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsx = sx + sxOffset;\n\t\t\tsy = sy + syOffset;\n\t\t\t\n\t\t\tthis.rooms[i][j][\"x\"] = sx;\n\t\t\tthis.rooms[i][j][\"y\"] = sy;\n\t\t\tthis.rooms[i][j][\"width\"] = roomw;\n\t\t\tthis.rooms[i][j][\"height\"] = roomh;  \n\t\t\t\n\t\t\tfor (var ii = sx; ii < sx + roomw; ii++) {\n\t\t\t\tfor (var jj = sy; jj < sy + roomh; jj++) {\n\t\t\t\t\tthis.map[ii][jj] = 0;\n\t\t\t\t}\n\t\t\t}  \n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._getWallPosition = function(aRoom, aDirection) {\n\tvar rx;\n\tvar ry;\n\tvar door;\n\t\n\tif (aDirection == 1 || aDirection == 3) {\n\t\trx = ROT.RNG.getUniformInt(aRoom[\"x\"] + 1, aRoom[\"x\"] + aRoom[\"width\"] - 2);\n\t\tif (aDirection == 1) {\n\t\t\try = aRoom[\"y\"] - 2;\n\t\t\tdoor = ry + 1;\n\t\t} else {\n\t\t\try = aRoom[\"y\"] + aRoom[\"height\"] + 1;\n\t\t\tdoor = ry -1;\n\t\t}\n\t\t\n\t\tthis.map[rx][door] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t} else if (aDirection == 2 || aDirection == 4) {\n\t\try = ROT.RNG.getUniformInt(aRoom[\"y\"] + 1, aRoom[\"y\"] + aRoom[\"height\"] - 2);\n\t\tif(aDirection == 2) {\n\t\t\trx = aRoom[\"x\"] + aRoom[\"width\"] + 1;\n\t\t\tdoor = rx - 1;\n\t\t} else {\n\t\t\trx = aRoom[\"x\"] - 2;\n\t\t\tdoor = rx + 1;\n\t\t}\n\t\t\n\t\tthis.map[door][ry] = 0; // i'm not setting a specific 'door' tile value right now, just empty space. \n\t\t\n\t}\n\treturn [rx, ry];\n}\n\n/***\n* @param startPosition a 2 element array\n* @param endPosition a 2 element array\n*/\nROT.Map.Rogue.prototype._drawCorridore = function (startPosition, endPosition) {\n\tvar xOffset = endPosition[0] - startPosition[0];\n\tvar yOffset = endPosition[1] - startPosition[1];\n\t\n\tvar xpos = startPosition[0];\n\tvar ypos = startPosition[1];\n\t\n\tvar tempDist;\n\tvar xDir;\n\tvar yDir;\n\t\n\tvar move; // 2 element array, element 0 is the direction, element 1 is the total value to move. \n\tvar moves = []; // a list of 2 element arrays\n\t\n\tvar xAbs = Math.abs(xOffset);\n\tvar yAbs = Math.abs(yOffset);\n\t\n\tvar percent = ROT.RNG.getUniform(); // used to split the move at different places along the long axis\n\tvar firstHalf = percent;\n\tvar secondHalf = 1 - percent;\n\t\n\txDir = xOffset > 0 ? 2 : 6;\n\tyDir = yOffset > 0 ? 4 : 0;\n\t\n\tif (xAbs < yAbs) {\n\t\t// move firstHalf of the y offset\n\t\ttempDist = Math.ceil(yAbs * firstHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t\t// move all the x offset\n\t\tmoves.push([xDir, xAbs]);\n\t\t// move sendHalf of the  y offset\n\t\ttempDist = Math.floor(yAbs * secondHalf);\n\t\tmoves.push([yDir, tempDist]);\n\t} else {\n\t\t//  move firstHalf of the x offset\n\t\ttempDist = Math.ceil(xAbs * firstHalf);\n\t\tmoves.push([xDir, tempDist]);\n\t\t// move all the y offset\n\t\tmoves.push([yDir, yAbs]);\n\t\t// move secondHalf of the x offset.\n\t\ttempDist = Math.floor(xAbs * secondHalf);\n\t\tmoves.push([xDir, tempDist]);  \n\t}\n\t\n\tthis.map[xpos][ypos] = 0;\n\t\n\twhile (moves.length > 0) {\n\t\tmove = moves.pop();\n\t\twhile (move[1] > 0) {\n\t\t\txpos += ROT.DIRS[8][move[0]][0];\n\t\t\typos += ROT.DIRS[8][move[0]][1];\n\t\t\tthis.map[xpos][ypos] = 0;\n\t\t\tmove[1] = move[1] - 1;\n\t\t}\n\t}\n}\n\nROT.Map.Rogue.prototype._createCorridors = function () {\n\t// Draw Corridors between connected rooms\n\t\n\tvar cw = this._options.cellWidth;\n\tvar ch = this._options.cellHeight;\n\tvar room;\n\tvar connection;\n\tvar otherRoom;\n\tvar wall;\n\tvar otherWall;\n\t\n\tfor (var i = 0; i < cw; i++) {\n\t\tfor (var j = 0; j < ch; j++) {\n\t\t\troom = this.rooms[i][j];\n\t\t\t\n\t\t\tfor (var k = 0; k < room[\"connections\"].length; k++) {\n\t\t\t\t\t\n\t\t\t\tconnection = room[\"connections\"][k]; \n\t\t\t\t\n\t\t\t\totherRoom = this.rooms[connection[0]][connection[1]];\n\t\t\t\t\n\t\t\t\t// figure out what wall our corridor will start one.\n\t\t\t\t// figure out what wall our corridor will end on. \n\t\t\t\tif (otherRoom[\"cellx\"] > room[\"cellx\"] ) {\n\t\t\t\t\twall = 2;\n\t\t\t\t\totherWall = 4;\n\t\t\t\t} else if (otherRoom[\"cellx\"] < room[\"cellx\"] ) {\n\t\t\t\t\twall = 4;\n\t\t\t\t\totherWall = 2;\n\t\t\t\t} else if(otherRoom[\"celly\"] > room[\"celly\"]) {\n\t\t\t\t\twall = 3;\n\t\t\t\t\totherWall = 1;\n\t\t\t\t} else if(otherRoom[\"celly\"] < room[\"celly\"]) {\n\t\t\t\t\twall = 1;\n\t\t\t\t\totherWall = 3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._drawCorridore(this._getWallPosition(room, wall), this._getWallPosition(otherRoom, otherWall));\n\t\t\t}\n\t\t}\n\t}\n}\n/**\n * @class Dungeon feature; has own .create() method\n */\nROT.Map.Feature = function() {}\nROT.Map.Feature.prototype.isValid = function(canBeDugCallback) {}\nROT.Map.Feature.prototype.create = function(digCallback) {}\nROT.Map.Feature.prototype.debug = function() {}\nROT.Map.Feature.createRandomAt = function(x, y, dx, dy, options) {}\n\n/**\n * @class Room\n * @augments ROT.Map.Feature\n * @param {int} x1\n * @param {int} y1\n * @param {int} x2\n * @param {int} y2\n * @param {int} [doorX]\n * @param {int} [doorY]\n */\nROT.Map.Feature.Room = function(x1, y1, x2, y2, doorX, doorY) {\n\tthis._x1 = x1;\n\tthis._y1 = y1;\n\tthis._x2 = x2;\n\tthis._y2 = y2;\n\tthis._doors = {};\n\tif (arguments.length > 4) { this.addDoor(doorX, doorY); }\n}\nROT.Map.Feature.Room.extend(ROT.Map.Feature);\n\n/**\n * Room of random size, with a given doors and direction\n */\nROT.Map.Feature.Room.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tif (dx == 1) { /* to the right */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x+1, y2, x+width, y2+height-1, x, y);\n\t}\n\t\n\tif (dx == -1) { /* to the left */\n\t\tvar y2 = y - Math.floor(ROT.RNG.getUniform() * height);\n\t\treturn new this(x-width, y2, x-1, y2+height-1, x, y);\n\t}\n\n\tif (dy == 1) { /* to the bottom */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y+1, x2+width-1, y+height, x, y);\n\t}\n\n\tif (dy == -1) { /* to the top */\n\t\tvar x2 = x - Math.floor(ROT.RNG.getUniform() * width);\n\t\treturn new this(x2, y-height, x2+width-1, y-1, x, y);\n\t}\n\n        throw new Error(\"dx or dy must be 1 or -1\");\n}\n\n/**\n * Room of random size, positioned around center coords\n */\nROT.Map.Feature.Room.createRandomCenter = function(cx, cy, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\n\tvar x1 = cx - Math.floor(ROT.RNG.getUniform()*width);\n\tvar y1 = cy - Math.floor(ROT.RNG.getUniform()*height);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\n/**\n * Room of random size within a given dimensions\n */\nROT.Map.Feature.Room.createRandom = function(availWidth, availHeight, options) {\n\tvar min = options.roomWidth[0];\n\tvar max = options.roomWidth[1];\n\tvar width = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar min = options.roomHeight[0];\n\tvar max = options.roomHeight[1];\n\tvar height = ROT.RNG.getUniformInt(min, max);\n\t\n\tvar left = availWidth - width - 1;\n\tvar top = availHeight - height - 1;\n\n\tvar x1 = 1 + Math.floor(ROT.RNG.getUniform()*left);\n\tvar y1 = 1 + Math.floor(ROT.RNG.getUniform()*top);\n\tvar x2 = x1 + width - 1;\n\tvar y2 = y1 + height - 1;\n\n\treturn new this(x1, y1, x2, y2);\n}\n\nROT.Map.Feature.Room.prototype.addDoor = function(x, y) {\n\tthis._doors[x+\",\"+y] = 1;\n\treturn this;\n}\n\n/**\n * @param {function}\n */\nROT.Map.Feature.Room.prototype.getDoors = function(callback) {\n\tfor (var key in this._doors) {\n\t\tvar parts = key.split(\",\");\n\t\tcallback(parseInt(parts[0]), parseInt(parts[1]));\n\t}\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.clearDoors = function() {\n\tthis._doors = {};\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.addDoors = function(isWallCallback) {\n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x != left && x != right && y != top && y != bottom) { continue; }\n\t\t\tif (isWallCallback(x, y)) { continue; }\n\n\t\t\tthis.addDoor(x, y);\n\t\t}\n\t}\n\n\treturn this;\n}\n\nROT.Map.Feature.Room.prototype.debug = function() {\n\tconsole.log(\"room\", this._x1, this._y1, this._x2, this._y2);\n}\n\nROT.Map.Feature.Room.prototype.isValid = function(isWallCallback, canBeDugCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tif (!isWallCallback(x, y)) { return false; }\n\t\t\t} else {\n\t\t\t\tif (!canBeDugCallback(x, y)) { return false; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty, 1 = wall, 2 = door. Multiple doors are allowed.\n */\nROT.Map.Feature.Room.prototype.create = function(digCallback) { \n\tvar left = this._x1-1;\n\tvar right = this._x2+1;\n\tvar top = this._y1-1;\n\tvar bottom = this._y2+1;\n\t\n\tvar value = 0;\n\tfor (var x=left; x<=right; x++) {\n\t\tfor (var y=top; y<=bottom; y++) {\n\t\t\tif (x+\",\"+y in this._doors) {\n\t\t\t\tvalue = 2;\n\t\t\t} else if (x == left || x == right || y == top || y == bottom) {\n\t\t\t\tvalue = 1;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tdigCallback(x, y, value);\n\t\t}\n\t}\n}\n\nROT.Map.Feature.Room.prototype.getCenter = function() {\n\treturn [Math.round((this._x1 + this._x2)/2), Math.round((this._y1 + this._y2)/2)];\n}\n\nROT.Map.Feature.Room.prototype.getLeft = function() {\n\treturn this._x1;\n}\n\nROT.Map.Feature.Room.prototype.getRight = function() {\n\treturn this._x2;\n}\n\nROT.Map.Feature.Room.prototype.getTop = function() {\n\treturn this._y1;\n}\n\nROT.Map.Feature.Room.prototype.getBottom = function() {\n\treturn this._y2;\n}\n\n/**\n * @class Corridor\n * @augments ROT.Map.Feature\n * @param {int} startX\n * @param {int} startY\n * @param {int} endX\n * @param {int} endY\n */\nROT.Map.Feature.Corridor = function(startX, startY, endX, endY) {\n\tthis._startX = startX;\n\tthis._startY = startY;\n\tthis._endX = endX; \n\tthis._endY = endY;\n\tthis._endsWithAWall = true;\n}\nROT.Map.Feature.Corridor.extend(ROT.Map.Feature);\n\nROT.Map.Feature.Corridor.createRandomAt = function(x, y, dx, dy, options) {\n\tvar min = options.corridorLength[0];\n\tvar max = options.corridorLength[1];\n\tvar length = ROT.RNG.getUniformInt(min, max);\n\t\n\treturn new this(x, y, x + dx*length, y + dy*length);\n}\n\nROT.Map.Feature.Corridor.prototype.debug = function() {\n\tconsole.log(\"corridor\", this._startX, this._startY, this._endX, this._endY);\n}\n\nROT.Map.Feature.Corridor.prototype.isValid = function(isWallCallback, canBeDugCallback){ \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1 + Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tvar ok = true;\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\n\t\tif (!canBeDugCallback(     x,      y)) { ok = false; }\n\t\tif (!isWallCallback  (x + nx, y + ny)) { ok = false; }\n\t\tif (!isWallCallback  (x - nx, y - ny)) { ok = false; }\n\t\t\n\t\tif (!ok) {\n\t\t\tlength = i;\n\t\t\tthis._endX = x-dx;\n\t\t\tthis._endY = y-dy;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * If the length degenerated, this corridor might be invalid\n\t */\n\t \n\t/* not supported */\n\tif (length == 0) { return false; } \n\t\n\t /* length 1 allowed only if the next space is empty */\n\tif (length == 1 && isWallCallback(this._endX + dx, this._endY + dy)) { return false; }\n\t\n\t/**\n\t * We do not want the corridor to crash into a corner of a room;\n\t * if any of the ending corners is empty, the N+1th cell of this corridor must be empty too.\n\t * \n\t * Situation:\n\t * #######1\n\t * .......?\n\t * #######2\n\t * \n\t * The corridor was dug from left to right.\n\t * 1, 2 - problematic corners, ? = N+1th cell (not dug)\n\t */\n\tvar firstCornerBad = !isWallCallback(this._endX + dx + nx, this._endY + dy + ny);\n\tvar secondCornerBad = !isWallCallback(this._endX + dx - nx, this._endY + dy - ny);\n\tthis._endsWithAWall = isWallCallback(this._endX + dx, this._endY + dy);\n\tif ((firstCornerBad || secondCornerBad) && this._endsWithAWall) { return false; }\n\n\treturn true;\n}\n\n/**\n * @param {function} digCallback Dig callback with a signature (x, y, value). Values: 0 = empty.\n */\nROT.Map.Feature.Corridor.prototype.create = function(digCallback) { \n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tvar length = 1+Math.max(Math.abs(dx), Math.abs(dy));\n\t\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\t\n\tfor (var i=0; i<length; i++) {\n\t\tvar x = sx + i*dx;\n\t\tvar y = sy + i*dy;\n\t\tdigCallback(x, y, 0);\n\t}\n\t\n\treturn true;\n}\n\nROT.Map.Feature.Corridor.prototype.createPriorityWalls = function(priorityWallCallback) {\n\tif (!this._endsWithAWall) { return; }\n\n\tvar sx = this._startX;\n\tvar sy = this._startY;\n\n\tvar dx = this._endX-sx;\n\tvar dy = this._endY-sy;\n\tif (dx) { dx = dx/Math.abs(dx); }\n\tif (dy) { dy = dy/Math.abs(dy); }\n\tvar nx = dy;\n\tvar ny = -dx;\n\n\tpriorityWallCallback(this._endX + dx, this._endY + dy);\n\tpriorityWallCallback(this._endX + nx, this._endY + ny);\n\tpriorityWallCallback(this._endX - nx, this._endY - ny);\n}\n/**\n * @class Base noise generator\n */\nROT.Noise = function() {\n};\n\nROT.Noise.prototype.get = function(x, y) {}\n/**\n * A simple 2d implementation of simplex noise by Ondrej Zara\n *\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n */\n\n/**\n * @class 2D simplex noise generator\n * @param {int} [gradients=256] Random gradients\n */\nROT.Noise.Simplex = function(gradients) {\n\tROT.Noise.call(this);\n\n\tthis._F2 = 0.5 * (Math.sqrt(3) - 1);\n\tthis._G2 = (3 - Math.sqrt(3)) / 6;\n\n\tthis._gradients = [\n\t\t[ 0, -1],\n\t\t[ 1, -1],\n\t\t[ 1,  0],\n\t\t[ 1,  1],\n\t\t[ 0,  1],\n\t\t[-1,  1],\n\t\t[-1,  0],\n\t\t[-1, -1]\n\t];\n\n\tvar permutations = [];\n\tvar count = gradients || 256;\n\tfor (var i=0;i<count;i++) { permutations.push(i); }\n\tpermutations = permutations.randomize();\n\n\tthis._perms = [];\n\tthis._indexes = [];\n\n\tfor (var i=0;i<2*count;i++) {\n\t\tthis._perms.push(permutations[i % count]);\n\t\tthis._indexes.push(this._perms[i] % this._gradients.length);\n\t}\n\n};\nROT.Noise.Simplex.extend(ROT.Noise);\n\nROT.Noise.Simplex.prototype.get = function(xin, yin) {\n\tvar perms = this._perms;\n\tvar indexes = this._indexes;\n\tvar count = perms.length/2;\n\tvar G2 = this._G2;\n\n\tvar n0 =0, n1 = 0, n2 = 0, gi; // Noise contributions from the three corners\n\n\t// Skew the input space to determine which simplex cell we're in\n\tvar s = (xin + yin) * this._F2; // Hairy factor for 2D\n\tvar i = Math.floor(xin + s);\n\tvar j = Math.floor(yin + s);\n\tvar t = (i + j) * G2;\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space\n\tvar Y0 = j - t;\n\tvar x0 = xin - X0; // The x,y distances from the cell origin\n\tvar y0 = yin - Y0;\n\n\t// For the 2D case, the simplex shape is an equilateral triangle.\n\t// Determine which simplex we are in.\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\tif (x0 > y0) {\n\t\ti1 = 1;\n\t\tj1 = 0;\n\t} else { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n\t\ti1 = 0;\n\t\tj1 = 1;\n\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n\t// c = (3-sqrt(3))/6\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\tvar y1 = y0 - j1 + G2;\n\tvar x2 = x0 - 1 + 2*G2; // Offsets for last corner in (x,y) unskewed coords\n\tvar y2 = y0 - 1 + 2*G2;\n\n\t// Work out the hashed gradient indices of the three simplex corners\n\tvar ii = i.mod(count);\n\tvar jj = j.mod(count);\n\n\t// Calculate the contribution from the three corners\n\tvar t0 = 0.5 - x0*x0 - y0*y0;\n\tif (t0 >= 0) {\n\t\tt0 *= t0;\n\t\tgi = indexes[ii+perms[jj]];\n\t\tvar grad = this._gradients[gi];\n\t\tn0 = t0 * t0 * (grad[0] * x0 + grad[1] * y0);\n\t}\n\t\n\tvar t1 = 0.5 - x1*x1 - y1*y1;\n\tif (t1 >= 0) {\n\t\tt1 *= t1;\n\t\tgi = indexes[ii+i1+perms[jj+j1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn1 = t1 * t1 * (grad[0] * x1 + grad[1] * y1);\n\t}\n\t\n\tvar t2 = 0.5 - x2*x2 - y2*y2;\n\tif (t2 >= 0) {\n\t\tt2 *= t2;\n\t\tgi = indexes[ii+1+perms[jj+1]];\n\t\tvar grad = this._gradients[gi];\n\t\tn2 = t2 * t2 * (grad[0] * x2 + grad[1] * y2);\n\t}\n\n\t// Add contributions from each corner to get the final noise value.\n\t// The result is scaled to return values in the interval [-1,1].\n\treturn 70 * (n0 + n1 + n2);\n}\n/**\n * @class Abstract FOV algorithm\n * @param {function} lightPassesCallback Does the light pass through x,y?\n * @param {object} [options]\n * @param {int} [options.topology=8] 4/6/8\n */\nROT.FOV = function(lightPassesCallback, options) {\n\tthis._lightPasses = lightPassesCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n};\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.prototype.compute = function(x, y, R, callback) {}\n\n/**\n * Return all neighbors in a concentric ring\n * @param {int} cx center-x\n * @param {int} cy center-y\n * @param {int} r range\n */\nROT.FOV.prototype._getCircle = function(cx, cy, r) {\n\tvar result = [];\n\tvar dirs, countFactor, startOffset;\n\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [0, 1];\n\t\t\tdirs = [\n\t\t\t\tROT.DIRS[8][7],\n\t\t\t\tROT.DIRS[8][1],\n\t\t\t\tROT.DIRS[8][3],\n\t\t\t\tROT.DIRS[8][5]\n\t\t\t]\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tdirs = ROT.DIRS[6];\n\t\t\tcountFactor = 1;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\n\t\tcase 8:\n\t\t\tdirs = ROT.DIRS[4];\n\t\t\tcountFactor = 2;\n\t\t\tstartOffset = [-1, 1];\n\t\tbreak;\n\t}\n\n\t/* starting neighbor */\n\tvar x = cx + startOffset[0]*r;\n\tvar y = cy + startOffset[1]*r;\n\n\t/* circle */\n\tfor (var i=0;i<dirs.length;i++) {\n\t\tfor (var j=0;j<r*countFactor;j++) {\n\t\t\tresult.push([x, y]);\n\t\t\tx += dirs[i][0];\n\t\t\ty += dirs[i][1];\n\n\t\t}\n\t}\n\n\treturn result;\n}\n/**\n * @class Discrete shadowcasting algorithm. Obsoleted by Precise shadowcasting.\n * @augments ROT.FOV\n */\nROT.FOV.DiscreteShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.DiscreteShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.DiscreteShadowcasting.prototype.compute = function(x, y, R, callback) {\n\tvar center = this._coords;\n\tvar map = this._map;\n\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* start and end angles */\n\tvar DATA = [];\n\t\n\tvar A, B, cx, cy, blocks;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar angle = 360 / neighbors.length;\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\tA = angle * (i - 0.5);\n\t\t\tB = A + angle;\n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tif (this._visibleCoords(Math.floor(A), Math.ceil(B), blocks, DATA)) { callback(cx, cy, r, 1); }\n\t\t\t\n\t\t\tif (DATA.length == 2 && DATA[0] == 0 && DATA[1] == 360) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int} A start angle\n * @param {int} B end angle\n * @param {bool} blocks Does current cell block visibility?\n * @param {int[][]} DATA shadowed angle pairs\n */\nROT.FOV.DiscreteShadowcasting.prototype._visibleCoords = function(A, B, blocks, DATA) {\n\tif (A < 0) { \n\t\tvar v1 = arguments.callee(0, B, blocks, DATA);\n\t\tvar v2 = arguments.callee(360+A, 360, blocks, DATA);\n\t\treturn v1 || v2;\n\t}\n\t\n\tvar index = 0;\n\twhile (index < DATA.length && DATA[index] < A) { index++; }\n\t\n\tif (index == DATA.length) { /* completely new shadow */\n\t\tif (blocks) { DATA.push(A, B); } \n\t\treturn true;\n\t}\n\t\n\tvar count = 0;\n\t\n\tif (index % 2) { /* this shadow starts in an existing shadow, or within its ending boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tif (count == 0) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, B);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\n\t} else { /* this shadow starts outside an existing shadow, or within a starting boundary */\n\t\twhile (index < DATA.length && DATA[index] < B) {\n\t\t\tindex++;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t/* visible when outside an existing shadow, or when overlapping */\n\t\tif (A == DATA[index-count] && count == 1) { return false; }\n\t\t\n\t\tif (blocks) { \n\t\t\tif (count % 2) {\n\t\t\t\tDATA.splice(index-count, count, A);\n\t\t\t} else {\n\t\t\t\tDATA.splice(index-count, count, A, B);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}\n}\n/**\n * @class Precise shadowcasting algorithm\n * @augments ROT.FOV\n */\nROT.FOV.PreciseShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.PreciseShadowcasting.extend(ROT.FOV);\n\n/**\n * @see ROT.FOV#compute\n */\nROT.FOV.PreciseShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t/* this place is always visible */\n\tcallback(x, y, 0, 1);\n\n\t/* standing in a dark place. FIXME is this a good idea?  */\n\tif (!this._lightPasses(x, y)) { return; }\n\t\n\t/* list of all shadows */\n\tvar SHADOWS = [];\n\t\n\tvar cx, cy, blocks, A1, A2, visibility;\n\n\t/* analyze surrounding cells in concentric rings, starting from the center */\n\tfor (var r=1; r<=R; r++) {\n\t\tvar neighbors = this._getCircle(x, y, r);\n\t\tvar neighborCount = neighbors.length;\n\n\t\tfor (var i=0;i<neighborCount;i++) {\n\t\t\tcx = neighbors[i][0];\n\t\t\tcy = neighbors[i][1];\n\t\t\t/* shift half-an-angle backwards to maintain consistency of 0-th cells */\n\t\t\tA1 = [i ? 2*i-1 : 2*neighborCount-1, 2*neighborCount];\n\t\t\tA2 = [2*i+1, 2*neighborCount]; \n\t\t\t\n\t\t\tblocks = !this._lightPasses(cx, cy);\n\t\t\tvisibility = this._checkVisibility(A1, A2, blocks, SHADOWS);\n\t\t\tif (visibility) { callback(cx, cy, r, visibility); }\n\n\t\t\tif (SHADOWS.length == 2 && SHADOWS[0][0] == 0 && SHADOWS[1][0] == SHADOWS[1][1]) { return; } /* cutoff? */\n\n\t\t} /* for all cells in this ring */\n\t} /* for all rings */\n}\n\n/**\n * @param {int[2]} A1 arc start\n * @param {int[2]} A2 arc end\n * @param {bool} blocks Does current arc block visibility?\n * @param {int[][]} SHADOWS list of active shadows\n */\nROT.FOV.PreciseShadowcasting.prototype._checkVisibility = function(A1, A2, blocks, SHADOWS) {\n\tif (A1[0] > A2[0]) { /* split into two sub-arcs */\n\t\tvar v1 = this._checkVisibility(A1, [A1[1], A1[1]], blocks, SHADOWS);\n\t\tvar v2 = this._checkVisibility([0, 1], A2, blocks, SHADOWS);\n\t\treturn (v1+v2)/2;\n\t}\n\n\t/* index1: first shadow >= A1 */\n\tvar index1 = 0, edge1 = false;\n\twhile (index1 < SHADOWS.length) {\n\t\tvar old = SHADOWS[index1];\n\t\tvar diff = old[0]*A1[1] - A1[0]*old[1];\n\t\tif (diff >= 0) { /* old >= A1 */\n\t\t\tif (diff == 0 && !(index1 % 2)) { edge1 = true; }\n\t\t\tbreak;\n\t\t}\n\t\tindex1++;\n\t}\n\n\t/* index2: last shadow <= A2 */\n\tvar index2 = SHADOWS.length, edge2 = false;\n\twhile (index2--) {\n\t\tvar old = SHADOWS[index2];\n\t\tvar diff = A2[0]*old[1] - old[0]*A2[1];\n\t\tif (diff >= 0) { /* old <= A2 */\n\t\t\tif (diff == 0 && (index2 % 2)) { edge2 = true; }\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar visible = true;\n\tif (index1 == index2 && (edge1 || edge2)) {  /* subset of existing shadow, one of the edges match */\n\t\tvisible = false; \n\t} else if (edge1 && edge2 && index1+1==index2 && (index2 % 2)) { /* completely equivalent with existing shadow */\n\t\tvisible = false;\n\t} else if (index1 > index2 && (index1 % 2)) { /* subset of existing shadow, not touching */\n\t\tvisible = false;\n\t}\n\t\n\tif (!visible) { return 0; } /* fast case: not visible */\n\t\n\tvar visibleLength, P;\n\n\t/* compute the length of visible arc, adjust list of shadows (if blocking) */\n\tvar remove = index2-index1+1;\n\tif (remove % 2) {\n\t\tif (index1 % 2) { /* first edge within existing shadow, second outside */\n\t\t\tvar P = SHADOWS[index1];\n\t\t\tvisibleLength = (A2[0]*P[1] - P[0]*A2[1]) / (P[1] * A2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A2); }\n\t\t} else { /* second edge within existing shadow, first outside */\n\t\t\tvar P = SHADOWS[index2];\n\t\t\tvisibleLength = (P[0]*A1[1] - A1[0]*P[1]) / (A1[1] * P[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1); }\n\t\t}\n\t} else {\n\t\tif (index1 % 2) { /* both edges within existing shadows */\n\t\t\tvar P1 = SHADOWS[index1];\n\t\t\tvar P2 = SHADOWS[index2];\n\t\t\tvisibleLength = (P2[0]*P1[1] - P1[0]*P2[1]) / (P1[1] * P2[1]);\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove); }\n\t\t} else { /* both edges outside existing shadows */\n\t\t\tif (blocks) { SHADOWS.splice(index1, remove, A1, A2); }\n\t\t\treturn 1; /* whole arc visible! */\n\t\t}\n\t}\n\n\tvar arcLength = (A2[0]*A1[1] - A1[0]*A2[1]) / (A1[1] * A2[1]);\n\n\treturn visibleLength/arcLength;\n}\n/**\n * @class Recursive shadowcasting algorithm\n * Currently only supports 4/8 topologies, not hexagonal.\n * Based on Peter Harkins' implementation of Björn Bergström's algorithm described here: http://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting\n * @augments ROT.FOV\n */\nROT.FOV.RecursiveShadowcasting = function(lightPassesCallback, options) {\n\tROT.FOV.call(this, lightPassesCallback, options);\n}\nROT.FOV.RecursiveShadowcasting.extend(ROT.FOV);\n\n/** Octants used for translating recursive shadowcasting offsets */\nROT.FOV.RecursiveShadowcasting.OCTANTS = [\n\t[-1,  0,  0,  1],\n\t[ 0, -1,  1,  0],\n\t[ 0, -1, -1,  0],\n\t[-1,  0,  0, -1],\n\t[ 1,  0,  0, -1],\n\t[ 0,  1, -1,  0],\n\t[ 0,  1,  1,  0],\n\t[ 1,  0,  0,  1]\n];\n\n/**\n * Compute visibility for a 360-degree circle\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute = function(x, y, R, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tfor(var i = 0; i < ROT.FOV.RecursiveShadowcasting.OCTANTS.length; i++) {\n\t\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[i], R, callback);\n\t}\n}\n\n/**\n * Compute visibility for a 180-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute180 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 180 degrees\n\tvar nextPreviousOctant = (dir - 2 + 8) % 8; //Need to retrieve the previous two octants to render a full 180 degrees\n\tvar nextOctant = (dir+ 1 + 8) % 8; //Need to grab to next octant to render a full 180 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextPreviousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[nextOctant], R, callback);\n}\n\n/**\n * Compute visibility for a 90-degree arc\n * @param {int} x\n * @param {int} y\n * @param {int} R Maximum visibility radius\n * @param {int} dir Direction to look in (expressed in a ROT.DIRS value);\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype.compute90 = function(x, y, R, dir, callback) {\n\t//You can always see your own tile\n\tcallback(x, y, 0, 1);\n\tvar previousOctant = (dir - 1 + 8) % 8; //Need to retrieve the previous octant to render a full 90 degrees\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[dir], R, callback);\n\tthis._renderOctant(x, y, ROT.FOV.RecursiveShadowcasting.OCTANTS[previousOctant], R, callback);\n}\n\n/**\n * Render one octant (45-degree arc) of the viewshed\n * @param {int} x\n * @param {int} y\n * @param {int} octant Octant to be rendered\n * @param {int} R Maximum visibility radius\n * @param {function} callback\n */\nROT.FOV.RecursiveShadowcasting.prototype._renderOctant = function(x, y, octant, R, callback) {\n\t//Radius incremented by 1 to provide same coverage area as other shadowcasting radiuses\n\tthis._castVisibility(x, y, 1, 1.0, 0.0, R + 1, octant[0], octant[1], octant[2], octant[3], callback);\n}\n\n/**\n * Actually calculates the visibility\n * @param {int} startX The starting X coordinate\n * @param {int} startY The starting Y coordinate\n * @param {int} row The row to render\n * @param {float} visSlopeStart The slope to start at\n * @param {float} visSlopeEnd The slope to end at\n * @param {int} radius The radius to reach out to\n * @param {int} xx \n * @param {int} xy \n * @param {int} yx \n * @param {int} yy \n * @param {function} callback The callback to use when we hit a block that is visible\n */\nROT.FOV.RecursiveShadowcasting.prototype._castVisibility = function(startX, startY, row, visSlopeStart, visSlopeEnd, radius, xx, xy, yx, yy, callback) {\n\tif(visSlopeStart < visSlopeEnd) { return; }\n\tfor(var i = row; i <= radius; i++) {\n\t\tvar dx = -i - 1;\n\t\tvar dy = -i;\n\t\tvar blocked = false;\n\t\tvar newStart = 0;\n\n\t\t//'Row' could be column, names here assume octant 0 and would be flipped for half the octants\n\t\twhile(dx <= 0) {\n\t\t\tdx += 1;\n\n\t\t\t//Translate from relative coordinates to map coordinates\n\t\t\tvar mapX = startX + dx * xx + dy * xy;\n\t\t\tvar mapY = startY + dx * yx + dy * yy;\n\n\t\t\t//Range of the row\n\t\t\tvar slopeStart = (dx - 0.5) / (dy + 0.5);\n\t\t\tvar slopeEnd = (dx + 0.5) / (dy - 0.5);\n\t\t\n\t\t\t//Ignore if not yet at left edge of Octant\n\t\t\tif(slopeEnd > visSlopeStart) { continue; }\n\t\t\t\n\t\t\t//Done if past right edge\n\t\t\tif(slopeStart < visSlopeEnd) { break; }\n\t\t\t\t\n\t\t\t//If it's in range, it's visible\n\t\t\tif((dx * dx + dy * dy) < (radius * radius)) {\n\t\t\t\tcallback(mapX, mapY, i, 1);\n\t\t\t}\n\t\n\t\t\tif(!blocked) {\n\t\t\t\t//If tile is a blocking tile, cast around it\n\t\t\t\tif(!this._lightPasses(mapX, mapY) && i < radius) {\n\t\t\t\t\tblocked = true;\n\t\t\t\t\tthis._castVisibility(startX, startY, i + 1, visSlopeStart, slopeStart, radius, xx, xy, yx, yy, callback);\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Keep narrowing if scanning across a block\n\t\t\t\tif(!this._lightPasses(mapX, mapY)) {\n\t\t\t\t\tnewStart = slopeEnd;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t//Block has ended\n\t\t\t\tblocked = false;\n\t\t\t\tvisSlopeStart = newStart;\n\t\t\t}\n\t\t}\n\t\tif(blocked) { break; }\n\t}\n}\n/**\n * @namespace Color operations\n */\nROT.Color = {\n\tfromString: function(str) {\n\t\tvar cached, r;\n\t\tif (str in this._cache) {\n\t\t\tcached = this._cache[str];\n\t\t} else {\n\t\t\tif (str.charAt(0) == \"#\") { /* hex rgb */\n\n\t\t\t\tvar values = str.match(/[0-9a-f]/gi).map(function(x) { return parseInt(x, 16); });\n\t\t\t\tif (values.length == 3) {\n\t\t\t\t\tcached = values.map(function(x) { return x*17; });\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i=0;i<3;i++) {\n\t\t\t\t\t\tvalues[i+1] += 16*values[i];\n\t\t\t\t\t\tvalues.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tcached = values;\n\t\t\t\t}\n\n\t\t\t} else if ((r = str.match(/rgb\\(([0-9, ]+)\\)/i))) { /* decimal rgb */\n\t\t\t\tcached = r[1].split(/\\s*,\\s*/).map(function(x) { return parseInt(x); });\n\t\t\t} else { /* html name */\n\t\t\t\tcached = [0, 0, 0];\n\t\t\t}\n\n\t\t\tthis._cache[str] = cached;\n\t\t}\n\n\t\treturn cached.slice();\n\t},\n\n\t/**\n\t * Add two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Add two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tadd_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] += arguments[j][i];\n\t\t\t}\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply: function(color1, color2) {\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tresult[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tresult[i] = Math.round(result[i]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Multiply (mix) two or more colors, MODIFIES FIRST ARGUMENT\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @returns {number[]}\n\t */\n\tmultiply_: function(color1, color2) {\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tfor (var j=1;j<arguments.length;j++) {\n\t\t\t\tcolor1[i] *= arguments[j][i] / 255;\n\t\t\t}\n\t\t\tcolor1[i] = Math.round(color1[i]);\n\t\t}\n\t\treturn color1;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolate: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar result = color1.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] = Math.round(result[i] + factor*(color2[i]-color1[i]));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Interpolate (blend) two colors with a given factor in HSL mode\n\t * @param {number[]} color1\n\t * @param {number[]} color2\n\t * @param {float} [factor=0.5] 0..1\n\t * @returns {number[]}\n\t */\n\tinterpolateHSL: function(color1, color2, factor) {\n\t\tif (arguments.length < 3) { factor = 0.5; }\n\t\tvar hsl1 = this.rgb2hsl(color1);\n\t\tvar hsl2 = this.rgb2hsl(color2);\n\t\tfor (var i=0;i<3;i++) {\n\t\t\thsl1[i] += factor*(hsl2[i]-hsl1[i]);\n\t\t}\n\t\treturn this.hsl2rgb(hsl1);\n\t},\n\n\t/**\n\t * Create a new random color based on this one\n\t * @param {number[]} color\n\t * @param {number[]} diff Set of standard deviations\n\t * @returns {number[]}\n\t */\n\trandomize: function(color, diff) {\n\t\tif (!(diff instanceof Array)) { diff = Math.round(ROT.RNG.getNormal(0, diff)); }\n\t\tvar result = color.slice();\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tresult[i] += (diff instanceof Array ? Math.round(ROT.RNG.getNormal(0, diff[i])) : diff);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts an RGB color value to HSL. Expects 0..255 inputs, produces 0..1 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\trgb2hsl: function(color) {\n\t\tvar r = color[0]/255;\n\t\tvar g = color[1]/255;\n\t\tvar b = color[2]/255;\n\n\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\tvar h, s, l = (max + min) / 2;\n\n\t\tif (max == min) {\n\t\t\th = s = 0; // achromatic\n\t\t} else {\n\t\t\tvar d = max - min;\n\t\t\ts = (l > 0.5 ? d / (2 - max - min) : d / (max + min));\n\t\t\tswitch(max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t}\n\t\t\th /= 6;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t/**\n\t * Converts an HSL color value to RGB. Expects 0..1 inputs, produces 0..255 outputs.\n\t * @param {number[]} color\n\t * @returns {number[]}\n\t */\n\thsl2rgb: function(color) {\n\t\tvar l = color[2];\n\n\t\tif (color[1] == 0) {\n\t\t\tl = Math.round(l*255);\n\t\t\treturn [l, l, l];\n\t\t} else {\n\t\t\tvar hue2rgb = function(p, q, t) {\n\t\t\t\tif (t < 0) t += 1;\n\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\tif (t < 1/6) return p + (q - p) * 6 * t;\n\t\t\t\tif (t < 1/2) return q;\n\t\t\t\tif (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tvar s = color[1];\n\t\t\tvar q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n\t\t\tvar p = 2 * l - q;\n\t\t\tvar r = hue2rgb(p, q, color[0] + 1/3);\n\t\t\tvar g = hue2rgb(p, q, color[0]);\n\t\t\tvar b = hue2rgb(p, q, color[0] - 1/3);\n\t\t\treturn [Math.round(r*255), Math.round(g*255), Math.round(b*255)];\n\t\t}\n\t},\n\n\ttoRGB: function(color) {\n\t\treturn \"rgb(\" + this._clamp(color[0]) + \",\" + this._clamp(color[1]) + \",\" + this._clamp(color[2]) + \")\";\n\t},\n\n\ttoHex: function(color) {\n\t\tvar parts = [];\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tparts.push(this._clamp(color[i]).toString(16).lpad(\"0\", 2));\n\t\t}\n\t\treturn \"#\" + parts.join(\"\");\n\t},\n\n\t_clamp: function(num) {\n\t\tif (num < 0) {\n\t\t\treturn 0;\n\t\t} else if (num > 255) {\n\t\t\treturn 255;\n\t\t} else {\n\t\t\treturn num;\n\t\t}\n\t},\n\n\t_cache: {\n\t\t\"black\": [0,0,0],\n\t\t\"navy\": [0,0,128],\n\t\t\"darkblue\": [0,0,139],\n\t\t\"mediumblue\": [0,0,205],\n\t\t\"blue\": [0,0,255],\n\t\t\"darkgreen\": [0,100,0],\n\t\t\"green\": [0,128,0],\n\t\t\"teal\": [0,128,128],\n\t\t\"darkcyan\": [0,139,139],\n\t\t\"deepskyblue\": [0,191,255],\n\t\t\"darkturquoise\": [0,206,209],\n\t\t\"mediumspringgreen\": [0,250,154],\n\t\t\"lime\": [0,255,0],\n\t\t\"springgreen\": [0,255,127],\n\t\t\"aqua\": [0,255,255],\n\t\t\"cyan\": [0,255,255],\n\t\t\"midnightblue\": [25,25,112],\n\t\t\"dodgerblue\": [30,144,255],\n\t\t\"forestgreen\": [34,139,34],\n\t\t\"seagreen\": [46,139,87],\n\t\t\"darkslategray\": [47,79,79],\n\t\t\"darkslategrey\": [47,79,79],\n\t\t\"limegreen\": [50,205,50],\n\t\t\"mediumseagreen\": [60,179,113],\n\t\t\"turquoise\": [64,224,208],\n\t\t\"royalblue\": [65,105,225],\n\t\t\"steelblue\": [70,130,180],\n\t\t\"darkslateblue\": [72,61,139],\n\t\t\"mediumturquoise\": [72,209,204],\n\t\t\"indigo\": [75,0,130],\n\t\t\"darkolivegreen\": [85,107,47],\n\t\t\"cadetblue\": [95,158,160],\n\t\t\"cornflowerblue\": [100,149,237],\n\t\t\"mediumaquamarine\": [102,205,170],\n\t\t\"dimgray\": [105,105,105],\n\t\t\"dimgrey\": [105,105,105],\n\t\t\"slateblue\": [106,90,205],\n\t\t\"olivedrab\": [107,142,35],\n\t\t\"slategray\": [112,128,144],\n\t\t\"slategrey\": [112,128,144],\n\t\t\"lightslategray\": [119,136,153],\n\t\t\"lightslategrey\": [119,136,153],\n\t\t\"mediumslateblue\": [123,104,238],\n\t\t\"lawngreen\": [124,252,0],\n\t\t\"chartreuse\": [127,255,0],\n\t\t\"aquamarine\": [127,255,212],\n\t\t\"maroon\": [128,0,0],\n\t\t\"purple\": [128,0,128],\n\t\t\"olive\": [128,128,0],\n\t\t\"gray\": [128,128,128],\n\t\t\"grey\": [128,128,128],\n\t\t\"skyblue\": [135,206,235],\n\t\t\"lightskyblue\": [135,206,250],\n\t\t\"blueviolet\": [138,43,226],\n\t\t\"darkred\": [139,0,0],\n\t\t\"darkmagenta\": [139,0,139],\n\t\t\"saddlebrown\": [139,69,19],\n\t\t\"darkseagreen\": [143,188,143],\n\t\t\"lightgreen\": [144,238,144],\n\t\t\"mediumpurple\": [147,112,216],\n\t\t\"darkviolet\": [148,0,211],\n\t\t\"palegreen\": [152,251,152],\n\t\t\"darkorchid\": [153,50,204],\n\t\t\"yellowgreen\": [154,205,50],\n\t\t\"sienna\": [160,82,45],\n\t\t\"brown\": [165,42,42],\n\t\t\"darkgray\": [169,169,169],\n\t\t\"darkgrey\": [169,169,169],\n\t\t\"lightblue\": [173,216,230],\n\t\t\"greenyellow\": [173,255,47],\n\t\t\"paleturquoise\": [175,238,238],\n\t\t\"lightsteelblue\": [176,196,222],\n\t\t\"powderblue\": [176,224,230],\n\t\t\"firebrick\": [178,34,34],\n\t\t\"darkgoldenrod\": [184,134,11],\n\t\t\"mediumorchid\": [186,85,211],\n\t\t\"rosybrown\": [188,143,143],\n\t\t\"darkkhaki\": [189,183,107],\n\t\t\"silver\": [192,192,192],\n\t\t\"mediumvioletred\": [199,21,133],\n\t\t\"indianred\": [205,92,92],\n\t\t\"peru\": [205,133,63],\n\t\t\"chocolate\": [210,105,30],\n\t\t\"tan\": [210,180,140],\n\t\t\"lightgray\": [211,211,211],\n\t\t\"lightgrey\": [211,211,211],\n\t\t\"palevioletred\": [216,112,147],\n\t\t\"thistle\": [216,191,216],\n\t\t\"orchid\": [218,112,214],\n\t\t\"goldenrod\": [218,165,32],\n\t\t\"crimson\": [220,20,60],\n\t\t\"gainsboro\": [220,220,220],\n\t\t\"plum\": [221,160,221],\n\t\t\"burlywood\": [222,184,135],\n\t\t\"lightcyan\": [224,255,255],\n\t\t\"lavender\": [230,230,250],\n\t\t\"darksalmon\": [233,150,122],\n\t\t\"violet\": [238,130,238],\n\t\t\"palegoldenrod\": [238,232,170],\n\t\t\"lightcoral\": [240,128,128],\n\t\t\"khaki\": [240,230,140],\n\t\t\"aliceblue\": [240,248,255],\n\t\t\"honeydew\": [240,255,240],\n\t\t\"azure\": [240,255,255],\n\t\t\"sandybrown\": [244,164,96],\n\t\t\"wheat\": [245,222,179],\n\t\t\"beige\": [245,245,220],\n\t\t\"whitesmoke\": [245,245,245],\n\t\t\"mintcream\": [245,255,250],\n\t\t\"ghostwhite\": [248,248,255],\n\t\t\"salmon\": [250,128,114],\n\t\t\"antiquewhite\": [250,235,215],\n\t\t\"linen\": [250,240,230],\n\t\t\"lightgoldenrodyellow\": [250,250,210],\n\t\t\"oldlace\": [253,245,230],\n\t\t\"red\": [255,0,0],\n\t\t\"fuchsia\": [255,0,255],\n\t\t\"magenta\": [255,0,255],\n\t\t\"deeppink\": [255,20,147],\n\t\t\"orangered\": [255,69,0],\n\t\t\"tomato\": [255,99,71],\n\t\t\"hotpink\": [255,105,180],\n\t\t\"coral\": [255,127,80],\n\t\t\"darkorange\": [255,140,0],\n\t\t\"lightsalmon\": [255,160,122],\n\t\t\"orange\": [255,165,0],\n\t\t\"lightpink\": [255,182,193],\n\t\t\"pink\": [255,192,203],\n\t\t\"gold\": [255,215,0],\n\t\t\"peachpuff\": [255,218,185],\n\t\t\"navajowhite\": [255,222,173],\n\t\t\"moccasin\": [255,228,181],\n\t\t\"bisque\": [255,228,196],\n\t\t\"mistyrose\": [255,228,225],\n\t\t\"blanchedalmond\": [255,235,205],\n\t\t\"papayawhip\": [255,239,213],\n\t\t\"lavenderblush\": [255,240,245],\n\t\t\"seashell\": [255,245,238],\n\t\t\"cornsilk\": [255,248,220],\n\t\t\"lemonchiffon\": [255,250,205],\n\t\t\"floralwhite\": [255,250,240],\n\t\t\"snow\": [255,250,250],\n\t\t\"yellow\": [255,255,0],\n\t\t\"lightyellow\": [255,255,224],\n\t\t\"ivory\": [255,255,240],\n\t\t\"white\": [255,255,255]\n\t}\n}\n/**\n * @class Lighting computation, based on a traditional FOV for multiple light sources and multiple passes.\n * @param {function} reflectivityCallback Callback to retrieve cell reflectivity (0..1)\n * @param {object} [options]\n * @param {int} [options.passes=1] Number of passes. 1 equals to simple FOV of all light sources, >1 means a *highly simplified* radiosity-like algorithm.\n * @param {int} [options.emissionThreshold=100] Cells with emissivity > threshold will be treated as light source in the next pass.\n * @param {int} [options.range=10] Max light range\n */\nROT.Lighting = function(reflectivityCallback, options) {\n\tthis._reflectivityCallback = reflectivityCallback;\n\tthis._options = {\n\t\tpasses: 1,\n\t\temissionThreshold: 100,\n\t\trange: 10\n\t};\n\tthis._fov = null;\n\n\tthis._lights = {};\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\tthis.setOptions(options);\n}\n\n/**\n * Adjust options at runtime\n * @see ROT.Lighting\n * @param {object} [options]\n */\nROT.Lighting.prototype.setOptions = function(options) {\n\tfor (var p in options) { this._options[p] = options[p]; }\n\tif (options && options.range) { this.reset(); }\n\treturn this;\n}\n\n/**\n * Set the used Field-Of-View algo\n * @param {ROT.FOV} fov\n */\nROT.Lighting.prototype.setFOV = function(fov) {\n\tthis._fov = fov;\n\tthis._fovCache = {};\n\treturn this;\n}\n\n/**\n * Set (or remove) a light source\n * @param {int} x\n * @param {int} y\n * @param {null || string || number[3]} color\n */\nROT.Lighting.prototype.setLight = function(x, y, color) {\n\tvar key = x+\",\"+y;\n\n\tif (color) {\n\t\tthis._lights[key] = (typeof(color) == \"string\" ? ROT.Color.fromString(color) : color);\n\t} else {\n\t\tdelete this._lights[key];\n\t}\n\treturn this;\n}\n\n/**\n * Remove all light sources\n */\nROT.Lighting.prototype.clearLights = function() {\n    this._lights = {};\n}\n\n/**\n * Reset the pre-computed topology values. Call whenever the underlying map changes its light-passability.\n */\nROT.Lighting.prototype.reset = function() {\n\tthis._reflectivityCache = {};\n\tthis._fovCache = {};\n\n\treturn this;\n}\n\n/**\n * Compute the lighting\n * @param {function} lightingCallback Will be called with (x, y, color) for every lit cell\n */\nROT.Lighting.prototype.compute = function(lightingCallback) {\n\tvar doneCells = {};\n\tvar emittingCells = {};\n\tvar litCells = {};\n\n\tfor (var key in this._lights) { /* prepare emitters for first pass */\n\t\tvar light = this._lights[key];\n\t\temittingCells[key] = [0, 0, 0];\n\t\tROT.Color.add_(emittingCells[key], light);\n\t}\n\n\tfor (var i=0;i<this._options.passes;i++) { /* main loop */\n\t\tthis._emitLight(emittingCells, litCells, doneCells);\n\t\tif (i+1 == this._options.passes) { continue; } /* not for the last pass */\n\t\temittingCells = this._computeEmitters(litCells, doneCells);\n\t}\n\n\tfor (var litKey in litCells) { /* let the user know what and how is lit */\n\t\tvar parts = litKey.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tlightingCallback(x, y, litCells[litKey]);\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute one iteration from all emitting cells\n * @param {object} emittingCells These emit light\n * @param {object} litCells Add projected light to these\n * @param {object} doneCells These already emitted, forbid them from further calculations\n */\nROT.Lighting.prototype._emitLight = function(emittingCells, litCells, doneCells) {\n\tfor (var key in emittingCells) {\n\t\tvar parts = key.split(\",\");\n\t\tvar x = parseInt(parts[0]);\n\t\tvar y = parseInt(parts[1]);\n\t\tthis._emitLightFromCell(x, y, emittingCells[key], litCells);\n\t\tdoneCells[key] = 1;\n\t}\n\treturn this;\n}\n\n/**\n * Prepare a list of emitters for next pass\n * @param {object} litCells\n * @param {object} doneCells\n * @returns {object}\n */\nROT.Lighting.prototype._computeEmitters = function(litCells, doneCells) {\n\tvar result = {};\n\n\tfor (var key in litCells) {\n\t\tif (key in doneCells) { continue; } /* already emitted */\n\n\t\tvar color = litCells[key];\n\n\t\tif (key in this._reflectivityCache) {\n\t\t\tvar reflectivity = this._reflectivityCache[key];\n\t\t} else {\n\t\t\tvar parts = key.split(\",\");\n\t\t\tvar x = parseInt(parts[0]);\n\t\t\tvar y = parseInt(parts[1]);\n\t\t\tvar reflectivity = this._reflectivityCallback(x, y);\n\t\t\tthis._reflectivityCache[key] = reflectivity;\n\t\t}\n\n\t\tif (reflectivity == 0) { continue; } /* will not reflect at all */\n\n\t\t/* compute emission color */\n\t\tvar emission = [];\n\t\tvar intensity = 0;\n\t\tfor (var i=0;i<3;i++) {\n\t\t\tvar part = Math.round(color[i]*reflectivity);\n\t\t\temission[i] = part;\n\t\t\tintensity += part;\n\t\t}\n\t\tif (intensity > this._options.emissionThreshold) { result[key] = emission; }\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute one iteration from one cell\n * @param {int} x\n * @param {int} y\n * @param {number[]} color\n * @param {object} litCells Cell data to by updated\n */\nROT.Lighting.prototype._emitLightFromCell = function(x, y, color, litCells) {\n\tvar key = x+\",\"+y;\n\tif (key in this._fovCache) {\n\t\tvar fov = this._fovCache[key];\n\t} else {\n\t\tvar fov = this._updateFOV(x, y);\n\t}\n\n\tfor (var fovKey in fov) {\n\t\tvar formFactor = fov[fovKey];\n\n\t\tif (fovKey in litCells) { /* already lit */\n\t\t\tvar result = litCells[fovKey];\n\t\t} else { /* newly lit */\n\t\t\tvar result = [0, 0, 0];\n\t\t\tlitCells[fovKey] = result;\n\t\t}\n\n\t\tfor (var i=0;i<3;i++) { result[i] += Math.round(color[i]*formFactor); } /* add light color */\n\t}\n\n\treturn this;\n}\n\n/**\n * Compute FOV (\"form factor\") for a potential light source at [x,y]\n * @param {int} x\n * @param {int} y\n * @returns {object}\n */\nROT.Lighting.prototype._updateFOV = function(x, y) {\n\tvar key1 = x+\",\"+y;\n\tvar cache = {};\n\tthis._fovCache[key1] = cache;\n\tvar range = this._options.range;\n\tvar cb = function(x, y, r, vis) {\n\t\tvar key2 = x+\",\"+y;\n\t\tvar formFactor = vis * (1-r/range);\n\t\tif (formFactor == 0) { return; }\n\t\tcache[key2] = formFactor;\n\t}\n\tthis._fov.compute(x, y, range, cb.bind(this));\n\n\treturn cache;\n}\n/**\n * @class Abstract pathfinder\n * @param {int} toX Target X coord\n * @param {int} toY Target Y coord\n * @param {function} passableCallback Callback to determine map passability\n * @param {object} [options]\n * @param {int} [options.topology=8]\n */\nROT.Path = function(toX, toY, passableCallback, options) {\n\tthis._toX = toX;\n\tthis._toY = toY;\n\tthis._fromX = null;\n\tthis._fromY = null;\n\tthis._passableCallback = passableCallback;\n\tthis._options = {\n\t\ttopology: 8\n\t}\n\tfor (var p in options) { this._options[p] = options[p]; }\n\n\tthis._dirs = ROT.DIRS[this._options.topology];\n\tif (this._options.topology == 8) { /* reorder dirs for more aesthetic result (vertical/horizontal first) */\n\t\tthis._dirs = [\n\t\t\tthis._dirs[0],\n\t\t\tthis._dirs[2],\n\t\t\tthis._dirs[4],\n\t\t\tthis._dirs[6],\n\t\t\tthis._dirs[1],\n\t\t\tthis._dirs[3],\n\t\t\tthis._dirs[5],\n\t\t\tthis._dirs[7]\n\t\t]\n\t}\n}\n\n/**\n * Compute a path from a given point\n * @param {int} fromX\n * @param {int} fromY\n * @param {function} callback Will be called for every path item with arguments \"x\" and \"y\"\n */\nROT.Path.prototype.compute = function(fromX, fromY, callback) {\n}\n\nROT.Path.prototype._getNeighbors = function(cx, cy) {\n\tvar result = [];\n\tfor (var i=0;i<this._dirs.length;i++) {\n\t\tvar dir = this._dirs[i];\n\t\tvar x = cx + dir[0];\n\t\tvar y = cy + dir[1];\n\t\t\n\t\tif (!this._passableCallback(x, y)) { continue; }\n\t\tresult.push([x, y]);\n\t}\n\t\n\treturn result;\n}\n/**\n * @class Simplified Dijkstra's algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.Dijkstra = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._computed = {};\n\tthis._todo = [];\n\tthis._add(toX, toY, null);\n}\nROT.Path.Dijkstra.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.Dijkstra.prototype.compute = function(fromX, fromY, callback) {\n\tvar key = fromX+\",\"+fromY;\n\tif (!(key in this._computed)) { this._compute(fromX, fromY); }\n\tif (!(key in this._computed)) { return; }\n\t\n\tvar item = this._computed[key];\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\n/**\n * Compute a non-cached value\n */\nROT.Path.Dijkstra.prototype._compute = function(fromX, fromY) {\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { return; }\n\t\t\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\t\t\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._computed) { continue; } /* already done */\t\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n}\n\nROT.Path.Dijkstra.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev\n\t}\n\tthis._computed[x+\",\"+y] = obj;\n\tthis._todo.push(obj);\n}\n/**\n * @class Simplified A* algorithm: all edges have a value of 1\n * @augments ROT.Path\n * @see ROT.Path\n */\nROT.Path.AStar = function(toX, toY, passableCallback, options) {\n\tROT.Path.call(this, toX, toY, passableCallback, options);\n\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = null;\n\tthis._fromY = null;\n}\nROT.Path.AStar.extend(ROT.Path);\n\n/**\n * Compute a path from a given point\n * @see ROT.Path#compute\n */\nROT.Path.AStar.prototype.compute = function(fromX, fromY, callback) {\n\tthis._todo = [];\n\tthis._done = {};\n\tthis._fromX = fromX;\n\tthis._fromY = fromY;\n\tthis._add(this._toX, this._toY, null);\n\n\twhile (this._todo.length) {\n\t\tvar item = this._todo.shift();\n\t\tif (item.x == fromX && item.y == fromY) { break; }\n\t\tvar neighbors = this._getNeighbors(item.x, item.y);\n\n\t\tfor (var i=0;i<neighbors.length;i++) {\n\t\t\tvar neighbor = neighbors[i];\n\t\t\tvar x = neighbor[0];\n\t\t\tvar y = neighbor[1];\n\t\t\tvar id = x+\",\"+y;\n\t\t\tif (id in this._done) { continue; }\n\t\t\tthis._add(x, y, item); \n\t\t}\n\t}\n\t\n\tvar item = this._done[fromX+\",\"+fromY];\n\tif (!item) { return; }\n\t\n\twhile (item) {\n\t\tcallback(item.x, item.y);\n\t\titem = item.prev;\n\t}\n}\n\nROT.Path.AStar.prototype._add = function(x, y, prev) {\n\tvar obj = {\n\t\tx: x,\n\t\ty: y,\n\t\tprev: prev,\n\t\tg: (prev ? prev.g+1 : 0),\n\t\th: this._distance(x, y)\n\t}\n\tthis._done[x+\",\"+y] = obj;\n\t\n\t/* insert into priority queue */\n\t\n\tvar f = obj.g + obj.h;\n\tfor (var i=0;i<this._todo.length;i++) {\n\t\tvar item = this._todo[i];\n\t\tif (f < item.g + item.h) {\n\t\t\tthis._todo.splice(i, 0, obj);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tthis._todo.push(obj);\n}\n\nROT.Path.AStar.prototype._distance = function(x, y) {\n\tswitch (this._options.topology) {\n\t\tcase 4:\n\t\t\treturn (Math.abs(x-this._fromX) + Math.abs(y-this._fromY));\n\t\tbreak;\n\n\t\tcase 6:\n\t\t\tvar dx = Math.abs(x - this._fromX);\n\t\t\tvar dy = Math.abs(y - this._fromY);\n\t\t\treturn dy + Math.max(0, (dx-dy)/2);\n\t\tbreak;\n\n\t\tcase 8: \n\t\t\treturn Math.max(Math.abs(x-this._fromX), Math.abs(y-this._fromY));\n\t\tbreak;\n\t}\n\n        throw new Error(\"Illegal topology\");\n}\n/**\n * @class Terminal backend\n * @private\n */\nROT.Display.Term = function(context) {\n\tROT.Display.Backend.call(this, context);\n\tthis._cx = -1;\n\tthis._cy = -1;\n\tthis._lastColor = \"\";\n\tthis._options = {};\n\tthis._ox = 0;\n\tthis._oy = 0;\n\tthis._termcolor = {};\n}\nROT.Display.Term.extend(ROT.Display.Backend);\n\nROT.Display.Term.prototype.compute = function(options) {\n\tthis._options = options;\n\tthis._ox = Math.floor((process.stdout.columns - options.width) / 2);\n\tthis._oy = Math.floor((process.stdout.rows - options.height) / 2);\n\tthis._termcolor = new ROT.Display.Term[options.termColor.capitalize()](this._context);\n\tthis._context._termcolor = this._termcolor;\n}\n\nROT.Display.Term.prototype.draw = function(data, clearBefore) {\n\t// determine where to draw what with what colors\n\tvar x = data[0];\n\tvar y = data[1];\n\tvar ch = data[2];\n\tvar fg = data[3];\n\tvar bg = data[4];\n\n\t// determine if we need to move the terminal cursor\n\tvar dx = this._ox + x;\n\tvar dy = this._oy + y;\n\tif (dx < 0 || dx >= process.stdout.columns) { return; }\n\tif (dy < 0 || dy >= process.stdout.rows) { return; }\n\tif (dx !== this._cx || dy !== this._cy) {\n\t\tprocess.stdout.write(this._termcolor.positionToAnsi(dx,dy));\n\t\tthis._cx = dx;\n\t\tthis._cy = dy;\n\t}\n\n\t// terminals automatically clear, but if we're clearing when we're\n\t// not otherwise provided with a character, just use a space instead\n\tif (clearBefore) {\n\t\tif (!ch) {\n\t\t\tch = \" \";\n\t\t}\n\t}\n\t\t\n\t// if we're not clearing and not provided with a character, do nothing\n\tif (!ch) { return; }\n\n\t// determine if we need to change colors\n\tvar newColor = this._termcolor.colorToAnsi(fg,bg);\n\tif (newColor !== this._lastColor) {\n\t\tprocess.stdout.write(newColor);\n\t\tthis._lastColor = newColor;\n\t}\n\n\t// write the provided symbol to the display\n\tvar chars = [].concat(ch);\n\tprocess.stdout.write(chars[0]);\n\n\t// update our position, given that we wrote a character\n\tthis._cx++;\n\tif (this._cx >= process.stdout.columns) {\n\t\tthis._cx = 0;\n\t\tthis._cy++;\n\t}\n}\n\nROT.Display.Term.prototype.computeSize = function(availWidth, availHeight) {\n\treturn [process.stdout.columns, process.stdout.rows];\n}\n\nROT.Display.Term.prototype.computeFontSize = function(availWidth, availHeight) {\n\treturn 12;\n}\n\nROT.Display.Term.prototype.eventToPosition = function(x, y) {\n\treturn [x,y]\n}\n/**\n * @class Abstract terminal code module\n * @private\n */\nROT.Display.Term.Color = function(context) {\n\tthis._context = context;\n}\n\nROT.Display.Term.Color.prototype.clearToAnsi = function(bg) {\n}\n\nROT.Display.Term.Color.prototype.colorToAnsi = function(fg, bg) {\n}\n\nROT.Display.Term.Color.prototype.positionToAnsi = function(x, y) {\n}\n/**\n * @class xterm terminal code module\n * @private\n */\nROT.Display.Term.Xterm = function(context) {\n\tROT.Display.Term.Color.call(this, context);\n}\nROT.Display.Term.Xterm.extend(ROT.Display.Term.Color);\n\nROT.Display.Term.Xterm.prototype.clearToAnsi = function(bg) {\n\treturn \"\\x1b[0;48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\\x1b[2J\";\n}\n\nROT.Display.Term.Xterm.prototype.colorToAnsi = function(fg, bg) {\n\treturn \"\\x1b[0;38;5;\"\n\t\t+ this._termcolor(fg)\n\t\t+ \";48;5;\"\n\t\t+ this._termcolor(bg)\n\t\t+ \"m\";\n}\n\nROT.Display.Term.Xterm.prototype.positionToAnsi = function(x, y) {\n\treturn \"\\x1b[\" + (y+1) + \";\" + (x+1) + \"H\";\n}\n\nROT.Display.Term.Xterm.prototype._termcolor = function(color) {\n\tvar SRC_COLORS = 256.0;\n\tvar DST_COLORS = 6.0;\n\tvar COLOR_RATIO = DST_COLORS / SRC_COLORS;\n\tvar rgb = ROT.Color.fromString(color);\n\tvar r = Math.floor(rgb[0] * COLOR_RATIO);\n\tvar g = Math.floor(rgb[1] * COLOR_RATIO);\n\tvar b = Math.floor(rgb[2] * COLOR_RATIO);\n\treturn r*36 + g*6 + b*1 + 16;\n}\n/**\n * Export to Node.js module\n */\nfor (var p in ROT) {\n\texports[p] = ROT[p];\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../webpack/buildin/global.js */ 0), __webpack_require__(/*! ./../../process/browser.js */ 3)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3JvdC1qcy9saWIvcm90LmpzPzY1NjAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0VGhpcyBpcyByb3QuanMsIHRoZSBST2d1ZWxpa2UgVG9vbGtpdCBpbiBKYXZhU2NyaXB0LlxuXHRWZXJzaW9uIDAuNn5kZXYsIGdlbmVyYXRlZCBvbiBNb24gTm92IDMwIDEwOjM0OjQyIENFVCAyMDE1LlxuKi9cbi8qKlxuICogQWRkIG9iamVjdHMgZm9yIE5vZGUuanMgZW52aXJvbm1lbnRcbiAqL1xuZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdHJldHVybiBzZXRUaW1lb3V0KGNiLCAxMDAwLzYwKTtcbn07XG5cbmdsb2JhbC5kb2N1bWVudCA9IHtcblx0Ym9keToge1xuXHRcdGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkge30sXG5cdFx0c2Nyb2xsTGVmdDogMCxcblx0XHRzY3JvbGxUb3A6IDBcblx0fSxcblx0Y3JlYXRlRWxlbWVudDogZnVuY3Rpb24odHlwZSkge1xuXHRcdHZhciBjYW52YXM7XG5cdFx0cmV0dXJuIGNhbnZhcyA9IHtcblx0XHRcdGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZWN0O1xuXHRcdFx0XHRyZXR1cm4gcmVjdCA9IHtcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdHRvcDogMFxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGdldENvbnRleHQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIGNvbnRleHQ7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0ID0ge1xuXHRcdFx0XHRcdF90ZXJtY29sb3I6IG51bGwsXG5cdFx0XHRcdFx0YmVnaW5QYXRoOiBmdW5jdGlvbigpIHt9LFxuXHRcdFx0XHRcdGNhbnZhczogY2FudmFzLFxuXHRcdFx0XHRcdGNsZWFyUmVjdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fdGVybWNvbG9yICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjbGVhckNtZCA9IHRoaXMuX3Rlcm1jb2xvci5jbGVhclRvQW5zaSh0aGlzLmZpbGxTdHlsZSk7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNsZWFyQ21kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRyYXdJbWFnZTogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge30sXG5cdFx0XHRcdFx0ZmlsbDogZnVuY3Rpb24oKSB7fSxcblx0XHRcdFx0XHRmaWxsUmVjdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fdGVybWNvbG9yICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjbGVhckNtZCA9IHRoaXMuX3Rlcm1jb2xvci5jbGVhclRvQW5zaSh0aGlzLmZpbGxTdHlsZSk7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNsZWFyQ21kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZpbGxTdHlsZTogXCIjMDAwXCIsXG5cdFx0XHRcdFx0ZmlsbFRleHQ6IGZ1bmN0aW9uKGNocywgeCwgeSkge30sXG5cdFx0XHRcdFx0Zm9udDogXCJtb25vc3BhY2VcIixcblx0XHRcdFx0XHRsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHt9LFxuXHRcdFx0XHRcdG1lYXN1cmVUZXh0OiBmdW5jdGlvbihjaCkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQgPSB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAxMlxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1vdmVUbzogZnVuY3Rpb24oeCwgeSkge30sXG5cdFx0XHRcdFx0dGV4dEFsaWduOiBcImNlbnRlclwiLFxuXHRcdFx0XHRcdHRleHRCYXNlbGluZTogXCJtaWRkbGVcIlxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGxlZnQ6IFwiMTAwcHhcIixcblx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0dG9wOiBcIjEwMHB4XCIsXG5cdFx0XHRcdHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcblx0XHRcdH0sXG5cdFx0XHR3aWR0aDogMFxuXHRcdH07XG5cdH0sXG5cdGRvY3VtZW50RWxlbWVudDoge1xuXHRcdHNjcm9sbExlZnQ6IDAsXG5cdFx0c2Nyb2xsVG9wOiAwXG5cdH1cbn07XG4vKipcbiAqIEBuYW1lc3BhY2UgVG9wLWxldmVsIFJPVCBuYW1lc3BhY2VcbiAqL1xudmFyIFJPVCA9IHtcblx0LyoqXG5cdCAqIEByZXR1cm5zIHtib29sfSBJcyByb3QuanMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlcj9cblx0ICovXG5cdGlzU3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0ICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKTtcblx0fSxcblxuXHQvKiogRGVmYXVsdCB3aXRoIGZvciBkaXNwbGF5IGFuZCBtYXAgZ2VuZXJhdG9ycyAqL1xuXHRERUZBVUxUX1dJRFRIOiA4MCxcblx0LyoqIERlZmF1bHQgaGVpZ2h0IGZvciBkaXNwbGF5IGFuZCBtYXAgZ2VuZXJhdG9ycyAqL1xuXHRERUZBVUxUX0hFSUdIVDogMjUsXG5cblx0LyoqIERpcmVjdGlvbmFsIGNvbnN0YW50cy4gT3JkZXJpbmcgaXMgaW1wb3J0YW50ISAqL1xuXHRESVJTOiB7XG5cdFx0XCI0XCI6IFtcblx0XHRcdFsgMCwgLTFdLFxuXHRcdFx0WyAxLCAgMF0sXG5cdFx0XHRbIDAsICAxXSxcblx0XHRcdFstMSwgIDBdXG5cdFx0XSxcblx0XHRcIjhcIjogW1xuXHRcdFx0WyAwLCAtMV0sXG5cdFx0XHRbIDEsIC0xXSxcblx0XHRcdFsgMSwgIDBdLFxuXHRcdFx0WyAxLCAgMV0sXG5cdFx0XHRbIDAsICAxXSxcblx0XHRcdFstMSwgIDFdLFxuXHRcdFx0Wy0xLCAgMF0sXG5cdFx0XHRbLTEsIC0xXVxuXHRcdF0sXG5cdFx0XCI2XCI6IFtcblx0XHRcdFstMSwgLTFdLFxuXHRcdFx0WyAxLCAtMV0sXG5cdFx0XHRbIDIsICAwXSxcblx0XHRcdFsgMSwgIDFdLFxuXHRcdFx0Wy0xLCAgMV0sXG5cdFx0XHRbLTIsICAwXVxuXHRcdF1cblx0fSxcblxuXHQvKiogQ2FuY2VsIGtleS4gKi9cblx0VktfQ0FOQ0VMOiAzLCBcblx0LyoqIEhlbHAga2V5LiAqL1xuXHRWS19IRUxQOiA2LCBcblx0LyoqIEJhY2tzcGFjZSBrZXkuICovXG5cdFZLX0JBQ0tfU1BBQ0U6IDgsIFxuXHQvKiogVGFiIGtleS4gKi9cblx0VktfVEFCOiA5LCBcblx0LyoqIDUga2V5IG9uIE51bXBhZCB3aGVuIE51bUxvY2sgaXMgdW5sb2NrZWQuIE9yIG9uIE1hYywgY2xlYXIga2V5IHdoaWNoIGlzIHBvc2l0aW9uZWQgYXQgTnVtTG9jayBrZXkuICovXG5cdFZLX0NMRUFSOiAxMiwgXG5cdC8qKiBSZXR1cm4vZW50ZXIga2V5IG9uIHRoZSBtYWluIGtleWJvYXJkLiAqL1xuXHRWS19SRVRVUk46IDEzLCBcblx0LyoqIFJlc2VydmVkLCBidXQgbm90IHVzZWQuICovXG5cdFZLX0VOVEVSOiAxNCwgXG5cdC8qKiBTaGlmdCBrZXkuICovXG5cdFZLX1NISUZUOiAxNiwgXG5cdC8qKiBDb250cm9sIGtleS4gKi9cblx0VktfQ09OVFJPTDogMTcsIFxuXHQvKiogQWx0IChPcHRpb24gb24gTWFjKSBrZXkuICovXG5cdFZLX0FMVDogMTgsIFxuXHQvKiogUGF1c2Uga2V5LiAqL1xuXHRWS19QQVVTRTogMTksIFxuXHQvKiogQ2FwcyBsb2NrLiAqL1xuXHRWS19DQVBTX0xPQ0s6IDIwLCBcblx0LyoqIEVzY2FwZSBrZXkuICovXG5cdFZLX0VTQ0FQRTogMjcsIFxuXHQvKiogU3BhY2UgYmFyLiAqL1xuXHRWS19TUEFDRTogMzIsIFxuXHQvKiogUGFnZSBVcCBrZXkuICovXG5cdFZLX1BBR0VfVVA6IDMzLCBcblx0LyoqIFBhZ2UgRG93biBrZXkuICovXG5cdFZLX1BBR0VfRE9XTjogMzQsIFxuXHQvKiogRW5kIGtleS4gKi9cblx0VktfRU5EOiAzNSwgXG5cdC8qKiBIb21lIGtleS4gKi9cblx0VktfSE9NRTogMzYsIFxuXHQvKiogTGVmdCBhcnJvdy4gKi9cblx0VktfTEVGVDogMzcsIFxuXHQvKiogVXAgYXJyb3cuICovXG5cdFZLX1VQOiAzOCwgXG5cdC8qKiBSaWdodCBhcnJvdy4gKi9cblx0VktfUklHSFQ6IDM5LCBcblx0LyoqIERvd24gYXJyb3cuICovXG5cdFZLX0RPV046IDQwLCBcblx0LyoqIFByaW50IFNjcmVlbiBrZXkuICovXG5cdFZLX1BSSU5UU0NSRUVOOiA0NCwgXG5cdC8qKiBJbnMoZXJ0KSBrZXkuICovXG5cdFZLX0lOU0VSVDogNDUsIFxuXHQvKiogRGVsKGV0ZSkga2V5LiAqL1xuXHRWS19ERUxFVEU6IDQ2LCBcblx0LyoqKi9cblx0VktfMDogNDgsXG5cdC8qKiovXG5cdFZLXzE6IDQ5LFxuXHQvKioqL1xuXHRWS18yOiA1MCxcblx0LyoqKi9cblx0VktfMzogNTEsXG5cdC8qKiovXG5cdFZLXzQ6IDUyLFxuXHQvKioqL1xuXHRWS181OiA1Myxcblx0LyoqKi9cblx0VktfNjogNTQsXG5cdC8qKiovXG5cdFZLXzc6IDU1LFxuXHQvKioqL1xuXHRWS184OiA1Nixcblx0LyoqKi9cblx0VktfOTogNTcsXG5cdC8qKiBDb2xvbiAoOikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0NPTE9OOiA1OCwgXG5cdC8qKiBTZW1pY29sb24gKDspIGtleS4gKi9cblx0VktfU0VNSUNPTE9OOiA1OSwgXG5cdC8qKiBMZXNzLXRoYW4gKDwpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19MRVNTX1RIQU46IDYwLCBcblx0LyoqIEVxdWFscyAoPSkga2V5LiAqL1xuXHRWS19FUVVBTFM6IDYxLCBcblx0LyoqIEdyZWF0ZXItdGhhbiAoPikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0dSRUFURVJfVEhBTjogNjIsIFxuXHQvKiogUXVlc3Rpb24gbWFyayAoPykga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX1FVRVNUSU9OX01BUks6IDYzLCBcblx0LyoqIEF0bWFyayAoQCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FUOiA2NCwgXG5cdC8qKiovXG5cdFZLX0E6IDY1LFxuXHQvKioqL1xuXHRWS19COiA2Nixcblx0LyoqKi9cblx0VktfQzogNjcsXG5cdC8qKiovXG5cdFZLX0Q6IDY4LFxuXHQvKioqL1xuXHRWS19FOiA2OSxcblx0LyoqKi9cblx0VktfRjogNzAsXG5cdC8qKiovXG5cdFZLX0c6IDcxLFxuXHQvKioqL1xuXHRWS19IOiA3Mixcblx0LyoqKi9cblx0VktfSTogNzMsXG5cdC8qKiovXG5cdFZLX0o6IDc0LFxuXHQvKioqL1xuXHRWS19LOiA3NSxcblx0LyoqKi9cblx0VktfTDogNzYsXG5cdC8qKiovXG5cdFZLX006IDc3LFxuXHQvKioqL1xuXHRWS19OOiA3OCxcblx0LyoqKi9cblx0VktfTzogNzksXG5cdC8qKiovXG5cdFZLX1A6IDgwLFxuXHQvKioqL1xuXHRWS19ROiA4MSxcblx0LyoqKi9cblx0VktfUjogODIsXG5cdC8qKiovXG5cdFZLX1M6IDgzLFxuXHQvKioqL1xuXHRWS19UOiA4NCxcblx0LyoqKi9cblx0VktfVTogODUsXG5cdC8qKiovXG5cdFZLX1Y6IDg2LFxuXHQvKioqL1xuXHRWS19XOiA4Nyxcblx0LyoqKi9cblx0VktfWDogODgsXG5cdC8qKiovXG5cdFZLX1k6IDg5LFxuXHQvKioqL1xuXHRWS19aOiA5MCxcblx0LyoqKi9cblx0VktfQ09OVEVYVF9NRU5VOiA5Myxcblx0LyoqIDAgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQwOiA5NiwgXG5cdC8qKiAxIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTlVNUEFEMTogOTcsIFxuXHQvKiogMiBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX05VTVBBRDI6IDk4LCBcblx0LyoqIDMgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQzOiA5OSwgXG5cdC8qKiA0IG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTlVNUEFENDogMTAwLCBcblx0LyoqIDUgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQ1OiAxMDEsIFxuXHQvKiogNiBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX05VTVBBRDY6IDEwMiwgXG5cdC8qKiA3IG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTlVNUEFENzogMTAzLCBcblx0LyoqIDggb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19OVU1QQUQ4OiAxMDQsIFxuXHQvKiogOSBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX05VTVBBRDk6IDEwNSwgXG5cdC8qKiAqIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfTVVMVElQTFk6IDEwNixcblx0LyoqICsgb24gdGhlIG51bWVyaWMga2V5cGFkLiAqL1xuXHRWS19BREQ6IDEwNywgXG5cdC8qKiovXG5cdFZLX1NFUEFSQVRPUjogMTA4LFxuXHQvKiogLSBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX1NVQlRSQUNUOiAxMDksIFxuXHQvKiogRGVjaW1hbCBwb2ludCBvbiB0aGUgbnVtZXJpYyBrZXlwYWQuICovXG5cdFZLX0RFQ0lNQUw6IDExMCwgXG5cdC8qKiAvIG9uIHRoZSBudW1lcmljIGtleXBhZC4gKi9cblx0VktfRElWSURFOiAxMTEsIFxuXHQvKiogRjEga2V5LiAqL1xuXHRWS19GMTogMTEyLCBcblx0LyoqIEYyIGtleS4gKi9cblx0VktfRjI6IDExMywgXG5cdC8qKiBGMyBrZXkuICovXG5cdFZLX0YzOiAxMTQsIFxuXHQvKiogRjQga2V5LiAqL1xuXHRWS19GNDogMTE1LCBcblx0LyoqIEY1IGtleS4gKi9cblx0VktfRjU6IDExNiwgXG5cdC8qKiBGNiBrZXkuICovXG5cdFZLX0Y2OiAxMTcsIFxuXHQvKiogRjcga2V5LiAqL1xuXHRWS19GNzogMTE4LCBcblx0LyoqIEY4IGtleS4gKi9cblx0VktfRjg6IDExOSwgXG5cdC8qKiBGOSBrZXkuICovXG5cdFZLX0Y5OiAxMjAsIFxuXHQvKiogRjEwIGtleS4gKi9cblx0VktfRjEwOiAxMjEsIFxuXHQvKiogRjExIGtleS4gKi9cblx0VktfRjExOiAxMjIsIFxuXHQvKiogRjEyIGtleS4gKi9cblx0VktfRjEyOiAxMjMsIFxuXHQvKiogRjEzIGtleS4gKi9cblx0VktfRjEzOiAxMjQsIFxuXHQvKiogRjE0IGtleS4gKi9cblx0VktfRjE0OiAxMjUsIFxuXHQvKiogRjE1IGtleS4gKi9cblx0VktfRjE1OiAxMjYsIFxuXHQvKiogRjE2IGtleS4gKi9cblx0VktfRjE2OiAxMjcsIFxuXHQvKiogRjE3IGtleS4gKi9cblx0VktfRjE3OiAxMjgsIFxuXHQvKiogRjE4IGtleS4gKi9cblx0VktfRjE4OiAxMjksIFxuXHQvKiogRjE5IGtleS4gKi9cblx0VktfRjE5OiAxMzAsIFxuXHQvKiogRjIwIGtleS4gKi9cblx0VktfRjIwOiAxMzEsIFxuXHQvKiogRjIxIGtleS4gKi9cblx0VktfRjIxOiAxMzIsIFxuXHQvKiogRjIyIGtleS4gKi9cblx0VktfRjIyOiAxMzMsIFxuXHQvKiogRjIzIGtleS4gKi9cblx0VktfRjIzOiAxMzQsIFxuXHQvKiogRjI0IGtleS4gKi9cblx0VktfRjI0OiAxMzUsIFxuXHQvKiogTnVtIExvY2sga2V5LiAqL1xuXHRWS19OVU1fTE9DSzogMTQ0LCBcblx0LyoqIFNjcm9sbCBMb2NrIGtleS4gKi9cblx0VktfU0NST0xMX0xPQ0s6IDE0NSwgXG5cdC8qKiBDaXJjdW1mbGV4ICheKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfQ0lSQ1VNRkxFWDogMTYwLCBcblx0LyoqIEV4Y2xhbWF0aW9uICghKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfRVhDTEFNQVRJT046IDE2MSwgXG5cdC8qKiBEb3VibGUgcXVvdGUgKCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0RPVUJMRV9RVU9URTogMTYyLCBcblx0LyoqIEhhc2ggKCMpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19IQVNIOiAxNjMsIFxuXHQvKiogRG9sbGFyIHNpZ24gKCQpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19ET0xMQVI6IDE2NCwgXG5cdC8qKiBQZXJjZW50ICglKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfUEVSQ0VOVDogMTY1LCBcblx0LyoqIEFtcGVyc2FuZCAoJikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FNUEVSU0FORDogMTY2LCBcblx0LyoqIFVuZGVyc2NvcmUgKF8pIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19VTkRFUlNDT1JFOiAxNjcsIFxuXHQvKiogT3BlbiBwYXJlbnRoZXNpcyAoKCkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX09QRU5fUEFSRU46IDE2OCwgXG5cdC8qKiBDbG9zZSBwYXJlbnRoZXNpcyAoKSkga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0NMT1NFX1BBUkVOOiAxNjksIFxuXHQvKiBBc3RlcmlzayAoKikga2V5LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FTVEVSSVNLOiAxNzAsXG5cdC8qKiBQbHVzICgrKSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfUExVUzogMTcxLCBcblx0LyoqIFBpcGUgKHwpIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19QSVBFOiAxNzIsIFxuXHQvKiogSHlwaGVuLVVTL2RvY3MvTWludXMgKC0pIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19IWVBIRU5fTUlOVVM6IDE3MywgXG5cdC8qKiBPcGVuIGN1cmx5IGJyYWNrZXQgKHspIGtleS4gUmVxdWlyZXMgR2Vja28gMTUuMCAqL1xuXHRWS19PUEVOX0NVUkxZX0JSQUNLRVQ6IDE3NCwgXG5cdC8qKiBDbG9zZSBjdXJseSBicmFja2V0ICh9KSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfQ0xPU0VfQ1VSTFlfQlJBQ0tFVDogMTc1LCBcblx0LyoqIFRpbGRlICh+KSBrZXkuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfVElMREU6IDE3NiwgXG5cdC8qKiBDb21tYSAoLCkga2V5LiAqL1xuXHRWS19DT01NQTogMTg4LCBcblx0LyoqIFBlcmlvZCAoLikga2V5LiAqL1xuXHRWS19QRVJJT0Q6IDE5MCwgXG5cdC8qKiBTbGFzaCAoLykga2V5LiAqL1xuXHRWS19TTEFTSDogMTkxLCBcblx0LyoqIEJhY2sgdGljayAoYCkga2V5LiAqL1xuXHRWS19CQUNLX1FVT1RFOiAxOTIsIFxuXHQvKiogT3BlbiBzcXVhcmUgYnJhY2tldCAoWykga2V5LiAqL1xuXHRWS19PUEVOX0JSQUNLRVQ6IDIxOSwgXG5cdC8qKiBCYWNrIHNsYXNoIChcXCkga2V5LiAqL1xuXHRWS19CQUNLX1NMQVNIOiAyMjAsIFxuXHQvKiogQ2xvc2Ugc3F1YXJlIGJyYWNrZXQgKF0pIGtleS4gKi9cblx0VktfQ0xPU0VfQlJBQ0tFVDogMjIxLCBcblx0LyoqIFF1b3RlICgnJycpIGtleS4gKi9cblx0VktfUVVPVEU6IDIyMiwgXG5cdC8qKiBNZXRhIGtleSBvbiBMaW51eCwgQ29tbWFuZCBrZXkgb24gTWFjLiAqL1xuXHRWS19NRVRBOiAyMjQsIFxuXHQvKiogQWx0R3Iga2V5IG9uIExpbnV4LiBSZXF1aXJlcyBHZWNrbyAxNS4wICovXG5cdFZLX0FMVEdSOiAyMjUsIFxuXHQvKiogV2luZG93cyBsb2dvIGtleSBvbiBXaW5kb3dzLiBPciBTdXBlciBvciBIeXBlciBrZXkgb24gTGludXguIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfV0lOOiA5MSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfS0FOQTogMjEsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX0hBTkdVTDogMjEsIFxuXHQvKiog6Iux5pWwIGtleSBvbiBKYXBhbmVzZSBNYWMga2V5Ym9hcmQuIFJlcXVpcmVzIEdlY2tvIDE1LjAgKi9cblx0VktfRUlTVTogMjIsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX0pVTkpBOiAyMywgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfRklOQUw6IDI0LCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19IQU5KQTogMjUsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX0tBTkpJOiAyNSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfQ09OVkVSVDogMjgsIFxuXHQvKiogTGludXggc3VwcG9ydCBmb3IgdGhpcyBrZXljb2RlIHdhcyBhZGRlZCBpbiBHZWNrbyA0LjAuICovXG5cdFZLX05PTkNPTlZFUlQ6IDI5LCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19BQ0NFUFQ6IDMwLCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19NT0RFQ0hBTkdFOiAzMSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfU0VMRUNUOiA0MSwgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC4gKi9cblx0VktfUFJJTlQ6IDQyLCBcblx0LyoqIExpbnV4IHN1cHBvcnQgZm9yIHRoaXMga2V5Y29kZSB3YXMgYWRkZWQgaW4gR2Vja28gNC4wLiAqL1xuXHRWS19FWEVDVVRFOiA0MywgXG5cdC8qKiBMaW51eCBzdXBwb3J0IGZvciB0aGlzIGtleWNvZGUgd2FzIGFkZGVkIGluIEdlY2tvIDQuMC5cdCAqL1xuXHRWS19TTEVFUDogOTUgXG59O1xuLyoqXG4gKiBAbmFtZXNwYWNlXG4gKiBDb250YWlucyB0ZXh0IHRva2VuaXphdGlvbiBhbmQgYnJlYWtpbmcgcm91dGluZXNcbiAqL1xuUk9ULlRleHQgPSB7XG5cdFJFX0NPTE9SUzogLyUoW2JjXSl7KFtefV0qKX0vZyxcblxuXHQvKiB0b2tlbiB0eXBlcyAqL1xuXHRUWVBFX1RFWFQ6XHRcdDAsXG5cdFRZUEVfTkVXTElORTpcdDEsXG5cdFRZUEVfRkc6XHRcdDIsXG5cdFRZUEVfQkc6XHRcdDMsXG5cblx0LyoqXG5cdCAqIE1lYXN1cmUgc2l6ZSBvZiBhIHJlc3VsdGluZyB0ZXh0IGJsb2NrXG5cdCAqL1xuXHRtZWFzdXJlOiBmdW5jdGlvbihzdHIsIG1heFdpZHRoKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHt3aWR0aDowLCBoZWlnaHQ6MX07XG5cdFx0dmFyIHRva2VucyA9IHRoaXMudG9rZW5pemUoc3RyLCBtYXhXaWR0aCk7XG5cdFx0dmFyIGxpbmVXaWR0aCA9IDA7XG5cblx0XHRmb3IgKHZhciBpPTA7aTx0b2tlbnMubGVuZ3RoO2krKykge1xuXHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdFx0c3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdFx0XHRcdGNhc2UgdGhpcy5UWVBFX1RFWFQ6XG5cdFx0XHRcdFx0bGluZVdpZHRoICs9IHRva2VuLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSB0aGlzLlRZUEVfTkVXTElORTpcblx0XHRcdFx0XHRyZXN1bHQuaGVpZ2h0Kys7XG5cdFx0XHRcdFx0cmVzdWx0LndpZHRoID0gTWF0aC5tYXgocmVzdWx0LndpZHRoLCBsaW5lV2lkdGgpO1xuXHRcdFx0XHRcdGxpbmVXaWR0aCA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQud2lkdGggPSBNYXRoLm1heChyZXN1bHQud2lkdGgsIGxpbmVXaWR0aCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHN0cmluZyB0byBhIHNlcmllcyBvZiBhIGZvcm1hdHRpbmcgY29tbWFuZHNcblx0ICovXG5cdHRva2VuaXplOiBmdW5jdGlvbihzdHIsIG1heFdpZHRoKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0LyogZmlyc3QgdG9rZW5pemF0aW9uIHBhc3MgLSBzcGxpdCB0ZXh0cyBhbmQgY29sb3IgZm9ybWF0dGluZyBjb21tYW5kcyAqL1xuXHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdHN0ci5yZXBsYWNlKHRoaXMuUkVfQ09MT1JTLCBmdW5jdGlvbihtYXRjaCwgdHlwZSwgbmFtZSwgaW5kZXgpIHtcblx0XHRcdC8qIHN0cmluZyBiZWZvcmUgKi9cblx0XHRcdHZhciBwYXJ0ID0gc3RyLnN1YnN0cmluZyhvZmZzZXQsIGluZGV4KTtcblx0XHRcdGlmIChwYXJ0Lmxlbmd0aCkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdFx0dHlwZTogUk9ULlRleHQuVFlQRV9URVhULFxuXHRcdFx0XHRcdHZhbHVlOiBwYXJ0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBjb2xvciBjb21tYW5kICovXG5cdFx0XHRyZXN1bHQucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICh0eXBlID09IFwiY1wiID8gUk9ULlRleHQuVFlQRV9GRyA6IFJPVC5UZXh0LlRZUEVfQkcpLFxuXHRcdFx0XHR2YWx1ZTogbmFtZS50cmltKClcblx0XHRcdH0pO1xuXG5cdFx0XHRvZmZzZXQgPSBpbmRleCArIG1hdGNoLmxlbmd0aDtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0pO1xuXG5cdFx0LyogbGFzdCByZW1haW5pbmcgcGFydCAqL1xuXHRcdHZhciBwYXJ0ID0gc3RyLnN1YnN0cmluZyhvZmZzZXQpO1xuXHRcdGlmIChwYXJ0Lmxlbmd0aCkge1xuXHRcdFx0cmVzdWx0LnB1c2goe1xuXHRcdFx0XHR0eXBlOiBST1QuVGV4dC5UWVBFX1RFWFQsXG5cdFx0XHRcdHZhbHVlOiBwYXJ0XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fYnJlYWtMaW5lcyhyZXN1bHQsIG1heFdpZHRoKTtcblx0fSxcblxuXHQvKiBpbnNlcnQgbGluZSBicmVha3MgaW50byBmaXJzdC1wYXNzIHRva2VuaXplZCBkYXRhICovXG5cdF9icmVha0xpbmVzOiBmdW5jdGlvbih0b2tlbnMsIG1heFdpZHRoKSB7XG5cdFx0aWYgKCFtYXhXaWR0aCkgeyBtYXhXaWR0aCA9IEluZmluaXR5OyB9O1xuXG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBsaW5lTGVuZ3RoID0gMDtcblx0XHR2YXIgbGFzdFRva2VuV2l0aFNwYWNlID0gLTE7XG5cblx0XHR3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHsgLyogdGFrZSBhbGwgdGV4dCB0b2tlbnMsIHJlbW92ZSBzcGFjZSwgYXBwbHkgbGluZWJyZWFrcyAqL1xuXHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT0gUk9ULlRleHQuVFlQRV9ORVdMSU5FKSB7IC8qIHJlc2V0ICovXG5cdFx0XHRcdGxpbmVMZW5ndGggPSAwOyBcblx0XHRcdFx0bGFzdFRva2VuV2l0aFNwYWNlID0gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAodG9rZW4udHlwZSAhPSBST1QuVGV4dC5UWVBFX1RFWFQpIHsgLyogc2tpcCBub24tdGV4dCB0b2tlbnMgKi9cblx0XHRcdFx0aSsrO1xuXHRcdFx0XHRjb250aW51ZTsgXG5cdFx0XHR9XG5cblx0XHRcdC8qIHJlbW92ZSBzcGFjZXMgYXQgdGhlIGJlZ2lubmluZyBvZiBsaW5lICovXG5cdFx0XHR3aGlsZSAobGluZUxlbmd0aCA9PSAwICYmIHRva2VuLnZhbHVlLmNoYXJBdCgwKSA9PSBcIiBcIikgeyB0b2tlbi52YWx1ZSA9IHRva2VuLnZhbHVlLnN1YnN0cmluZygxKTsgfVxuXG5cdFx0XHQvKiBmb3JjZWQgbmV3bGluZT8gaW5zZXJ0IHR3byBuZXcgdG9rZW5zIGFmdGVyIHRoaXMgb25lICovXG5cdFx0XHR2YXIgaW5kZXggPSB0b2tlbi52YWx1ZS5pbmRleE9mKFwiXFxuXCIpO1xuXHRcdFx0aWYgKGluZGV4ICE9IC0xKSB7IFxuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IHRoaXMuX2JyZWFrSW5zaWRlVG9rZW4odG9rZW5zLCBpLCBpbmRleCwgdHJ1ZSk7IFxuXG5cdFx0XHRcdC8qIGlmIHRoZXJlIGFyZSBzcGFjZXMgYXQgdGhlIGVuZCwgd2UgbXVzdCByZW1vdmUgdGhlbSAod2UgZG8gbm90IHdhbnQgdGhlIGxpbmUgdG9vIGxvbmcpICovXG5cdFx0XHRcdHZhciBhcnIgPSB0b2tlbi52YWx1ZS5zcGxpdChcIlwiKTtcblx0XHRcdFx0d2hpbGUgKGFyci5sZW5ndGggJiYgYXJyW2Fyci5sZW5ndGgtMV0gPT0gXCIgXCIpIHsgYXJyLnBvcCgpOyB9XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gYXJyLmpvaW4oXCJcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8qIHRva2VuIGRlZ2VuZXJhdGVkPyAqL1xuXHRcdFx0aWYgKCF0b2tlbi52YWx1ZS5sZW5ndGgpIHtcblx0XHRcdFx0dG9rZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsaW5lTGVuZ3RoICsgdG9rZW4udmFsdWUubGVuZ3RoID4gbWF4V2lkdGgpIHsgLyogbGluZSB0b28gbG9uZywgZmluZCBhIHN1aXRhYmxlIGJyZWFraW5nIHNwb3QgKi9cblxuXHRcdFx0XHQvKiBpcyBpdCBwb3NzaWJsZSB0byBicmVhayB3aXRoaW4gdGhpcyB0b2tlbj8gKi9cblx0XHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHRcdHdoaWxlICgxKSB7XG5cdFx0XHRcdFx0dmFyIG5leHRJbmRleCA9IHRva2VuLnZhbHVlLmluZGV4T2YoXCIgXCIsIGluZGV4KzEpO1xuXHRcdFx0XHRcdGlmIChuZXh0SW5kZXggPT0gLTEpIHsgYnJlYWs7IH1cblx0XHRcdFx0XHRpZiAobGluZUxlbmd0aCArIG5leHRJbmRleCA+IG1heFdpZHRoKSB7IGJyZWFrOyB9XG5cdFx0XHRcdFx0aW5kZXggPSBuZXh0SW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaW5kZXggIT0gLTEpIHsgLyogYnJlYWsgYXQgc3BhY2Ugd2l0aGluIHRoaXMgb25lICovXG5cdFx0XHRcdFx0dG9rZW4udmFsdWUgPSB0aGlzLl9icmVha0luc2lkZVRva2VuKHRva2VucywgaSwgaW5kZXgsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxhc3RUb2tlbldpdGhTcGFjZSAhPSAtMSkgeyAvKiBpcyB0aGVyZSBhIHByZXZpb3VzIHRva2VuIHdoZXJlIGEgYnJlYWsgY2FuIG9jY3VyPyAqL1xuXHRcdFx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tsYXN0VG9rZW5XaXRoU3BhY2VdO1xuXHRcdFx0XHRcdHZhciBicmVha0luZGV4ID0gdG9rZW4udmFsdWUubGFzdEluZGV4T2YoXCIgXCIpO1xuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gdGhpcy5fYnJlYWtJbnNpZGVUb2tlbih0b2tlbnMsIGxhc3RUb2tlbldpdGhTcGFjZSwgYnJlYWtJbmRleCwgdHJ1ZSk7XG5cdFx0XHRcdFx0aSA9IGxhc3RUb2tlbldpdGhTcGFjZTtcblx0XHRcdFx0fSBlbHNlIHsgLyogZm9yY2UgYnJlYWsgaW4gdGhpcyB0b2tlbiAqL1xuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gdGhpcy5fYnJlYWtJbnNpZGVUb2tlbih0b2tlbnMsIGksIG1heFdpZHRoLWxpbmVMZW5ndGgsIGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgeyAvKiBsaW5lIG5vdCBsb25nLCBjb250aW51ZSAqL1xuXHRcdFx0XHRsaW5lTGVuZ3RoICs9IHRva2VuLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0aWYgKHRva2VuLnZhbHVlLmluZGV4T2YoXCIgXCIpICE9IC0xKSB7IGxhc3RUb2tlbldpdGhTcGFjZSA9IGk7IH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aSsrOyAvKiBhZHZhbmNlIHRvIG5leHQgdG9rZW4gKi9cblx0XHR9XG5cblxuXHRcdHRva2Vucy5wdXNoKHt0eXBlOiBST1QuVGV4dC5UWVBFX05FV0xJTkV9KTsgLyogaW5zZXJ0IGZha2UgbmV3bGluZSB0byBmaXggdGhlIGxhc3QgdGV4dCBsaW5lICovXG5cblx0XHQvKiByZW1vdmUgdHJhaWxpbmcgc3BhY2UgZnJvbSB0ZXh0IHRva2VucyBiZWZvcmUgbmV3bGluZXMgKi9cblx0XHR2YXIgbGFzdFRleHRUb2tlbiA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaT0wO2k8dG9rZW5zLmxlbmd0aDtpKyspIHtcblx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblx0XHRcdHN3aXRjaCAodG9rZW4udHlwZSkge1xuXHRcdFx0XHRjYXNlIFJPVC5UZXh0LlRZUEVfVEVYVDogbGFzdFRleHRUb2tlbiA9IHRva2VuOyBicmVhaztcblx0XHRcdFx0Y2FzZSBST1QuVGV4dC5UWVBFX05FV0xJTkU6IFxuXHRcdFx0XHRcdGlmIChsYXN0VGV4dFRva2VuKSB7IC8qIHJlbW92ZSB0cmFpbGluZyBzcGFjZSAqL1xuXHRcdFx0XHRcdFx0dmFyIGFyciA9IGxhc3RUZXh0VG9rZW4udmFsdWUuc3BsaXQoXCJcIik7XG5cdFx0XHRcdFx0XHR3aGlsZSAoYXJyLmxlbmd0aCAmJiBhcnJbYXJyLmxlbmd0aC0xXSA9PSBcIiBcIikgeyBhcnIucG9wKCk7IH1cblx0XHRcdFx0XHRcdGxhc3RUZXh0VG9rZW4udmFsdWUgPSBhcnIuam9pbihcIlwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdFRleHRUb2tlbiA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRva2Vucy5wb3AoKTsgLyogcmVtb3ZlIGZha2UgdG9rZW4gKi9cblxuXHRcdHJldHVybiB0b2tlbnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBuZXcgdG9rZW5zIGFuZCBpbnNlcnQgdGhlbSBpbnRvIHRoZSBzdHJlYW1cblx0ICogQHBhcmFtIHtvYmplY3RbXX0gdG9rZW5zXG5cdCAqIEBwYXJhbSB7aW50fSB0b2tlbkluZGV4IFRva2VuIGJlaW5nIHByb2Nlc3NlZFxuXHQgKiBAcGFyYW0ge2ludH0gYnJlYWtJbmRleCBJbmRleCB3aXRoaW4gY3VycmVudCB0b2tlbidzIHZhbHVlXG5cdCAqIEBwYXJhbSB7Ym9vbH0gcmVtb3ZlQnJlYWtDaGFyIERvIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBicmVha2luZyBjaGFyYWN0ZXI/XG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IHJlbWFpbmluZyB1bmJyb2tlbiB0b2tlbiB2YWx1ZVxuXHQgKi9cblx0X2JyZWFrSW5zaWRlVG9rZW46IGZ1bmN0aW9uKHRva2VucywgdG9rZW5JbmRleCwgYnJlYWtJbmRleCwgcmVtb3ZlQnJlYWtDaGFyKSB7XG5cdFx0dmFyIG5ld0JyZWFrVG9rZW4gPSB7XG5cdFx0XHR0eXBlOiBST1QuVGV4dC5UWVBFX05FV0xJTkVcblx0XHR9XG5cdFx0dmFyIG5ld1RleHRUb2tlbiA9IHtcblx0XHRcdHR5cGU6IFJPVC5UZXh0LlRZUEVfVEVYVCxcblx0XHRcdHZhbHVlOiB0b2tlbnNbdG9rZW5JbmRleF0udmFsdWUuc3Vic3RyaW5nKGJyZWFrSW5kZXggKyAocmVtb3ZlQnJlYWtDaGFyID8gMSA6IDApKVxuXHRcdH1cblx0XHR0b2tlbnMuc3BsaWNlKHRva2VuSW5kZXgrMSwgMCwgbmV3QnJlYWtUb2tlbiwgbmV3VGV4dFRva2VuKTtcblx0XHRyZXR1cm4gdG9rZW5zW3Rva2VuSW5kZXhdLnZhbHVlLnN1YnN0cmluZygwLCBicmVha0luZGV4KTtcblx0fVxufVxuLyoqXG4gKiBAcmV0dXJucyB7YW55fSBSYW5kb21seSBwaWNrZWQgaXRlbSwgbnVsbCB3aGVuIGxlbmd0aD0wXG4gKi9cbkFycmF5LnByb3RvdHlwZS5yYW5kb20gPSBBcnJheS5wcm90b3R5cGUucmFuZG9tIHx8IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHJldHVybiB0aGlzW01hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiB0aGlzLmxlbmd0aCldO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHthcnJheX0gTmV3IGFycmF5IHdpdGggcmFuZG9taXplZCBpdGVtc1xuICogRklYTUUgZGVzdHJveXMgdGhpcyFcbiAqL1xuQXJyYXkucHJvdG90eXBlLnJhbmRvbWl6ZSA9IEFycmF5LnByb3RvdHlwZS5yYW5kb21pemUgfHwgZnVuY3Rpb24oKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0d2hpbGUgKHRoaXMubGVuZ3RoKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKHRoaXMucmFuZG9tKCkpO1xuXHRcdHJlc3VsdC5wdXNoKHRoaXMuc3BsaWNlKGluZGV4LCAxKVswXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQWx3YXlzIHBvc2l0aXZlIG1vZHVsdXNcbiAqIEBwYXJhbSB7aW50fSBuIE1vZHVsdXNcbiAqIEByZXR1cm5zIHtpbnR9IHRoaXMgbW9kdWxvIG5cbiAqL1xuTnVtYmVyLnByb3RvdHlwZS5tb2QgPSBOdW1iZXIucHJvdG90eXBlLm1vZCB8fCBmdW5jdGlvbihuKSB7XG5cdHJldHVybiAoKHRoaXMlbikrbiklbjtcbn1cbi8qKlxuICogQHJldHVybnMge3N0cmluZ30gRmlyc3QgbGV0dGVyIGNhcGl0YWxpemVkXG4gKi9cblN0cmluZy5wcm90b3R5cGUuY2FwaXRhbGl6ZSA9IFN0cmluZy5wcm90b3R5cGUuY2FwaXRhbGl6ZSB8fCBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLnN1YnN0cmluZygxKTtcbn1cblxuLyoqIFxuICogTGVmdCBwYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcmFjdGVyPVwiMFwiXVxuICogQHBhcmFtIHtpbnR9IFtjb3VudD0yXVxuICovXG5TdHJpbmcucHJvdG90eXBlLmxwYWQgPSBTdHJpbmcucHJvdG90eXBlLmxwYWQgfHwgZnVuY3Rpb24oY2hhcmFjdGVyLCBjb3VudCkge1xuXHR2YXIgY2ggPSBjaGFyYWN0ZXIgfHwgXCIwXCI7XG5cdHZhciBjbnQgPSBjb3VudCB8fCAyO1xuXG5cdHZhciBzID0gXCJcIjtcblx0d2hpbGUgKHMubGVuZ3RoIDwgKGNudCAtIHRoaXMubGVuZ3RoKSkgeyBzICs9IGNoOyB9XG5cdHMgPSBzLnN1YnN0cmluZygwLCBjbnQtdGhpcy5sZW5ndGgpO1xuXHRyZXR1cm4gcyt0aGlzO1xufVxuXG4vKiogXG4gKiBSaWdodCBwYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcmFjdGVyPVwiMFwiXVxuICogQHBhcmFtIHtpbnR9IFtjb3VudD0yXVxuICovXG5TdHJpbmcucHJvdG90eXBlLnJwYWQgPSBTdHJpbmcucHJvdG90eXBlLnJwYWQgfHwgZnVuY3Rpb24oY2hhcmFjdGVyLCBjb3VudCkge1xuXHR2YXIgY2ggPSBjaGFyYWN0ZXIgfHwgXCIwXCI7XG5cdHZhciBjbnQgPSBjb3VudCB8fCAyO1xuXG5cdHZhciBzID0gXCJcIjtcblx0d2hpbGUgKHMubGVuZ3RoIDwgKGNudCAtIHRoaXMubGVuZ3RoKSkgeyBzICs9IGNoOyB9XG5cdHMgPSBzLnN1YnN0cmluZygwLCBjbnQtdGhpcy5sZW5ndGgpO1xuXHRyZXR1cm4gdGhpcytzO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIHN0cmluZyBpbiBhIGZsZXhpYmxlIHdheS4gU2NhbnMgZm9yICVzIHN0cmluZ3MgYW5kIHJlcGxhY2VzIHRoZW0gd2l0aCBhcmd1bWVudHMuIExpc3Qgb2YgcGF0dGVybnMgaXMgbW9kaWZpYWJsZSB2aWEgU3RyaW5nLmZvcm1hdC5tYXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAqIEBwYXJhbSB7YW55fSBbYXJndl1cbiAqL1xuU3RyaW5nLmZvcm1hdCA9IFN0cmluZy5mb3JtYXQgfHwgZnVuY3Rpb24odGVtcGxhdGUpIHtcblx0dmFyIG1hcCA9IFN0cmluZy5mb3JtYXQubWFwO1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cblx0dmFyIHJlcGxhY2VyID0gZnVuY3Rpb24obWF0Y2gsIGdyb3VwMSwgZ3JvdXAyLCBpbmRleCkge1xuXHRcdGlmICh0ZW1wbGF0ZS5jaGFyQXQoaW5kZXgtMSkgPT0gXCIlXCIpIHsgcmV0dXJuIG1hdGNoLnN1YnN0cmluZygxKTsgfVxuXHRcdGlmICghYXJncy5sZW5ndGgpIHsgcmV0dXJuIG1hdGNoOyB9XG5cdFx0dmFyIG9iaiA9IGFyZ3NbMF07XG5cblx0XHR2YXIgZ3JvdXAgPSBncm91cDEgfHwgZ3JvdXAyO1xuXHRcdHZhciBwYXJ0cyA9IGdyb3VwLnNwbGl0KFwiLFwiKTtcblx0XHR2YXIgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIG1ldGhvZCA9IG1hcFtuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHRcdGlmICghbWV0aG9kKSB7IHJldHVybiBtYXRjaDsgfVxuXG5cdFx0dmFyIG9iaiA9IGFyZ3Muc2hpZnQoKTtcblx0XHR2YXIgcmVwbGFjZWQgPSBvYmpbbWV0aG9kXS5hcHBseShvYmosIHBhcnRzKTtcblxuXHRcdHZhciBmaXJzdCA9IG5hbWUuY2hhckF0KDApO1xuXHRcdGlmIChmaXJzdCAhPSBmaXJzdC50b0xvd2VyQ2FzZSgpKSB7IHJlcGxhY2VkID0gcmVwbGFjZWQuY2FwaXRhbGl6ZSgpOyB9XG5cblx0XHRyZXR1cm4gcmVwbGFjZWQ7XG5cdH1cblx0cmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoLyUoPzooW2Etel0rKXwoPzp7KFtefV0rKX0pKS9naSwgcmVwbGFjZXIpO1xufVxuXG5TdHJpbmcuZm9ybWF0Lm1hcCA9IFN0cmluZy5mb3JtYXQubWFwIHx8IHtcblx0XCJzXCI6IFwidG9TdHJpbmdcIlxufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIFN0cmluZy5mb3JtYXQodGhpcylcbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQgPSBTdHJpbmcucHJvdG90eXBlLmZvcm1hdCB8fCBmdW5jdGlvbigpIHtcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRhcmdzLnVuc2hpZnQodGhpcyk7XG5cdHJldHVybiBTdHJpbmcuZm9ybWF0LmFwcGx5KFN0cmluZywgYXJncyk7XG59XG5cbmlmICghT2JqZWN0LmNyZWF0ZSkgeyAgXG5cdC8qKlxuXHQgKiBFUzUgT2JqZWN0LmNyZWF0ZVxuXHQgKi9cblx0T2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uKG8pIHsgIFxuXHRcdHZhciB0bXAgPSBmdW5jdGlvbigpIHt9O1xuXHRcdHRtcC5wcm90b3R5cGUgPSBvO1xuXHRcdHJldHVybiBuZXcgdG1wKCk7XG5cdH07ICBcbn0gIFxuLyoqXG4gKiBTZXRzIHByb3RvdHlwZSBvZiB0aGlzIGZ1bmN0aW9uIHRvIGFuIGluc3RhbmNlIG9mIHBhcmVudCBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gcGFyZW50XG4gKi9cbkZ1bmN0aW9uLnByb3RvdHlwZS5leHRlbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuZXh0ZW5kIHx8IGZ1bmN0aW9uKHBhcmVudCkge1xuXHR0aGlzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG5cdHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdGhpcztcblx0cmV0dXJuIHRoaXM7XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHR8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuXHRcdHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgZnVuY3Rpb24oY2IpIHsgcmV0dXJuIHNldFRpbWVvdXQoY2IsIDEwMDAvNjApOyB9O1xuXG5cdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZVxuXHRcdHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lXG5cdFx0fHwgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7IH07XG59XG4vKipcbiAqIEBjbGFzcyBWaXN1YWwgbWFwIGRpc3BsYXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy53aWR0aD1ST1QuREVGQVVMVF9XSURUSF1cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5oZWlnaHQ9Uk9ULkRFRkFVTFRfSEVJR0hUXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmZvbnRTaXplPTE1XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvbnRGYW1pbHk9XCJtb25vc3BhY2VcIl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb250U3R5bGU9XCJcIl0gYm9sZC9pdGFsaWMvbm9uZS9ib3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmc9XCIjY2NjXCJdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmc9XCIjMDAwXCJdXG4gKiBAcGFyYW0ge2Zsb2F0fSBbb3B0aW9ucy5zcGFjaW5nPTFdXG4gKiBAcGFyYW0ge2Zsb2F0fSBbb3B0aW9ucy5ib3JkZXI9MF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYXlvdXQ9XCJyZWN0XCJdXG4gKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLmZvcmNlU3F1YXJlUmF0aW89ZmFsc2VdXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMudGlsZVdpZHRoPTMyXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRpbGVIZWlnaHQ9MzJdXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudGlsZU1hcD17fV1cbiAqIEBwYXJhbSB7aW1hZ2V9IFtvcHRpb25zLnRpbGVTZXQ9bnVsbF1cbiAqIEBwYXJhbSB7aW1hZ2V9IFtvcHRpb25zLnRpbGVDb2xvcml6ZT1mYWxzZV1cbiAqL1xuUk9ULkRpc3BsYXkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHR0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0dGhpcy5fZGF0YSA9IHt9O1xuXHR0aGlzLl9kaXJ0eSA9IGZhbHNlOyAvKiBmYWxzZSA9IG5vdGhpbmcsIHRydWUgPSBhbGwsIG9iamVjdCA9IGRpcnR5IGNlbGxzICovXG5cdHRoaXMuX29wdGlvbnMgPSB7fTtcblx0dGhpcy5fYmFja2VuZCA9IG51bGw7XG5cdFxuXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0d2lkdGg6IFJPVC5ERUZBVUxUX1dJRFRILFxuXHRcdGhlaWdodDogUk9ULkRFRkFVTFRfSEVJR0hULFxuXHRcdHRyYW5zcG9zZTogZmFsc2UsXG5cdFx0bGF5b3V0OiBcInJlY3RcIixcblx0XHRmb250U2l6ZTogMTUsXG5cdFx0c3BhY2luZzogMSxcblx0XHRib3JkZXI6IDAsXG5cdFx0Zm9yY2VTcXVhcmVSYXRpbzogZmFsc2UsXG5cdFx0Zm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcblx0XHRmb250U3R5bGU6IFwiXCIsXG5cdFx0Zmc6IFwiI2NjY1wiLFxuXHRcdGJnOiBcIiMwMDBcIixcblx0XHR0aWxlV2lkdGg6IDMyLFxuXHRcdHRpbGVIZWlnaHQ6IDMyLFxuXHRcdHRpbGVNYXA6IHt9LFxuXHRcdHRpbGVTZXQ6IG51bGwsXG5cdFx0dGlsZUNvbG9yaXplOiBmYWxzZSxcblx0XHR0ZXJtQ29sb3I6IFwieHRlcm1cIlxuXHR9O1xuXHRmb3IgKHZhciBwIGluIG9wdGlvbnMpIHsgZGVmYXVsdE9wdGlvbnNbcF0gPSBvcHRpb25zW3BdOyB9XG5cdHRoaXMuc2V0T3B0aW9ucyhkZWZhdWx0T3B0aW9ucyk7XG5cdHRoaXMuREVCVUcgPSB0aGlzLkRFQlVHLmJpbmQodGhpcyk7XG5cblx0dGhpcy5fdGljayA9IHRoaXMuX3RpY2suYmluZCh0aGlzKTtcblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xufVxuXG4vKipcbiAqIERlYnVnIGhlbHBlciwgaWRlYWwgYXMgYSBtYXAgZ2VuZXJhdG9yIGNhbGxiYWNrLiBBbHdheXMgYm91bmQgdG8gdGhpcy5cbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtpbnR9IHdoYXRcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLkRFQlVHID0gZnVuY3Rpb24oeCwgeSwgd2hhdCkge1xuXHR2YXIgY29sb3JzID0gW3RoaXMuX29wdGlvbnMuYmcsIHRoaXMuX29wdGlvbnMuZmddO1xuXHR0aGlzLmRyYXcoeCwgeSwgbnVsbCwgbnVsbCwgY29sb3JzW3doYXQgJSBjb2xvcnMubGVuZ3RoXSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHdob2xlIGRpc3BsYXkgKGNvdmVyIGl0IHdpdGggYmFja2dyb3VuZCBjb2xvcilcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX2RhdGEgPSB7fTtcblx0dGhpcy5fZGlydHkgPSB0cnVlO1xufVxuXG4vKipcbiAqIEBzZWUgUk9ULkRpc3BsYXlcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxuXHRpZiAob3B0aW9ucy53aWR0aCB8fCBvcHRpb25zLmhlaWdodCB8fCBvcHRpb25zLmZvbnRTaXplIHx8IG9wdGlvbnMuZm9udEZhbWlseSB8fCBvcHRpb25zLnNwYWNpbmcgfHwgb3B0aW9ucy5sYXlvdXQpIHtcblx0XHRpZiAob3B0aW9ucy5sYXlvdXQpIHsgXG5cdFx0XHR0aGlzLl9iYWNrZW5kID0gbmV3IFJPVC5EaXNwbGF5W29wdGlvbnMubGF5b3V0LmNhcGl0YWxpemUoKV0odGhpcy5fY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0dmFyIGZvbnQgPSAodGhpcy5fb3B0aW9ucy5mb250U3R5bGUgPyB0aGlzLl9vcHRpb25zLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIikgKyB0aGlzLl9vcHRpb25zLmZvbnRTaXplICsgXCJweCBcIiArIHRoaXMuX29wdGlvbnMuZm9udEZhbWlseTtcblx0XHR0aGlzLl9jb250ZXh0LmZvbnQgPSBmb250O1xuXHRcdHRoaXMuX2JhY2tlbmQuY29tcHV0ZSh0aGlzLl9vcHRpb25zKTtcblx0XHR0aGlzLl9jb250ZXh0LmZvbnQgPSBmb250O1xuXHRcdHRoaXMuX2NvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHR0aGlzLl9jb250ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJldHVybnMgY3VycmVudGx5IHNldCBvcHRpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBDdXJyZW50IG9wdGlvbnMgb2JqZWN0IFxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5fb3B0aW9ucztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSBvZiB0aGlzIGRpc3BsYXlcbiAqIEByZXR1cm5zIHtub2RlfSBET00gbm9kZVxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9jb250ZXh0LmNhbnZhcztcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXhpbXVtIHdpZHRoL2hlaWdodCB0byBmaXQgaW50byBhIHNldCBvZiBnaXZlbiBjb25zdHJhaW50c1xuICogQHBhcmFtIHtpbnR9IGF2YWlsV2lkdGggTWF4aW11bSBhbGxvd2VkIHBpeGVsIHdpZHRoXG4gKiBAcGFyYW0ge2ludH0gYXZhaWxIZWlnaHQgTWF4aW11bSBhbGxvd2VkIHBpeGVsIGhlaWdodFxuICogQHJldHVybnMge2ludFsyXX0gY2VsbFdpZHRoLGNlbGxIZWlnaHRcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcblx0cmV0dXJuIHRoaXMuX2JhY2tlbmQuY29tcHV0ZVNpemUoYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQsIHRoaXMuX29wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIG1heGltdW0gZm9udCBzaXplIHRvIGZpdCBpbnRvIGEgc2V0IG9mIGdpdmVuIGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge2ludH0gYXZhaWxXaWR0aCBNYXhpbXVtIGFsbG93ZWQgcGl4ZWwgd2lkdGhcbiAqIEBwYXJhbSB7aW50fSBhdmFpbEhlaWdodCBNYXhpbXVtIGFsbG93ZWQgcGl4ZWwgaGVpZ2h0XG4gKiBAcmV0dXJucyB7aW50fSBmb250U2l6ZVxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuY29tcHV0ZUZvbnRTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcblx0cmV0dXJuIHRoaXMuX2JhY2tlbmQuY29tcHV0ZUZvbnRTaXplKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0LCB0aGlzLl9vcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgRE9NIGV2ZW50IChtb3VzZSBvciB0b3VjaCkgdG8gbWFwIGNvb3JkaW5hdGVzLiBVc2VzIGZpcnN0IHRvdWNoIGZvciBtdWx0aS10b3VjaC5cbiAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnRcbiAqIEByZXR1cm5zIHtpbnRbMl19IC0xIGZvciB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgY2FudmFzXG4gKi9cblJPVC5EaXNwbGF5LnByb3RvdHlwZS5ldmVudFRvUG9zaXRpb24gPSBmdW5jdGlvbihlKSB7XG5cdGlmIChlLnRvdWNoZXMpIHtcblx0XHR2YXIgeCA9IGUudG91Y2hlc1swXS5jbGllbnRYO1xuXHRcdHZhciB5ID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHggPSBlLmNsaWVudFg7XG5cdFx0dmFyIHkgPSBlLmNsaWVudFk7XG5cdH1cblxuXHR2YXIgcmVjdCA9IHRoaXMuX2NvbnRleHQuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHR4IC09IHJlY3QubGVmdDtcblx0eSAtPSByZWN0LnRvcDtcblx0XG5cdGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoIHx8IHkgPj0gdGhpcy5fY29udGV4dC5jYW52YXMuaGVpZ2h0KSB7IHJldHVybiBbLTEsIC0xXTsgfVxuXG5cdHJldHVybiB0aGlzLl9iYWNrZW5kLmV2ZW50VG9Qb3NpdGlvbih4LCB5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludH0geFxuICogQHBhcmFtIHtpbnR9IHlcbiAqIEBwYXJhbSB7c3RyaW5nIHx8IHN0cmluZ1tdfSBjaCBPbmUgb3IgbW9yZSBjaGFycyAod2lsbCBiZSBvdmVybGFwcGluZyB0aGVtc2VsdmVzKVxuICogQHBhcmFtIHtzdHJpbmd9IFtmZ10gZm9yZWdyb3VuZCBjb2xvclxuICogQHBhcmFtIHtzdHJpbmd9IFtiZ10gYmFja2dyb3VuZCBjb2xvclxuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHgsIHksIGNoLCBmZywgYmcpIHtcblx0aWYgKCFmZykgeyBmZyA9IHRoaXMuX29wdGlvbnMuZmc7IH1cblx0aWYgKCFiZykgeyBiZyA9IHRoaXMuX29wdGlvbnMuYmc7IH1cblx0dGhpcy5fZGF0YVt4K1wiLFwiK3ldID0gW3gsIHksIGNoLCBmZywgYmddO1xuXHRcblx0aWYgKHRoaXMuX2RpcnR5ID09PSB0cnVlKSB7IHJldHVybjsgfSAvKiB3aWxsIGFscmVhZHkgcmVkcmF3IGV2ZXJ5dGhpbmcgKi9cblx0aWYgKCF0aGlzLl9kaXJ0eSkgeyB0aGlzLl9kaXJ0eSA9IHt9OyB9IC8qIGZpcnN0ISAqL1xuXHR0aGlzLl9kaXJ0eVt4K1wiLFwiK3ldID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEcmF3cyBhIHRleHQgYXQgZ2l2ZW4gcG9zaXRpb24uIE9wdGlvbmFsbHkgd3JhcHMgYXQgYSBtYXhpbXVtIGxlbmd0aC4gQ3VycmVudGx5IGRvZXMgbm90IHdvcmsgd2l0aCBoZXggbGF5b3V0LlxuICogQHBhcmFtIHtpbnR9IHhcbiAqIEBwYXJhbSB7aW50fSB5XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBNYXkgY29udGFpbiBjb2xvci9iYWNrZ3JvdW5kIGZvcm1hdCBzcGVjaWZpZXJzLCAlY3tuYW1lfS8lYntuYW1lfSwgYm90aCBvcHRpb25hbC4gJWN7fS8lYnt9IHJlc2V0cyB0byBkZWZhdWx0LlxuICogQHBhcmFtIHtpbnR9IFttYXhXaWR0aF0gd3JhcCBhdCB3aGF0IHdpZHRoP1xuICogQHJldHVybnMge2ludH0gbGluZXMgZHJhd25cbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLmRyYXdUZXh0ID0gZnVuY3Rpb24oeCwgeSwgdGV4dCwgbWF4V2lkdGgpIHtcblx0dmFyIGZnID0gbnVsbDtcblx0dmFyIGJnID0gbnVsbDtcblx0dmFyIGN4ID0geDtcblx0dmFyIGN5ID0geTtcblx0dmFyIGxpbmVzID0gMTtcblx0aWYgKCFtYXhXaWR0aCkgeyBtYXhXaWR0aCA9IHRoaXMuX29wdGlvbnMud2lkdGgteDsgfVxuXG5cdHZhciB0b2tlbnMgPSBST1QuVGV4dC50b2tlbml6ZSh0ZXh0LCBtYXhXaWR0aCk7XG5cblx0d2hpbGUgKHRva2Vucy5sZW5ndGgpIHsgLyogaW50ZXJwcmV0IHRva2VuaXplZCBvcGNvZGUgc3RyZWFtICovXG5cdFx0dmFyIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0c3dpdGNoICh0b2tlbi50eXBlKSB7XG5cdFx0XHRjYXNlIFJPVC5UZXh0LlRZUEVfVEVYVDpcblx0XHRcdFx0dmFyIGlzU3BhY2UgPSBmYWxzZSwgaXNQcmV2U3BhY2UgPSBmYWxzZSwgaXNGdWxsV2lkdGggPSBmYWxzZSwgaXNQcmV2RnVsbFdpZHRoID0gZmFsc2U7XG5cdFx0XHRcdGZvciAodmFyIGk9MDtpPHRva2VuLnZhbHVlLmxlbmd0aDtpKyspIHtcblx0XHRcdFx0XHR2YXIgY2MgPSB0b2tlbi52YWx1ZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRcdHZhciBjID0gdG9rZW4udmFsdWUuY2hhckF0KGkpO1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB0byBgdHJ1ZWAgd2hlbiB0aGUgY3VycmVudCBjaGFyIGlzIGZ1bGwtd2lkdGguXG5cdFx0XHRcdFx0aXNGdWxsV2lkdGggPSAoY2MgPiAweGZmICYmIGNjIDwgMHhmZjYxKSB8fCAoY2MgPiAweGZmZGMgJiYgY2MgPCAweGZmZTgpICYmIGNjID4gMHhmZmVlO1xuXHRcdFx0XHRcdC8vIEN1cnJlbnQgY2hhciBpcyBzcGFjZSwgd2hhdGV2ZXIgZnVsbC13aWR0aCBvciBoYWxmLXdpZHRoIGJvdGggYXJlIE9LLlxuXHRcdFx0XHRcdGlzU3BhY2UgPSAoYy5jaGFyQ29kZUF0KDApID09IDB4MjAgfHwgYy5jaGFyQ29kZUF0KDApID09IDB4MzAwMCk7XG5cdFx0XHRcdFx0Ly8gVGhlIHByZXZpb3VzIGNoYXIgaXMgZnVsbC13aWR0aCBhbmRcblx0XHRcdFx0XHQvLyBjdXJyZW50IGNoYXIgaXMgbmV0aGVyIGhhbGYtd2lkdGggbm9yIGEgc3BhY2UuXG5cdFx0XHRcdFx0aWYgKGlzUHJldkZ1bGxXaWR0aCAmJiAhaXNGdWxsV2lkdGggJiYgIWlzU3BhY2UpIHsgY3grKzsgfSAvLyBhZGQgYW4gZXh0cmEgcG9zaXRpb25cblx0XHRcdFx0XHQvLyBUaGUgY3VycmVudCBjaGFyIGlzIGZ1bGwtd2lkdGggYW5kXG5cdFx0XHRcdFx0Ly8gdGhlIHByZXZpb3VzIGNoYXIgaXMgbm90IGEgc3BhY2UuXG5cdFx0XHRcdFx0aWYoaXNGdWxsV2lkdGggJiYgIWlzUHJldlNwYWNlKSB7IGN4Kys7IH0gLy8gYWRkIGFuIGV4dHJhIHBvc2l0aW9uXG5cdFx0XHRcdFx0dGhpcy5kcmF3KGN4KyssIGN5LCBjLCBmZywgYmcpO1xuXHRcdFx0XHRcdGlzUHJldlNwYWNlID0gaXNTcGFjZTtcblx0XHRcdFx0XHRpc1ByZXZGdWxsV2lkdGggPSBpc0Z1bGxXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUk9ULlRleHQuVFlQRV9GRzpcblx0XHRcdFx0ZmcgPSB0b2tlbi52YWx1ZSB8fCBudWxsO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUk9ULlRleHQuVFlQRV9CRzpcblx0XHRcdFx0YmcgPSB0b2tlbi52YWx1ZSB8fCBudWxsO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUk9ULlRleHQuVFlQRV9ORVdMSU5FOlxuXHRcdFx0XHRjeCA9IHg7XG5cdFx0XHRcdGN5Kys7XG5cdFx0XHRcdGxpbmVzKytcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBsaW5lcztcbn1cblxuLyoqXG4gKiBUaW1lciB0aWNrOiB1cGRhdGUgZGlydHkgcGFydHNcbiAqL1xuUk9ULkRpc3BsYXkucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cdHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcblxuXHRpZiAoIXRoaXMuX2RpcnR5KSB7IHJldHVybjsgfVxuXG5cdGlmICh0aGlzLl9kaXJ0eSA9PT0gdHJ1ZSkgeyAvKiBkcmF3IGFsbCAqL1xuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fb3B0aW9ucy5iZztcblx0XHR0aGlzLl9jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2NvbnRleHQuY2FudmFzLndpZHRoLCB0aGlzLl9jb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZGF0YSkgeyAvKiByZWRyYXcgY2FjaGVkIGRhdGEgKi9cblx0XHRcdHRoaXMuX2RyYXcoaWQsIGZhbHNlKTtcblx0XHR9XG5cblx0fSBlbHNlIHsgLyogZHJhdyBvbmx5IGRpcnR5ICovXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX2RpcnR5KSB7XG5cdFx0XHR0aGlzLl9kcmF3KGtleSwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5fZGlydHkgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFdoYXQgdG8gZHJhd1xuICogQHBhcmFtIHtib29sfSBjbGVhckJlZm9yZSBJcyBpdCBuZWNlc3NhcnkgdG8gY2xlYW4gYmVmb3JlP1xuICovXG5ST1QuRGlzcGxheS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbihrZXksIGNsZWFyQmVmb3JlKSB7XG5cdHZhciBkYXRhID0gdGhpcy5fZGF0YVtrZXldO1xuXHRpZiAoZGF0YVs0XSAhPSB0aGlzLl9vcHRpb25zLmJnKSB7IGNsZWFyQmVmb3JlID0gdHJ1ZTsgfVxuXG5cdHRoaXMuX2JhY2tlbmQuZHJhdyhkYXRhLCBjbGVhckJlZm9yZSk7XG59XG4vKipcbiAqIEBjbGFzcyBBYnN0cmFjdCBkaXNwbGF5IGJhY2tlbmQgbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5ST1QuRGlzcGxheS5CYWNrZW5kID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKSB7XG59XG5cblJPVC5EaXNwbGF5LkJhY2tlbmQucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuY29tcHV0ZUZvbnRTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcbn1cblxuUk9ULkRpc3BsYXkuQmFja2VuZC5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xufVxuLyoqXG4gKiBAY2xhc3MgUmVjdGFuZ3VsYXIgYmFja2VuZFxuICogQHByaXZhdGVcbiAqL1xuUk9ULkRpc3BsYXkuUmVjdCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Uk9ULkRpc3BsYXkuQmFja2VuZC5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXHRcblx0dGhpcy5fc3BhY2luZ1ggPSAwO1xuXHR0aGlzLl9zcGFjaW5nWSA9IDA7XG5cdHRoaXMuX2NhbnZhc0NhY2hlID0ge307XG5cdHRoaXMuX29wdGlvbnMgPSB7fTtcbn1cblJPVC5EaXNwbGF5LlJlY3QuZXh0ZW5kKFJPVC5EaXNwbGF5LkJhY2tlbmQpO1xuXG5ST1QuRGlzcGxheS5SZWN0LmNhY2hlID0gZmFsc2U7XG5cblJPVC5EaXNwbGF5LlJlY3QucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHRoaXMuX2NhbnZhc0NhY2hlID0ge307XG5cdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG5cdHZhciBjaGFyV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChcIldcIikud2lkdGgpO1xuXHR0aGlzLl9zcGFjaW5nWCA9IE1hdGguY2VpbChvcHRpb25zLnNwYWNpbmcgKiBjaGFyV2lkdGgpO1xuXHR0aGlzLl9zcGFjaW5nWSA9IE1hdGguY2VpbChvcHRpb25zLnNwYWNpbmcgKiBvcHRpb25zLmZvbnRTaXplKTtcblxuXHRpZiAodGhpcy5fb3B0aW9ucy5mb3JjZVNxdWFyZVJhdGlvKSB7XG5cdFx0dGhpcy5fc3BhY2luZ1ggPSB0aGlzLl9zcGFjaW5nWSA9IE1hdGgubWF4KHRoaXMuX3NwYWNpbmdYLCB0aGlzLl9zcGFjaW5nWSk7XG5cdH1cblxuXHR0aGlzLl9jb250ZXh0LmNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiB0aGlzLl9zcGFjaW5nWDtcblx0dGhpcy5fY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKiB0aGlzLl9zcGFjaW5nWTtcbn1cblxuUk9ULkRpc3BsYXkuUmVjdC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKSB7XG5cdGlmICh0aGlzLmNvbnN0cnVjdG9yLmNhY2hlKSB7XG5cdFx0dGhpcy5fZHJhd1dpdGhDYWNoZShkYXRhLCBjbGVhckJlZm9yZSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fZHJhd05vQ2FjaGUoZGF0YSwgY2xlYXJCZWZvcmUpO1xuXHR9XG59XG5cblJPVC5EaXNwbGF5LlJlY3QucHJvdG90eXBlLl9kcmF3V2l0aENhY2hlID0gZnVuY3Rpb24oZGF0YSwgY2xlYXJCZWZvcmUpIHtcblx0dmFyIHggPSBkYXRhWzBdO1xuXHR2YXIgeSA9IGRhdGFbMV07XG5cdHZhciBjaCA9IGRhdGFbMl07XG5cdHZhciBmZyA9IGRhdGFbM107XG5cdHZhciBiZyA9IGRhdGFbNF07XG5cblx0dmFyIGhhc2ggPSBcIlwiK2NoK2ZnK2JnO1xuXHRpZiAoaGFzaCBpbiB0aGlzLl9jYW52YXNDYWNoZSkge1xuXHRcdHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXNDYWNoZVtoYXNoXTtcblx0fSBlbHNlIHtcblx0XHR2YXIgYiA9IHRoaXMuX29wdGlvbnMuYm9yZGVyO1xuXHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGNhbnZhcy53aWR0aCA9IHRoaXMuX3NwYWNpbmdYO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9zcGFjaW5nWTtcblx0XHRjdHguZmlsbFN0eWxlID0gYmc7XG5cdFx0Y3R4LmZpbGxSZWN0KGIsIGIsIGNhbnZhcy53aWR0aC1iLCBjYW52YXMuaGVpZ2h0LWIpO1xuXHRcdFxuXHRcdGlmIChjaCkge1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZnO1xuXHRcdFx0Y3R4LmZvbnQgPSB0aGlzLl9jb250ZXh0LmZvbnQ7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXG5cdFx0XHR2YXIgY2hhcnMgPSBbXS5jb25jYXQoY2gpO1xuXHRcdFx0Zm9yICh2YXIgaT0wO2k8Y2hhcnMubGVuZ3RoO2krKykge1xuXHRcdFx0XHRjdHguZmlsbFRleHQoY2hhcnNbaV0sIHRoaXMuX3NwYWNpbmdYLzIsIE1hdGguY2VpbCh0aGlzLl9zcGFjaW5nWS8yKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NhbnZhc0NhY2hlW2hhc2hdID0gY2FudmFzO1xuXHR9XG5cdFxuXHR0aGlzLl9jb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIHgqdGhpcy5fc3BhY2luZ1gsIHkqdGhpcy5fc3BhY2luZ1kpO1xufVxuXG5ST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5fZHJhd05vQ2FjaGUgPSBmdW5jdGlvbihkYXRhLCBjbGVhckJlZm9yZSkge1xuXHR2YXIgeCA9IGRhdGFbMF07XG5cdHZhciB5ID0gZGF0YVsxXTtcblx0dmFyIGNoID0gZGF0YVsyXTtcblx0dmFyIGZnID0gZGF0YVszXTtcblx0dmFyIGJnID0gZGF0YVs0XTtcblxuXHRpZiAoY2xlYXJCZWZvcmUpIHsgXG5cdFx0dmFyIGIgPSB0aGlzLl9vcHRpb25zLmJvcmRlcjtcblx0XHR0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IGJnO1xuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoeCp0aGlzLl9zcGFjaW5nWCArIGIsIHkqdGhpcy5fc3BhY2luZ1kgKyBiLCB0aGlzLl9zcGFjaW5nWCAtIGIsIHRoaXMuX3NwYWNpbmdZIC0gYik7XG5cdH1cblx0XG5cdGlmICghY2gpIHsgcmV0dXJuOyB9XG5cblx0dGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBmZztcblxuXHR2YXIgY2hhcnMgPSBbXS5jb25jYXQoY2gpO1xuXHRmb3IgKHZhciBpPTA7aTxjaGFycy5sZW5ndGg7aSsrKSB7XG5cdFx0dGhpcy5fY29udGV4dC5maWxsVGV4dChjaGFyc1tpXSwgKHgrMC41KSAqIHRoaXMuX3NwYWNpbmdYLCBNYXRoLmNlaWwoKHkrMC41KSAqIHRoaXMuX3NwYWNpbmdZKSk7XG5cdH1cbn1cblxuUk9ULkRpc3BsYXkuUmVjdC5wcm90b3R5cGUuY29tcHV0ZVNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkge1xuXHR2YXIgd2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9zcGFjaW5nWCk7XG5cdHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGF2YWlsSGVpZ2h0IC8gdGhpcy5fc3BhY2luZ1kpO1xuXHRyZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xufVxuXG5ST1QuRGlzcGxheS5SZWN0LnByb3RvdHlwZS5jb21wdXRlRm9udFNpemUgPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCkge1xuXHR2YXIgYm94V2lkdGggPSBNYXRoLmZsb29yKGF2YWlsV2lkdGggLyB0aGlzLl9vcHRpb25zLndpZHRoKTtcblx0dmFyIGJveEhlaWdodCA9IE1hdGguZmxvb3IoYXZhaWxIZWlnaHQgLyB0aGlzLl9vcHRpb25zLmhlaWdodCk7XG5cblx0LyogY29tcHV0ZSBjaGFyIHJhdGlvICovXG5cdHZhciBvbGRGb250ID0gdGhpcy5fY29udGV4dC5mb250O1xuXHR0aGlzLl9jb250ZXh0LmZvbnQgPSBcIjEwMHB4IFwiICsgdGhpcy5fb3B0aW9ucy5mb250RmFtaWx5O1xuXHR2YXIgd2lkdGggPSBNYXRoLmNlaWwodGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChcIldcIikud2lkdGgpO1xuXHR0aGlzLl9jb250ZXh0LmZvbnQgPSBvbGRGb250O1xuXHR2YXIgcmF0aW8gPSB3aWR0aCAvIDEwMDtcblx0XHRcblx0dmFyIHdpZHRoRnJhY3Rpb24gPSByYXRpbyAqIGJveEhlaWdodCAvIGJveFdpZHRoO1xuXHRpZiAod2lkdGhGcmFjdGlvbiA+IDEpIHsgLyogdG9vIHdpZGUgd2l0aCBjdXJyZW50IGFzcGVjdCByYXRpbyAqL1xuXHRcdGJveEhlaWdodCA9IE1hdGguZmxvb3IoYm94SGVpZ2h0IC8gd2lkdGhGcmFjdGlvbik7XG5cdH1cblx0cmV0dXJuIE1hdGguZmxvb3IoYm94SGVpZ2h0IC8gdGhpcy5fb3B0aW9ucy5zcGFjaW5nKTtcbn1cblxuUk9ULkRpc3BsYXkuUmVjdC5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuXHRyZXR1cm4gW01hdGguZmxvb3IoeC90aGlzLl9zcGFjaW5nWCksIE1hdGguZmxvb3IoeS90aGlzLl9zcGFjaW5nWSldO1xufVxuLyoqXG4gKiBAY2xhc3MgSGV4YWdvbmFsIGJhY2tlbmRcbiAqIEBwcml2YXRlXG4gKi9cblJPVC5EaXNwbGF5LkhleCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Uk9ULkRpc3BsYXkuQmFja2VuZC5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXG5cdHRoaXMuX3NwYWNpbmdYID0gMDtcblx0dGhpcy5fc3BhY2luZ1kgPSAwO1xuXHR0aGlzLl9oZXhTaXplID0gMDtcblx0dGhpcy5fb3B0aW9ucyA9IHt9O1xufVxuUk9ULkRpc3BsYXkuSGV4LmV4dGVuZChST1QuRGlzcGxheS5CYWNrZW5kKTtcblxuUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuXHQvKiBGSVhNRSBjaGFyIHNpemUgY29tcHV0YXRpb24gZG9lcyBub3QgcmVzcGVjdCB0cmFuc3Bvc2VkIGhleGVzICovXG5cdHZhciBjaGFyV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChcIldcIikud2lkdGgpO1xuXHR0aGlzLl9oZXhTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnNwYWNpbmcgKiAob3B0aW9ucy5mb250U2l6ZSArIGNoYXJXaWR0aC9NYXRoLnNxcnQoMykpIC8gMik7XG5cdHRoaXMuX3NwYWNpbmdYID0gdGhpcy5faGV4U2l6ZSAqIE1hdGguc3FydCgzKSAvIDI7XG5cdHRoaXMuX3NwYWNpbmdZID0gdGhpcy5faGV4U2l6ZSAqIDEuNTtcblxuXHRpZiAob3B0aW9ucy50cmFuc3Bvc2UpIHtcblx0XHR2YXIgeHByb3AgPSBcImhlaWdodFwiO1xuXHRcdHZhciB5cHJvcCA9IFwid2lkdGhcIjtcblx0fSBlbHNlIHtcblx0XHR2YXIgeHByb3AgPSBcIndpZHRoXCI7XG5cdFx0dmFyIHlwcm9wID0gXCJoZWlnaHRcIjtcblx0fVxuXHR0aGlzLl9jb250ZXh0LmNhbnZhc1t4cHJvcF0gPSBNYXRoLmNlaWwoIChvcHRpb25zLndpZHRoICsgMSkgKiB0aGlzLl9zcGFjaW5nWCApO1xuXHR0aGlzLl9jb250ZXh0LmNhbnZhc1t5cHJvcF0gPSBNYXRoLmNlaWwoIChvcHRpb25zLmhlaWdodCAtIDEpICogdGhpcy5fc3BhY2luZ1kgKyAyKnRoaXMuX2hleFNpemUgKTtcbn1cblxuUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZGF0YSwgY2xlYXJCZWZvcmUpIHtcblx0dmFyIHggPSBkYXRhWzBdO1xuXHR2YXIgeSA9IGRhdGFbMV07XG5cdHZhciBjaCA9IGRhdGFbMl07XG5cdHZhciBmZyA9IGRhdGFbM107XG5cdHZhciBiZyA9IGRhdGFbNF07XG5cblx0dmFyIHB4ID0gW1xuXHRcdCh4KzEpICogdGhpcy5fc3BhY2luZ1gsXG5cdFx0eSAqIHRoaXMuX3NwYWNpbmdZICsgdGhpcy5faGV4U2l6ZVxuXHRdO1xuXHRpZiAodGhpcy5fb3B0aW9ucy50cmFuc3Bvc2UpIHsgcHgucmV2ZXJzZSgpOyB9XG5cblx0aWYgKGNsZWFyQmVmb3JlKSB7IFxuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gYmc7XG5cdFx0dGhpcy5fZmlsbChweFswXSwgcHhbMV0pO1xuXHR9XG5cdFxuXHRpZiAoIWNoKSB7IHJldHVybjsgfVxuXG5cdHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gZmc7XG5cblx0dmFyIGNoYXJzID0gW10uY29uY2F0KGNoKTtcblx0Zm9yICh2YXIgaT0wO2k8Y2hhcnMubGVuZ3RoO2krKykge1xuXHRcdHRoaXMuX2NvbnRleHQuZmlsbFRleHQoY2hhcnNbaV0sIHB4WzBdLCBNYXRoLmNlaWwocHhbMV0pKTtcblx0fVxufVxuXG5ST1QuRGlzcGxheS5IZXgucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcblx0aWYgKHRoaXMuX29wdGlvbnMudHJhbnNwb3NlKSB7XG5cdFx0YXZhaWxXaWR0aCArPSBhdmFpbEhlaWdodDtcblx0XHRhdmFpbEhlaWdodCA9IGF2YWlsV2lkdGggLSBhdmFpbEhlaWdodDtcblx0XHRhdmFpbFdpZHRoIC09IGF2YWlsSGVpZ2h0O1xuXHR9XG5cblx0dmFyIHdpZHRoID0gTWF0aC5mbG9vcihhdmFpbFdpZHRoIC8gdGhpcy5fc3BhY2luZ1gpIC0gMTtcblx0dmFyIGhlaWdodCA9IE1hdGguZmxvb3IoKGF2YWlsSGVpZ2h0IC0gMip0aGlzLl9oZXhTaXplKSAvIHRoaXMuX3NwYWNpbmdZICsgMSk7XG5cdHJldHVybiBbd2lkdGgsIGhlaWdodF07XG59XG5cblJPVC5EaXNwbGF5LkhleC5wcm90b3R5cGUuY29tcHV0ZUZvbnRTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcblx0aWYgKHRoaXMuX29wdGlvbnMudHJhbnNwb3NlKSB7XG5cdFx0YXZhaWxXaWR0aCArPSBhdmFpbEhlaWdodDtcblx0XHRhdmFpbEhlaWdodCA9IGF2YWlsV2lkdGggLSBhdmFpbEhlaWdodDtcblx0XHRhdmFpbFdpZHRoIC09IGF2YWlsSGVpZ2h0O1xuXHR9XG5cblx0dmFyIGhleFNpemVXaWR0aCA9IDIqYXZhaWxXaWR0aCAvICgodGhpcy5fb3B0aW9ucy53aWR0aCsxKSAqIE1hdGguc3FydCgzKSkgLSAxO1xuXHR2YXIgaGV4U2l6ZUhlaWdodCA9IGF2YWlsSGVpZ2h0IC8gKDIgKyAxLjUqKHRoaXMuX29wdGlvbnMuaGVpZ2h0LTEpKTtcblx0dmFyIGhleFNpemUgPSBNYXRoLm1pbihoZXhTaXplV2lkdGgsIGhleFNpemVIZWlnaHQpO1xuXG5cdC8qIGNvbXB1dGUgY2hhciByYXRpbyAqL1xuXHR2YXIgb2xkRm9udCA9IHRoaXMuX2NvbnRleHQuZm9udDtcblx0dGhpcy5fY29udGV4dC5mb250ID0gXCIxMDBweCBcIiArIHRoaXMuX29wdGlvbnMuZm9udEZhbWlseTtcblx0dmFyIHdpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoXCJXXCIpLndpZHRoKTtcblx0dGhpcy5fY29udGV4dC5mb250ID0gb2xkRm9udDtcblx0dmFyIHJhdGlvID0gd2lkdGggLyAxMDA7XG5cblx0aGV4U2l6ZSA9IE1hdGguZmxvb3IoaGV4U2l6ZSkrMTsgLyogY2xvc2VzdCBsYXJnZXIgaGV4U2l6ZSAqL1xuXG5cdC8qIEZJWE1FIGNoYXIgc2l6ZSBjb21wdXRhdGlvbiBkb2VzIG5vdCByZXNwZWN0IHRyYW5zcG9zZWQgaGV4ZXMgKi9cblx0dmFyIGZvbnRTaXplID0gMipoZXhTaXplIC8gKHRoaXMuX29wdGlvbnMuc3BhY2luZyAqICgxICsgcmF0aW8gLyBNYXRoLnNxcnQoMykpKTtcblxuXHQvKiBjbG9zZXN0IHNtYWxsZXIgZm9udFNpemUgKi9cblx0cmV0dXJuIE1hdGguY2VpbChmb250U2l6ZSktMTtcbn1cblxuUk9ULkRpc3BsYXkuSGV4LnByb3RvdHlwZS5ldmVudFRvUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG5cdGlmICh0aGlzLl9vcHRpb25zLnRyYW5zcG9zZSkge1xuXHRcdHggKz0geTtcblx0XHR5ID0geC15O1xuXHRcdHggLT0geTtcblx0XHR2YXIgcHJvcCA9IFwid2lkdGhcIjtcblx0fSBlbHNlIHtcblx0XHR2YXIgcHJvcCA9IFwiaGVpZ2h0XCI7XG5cdH1cblx0dmFyIHNpemUgPSB0aGlzLl9jb250ZXh0LmNhbnZhc1twcm9wXSAvIHRoaXMuX29wdGlvbnNbcHJvcF07XG5cdHkgPSBNYXRoLmZsb29yKHkvc2l6ZSk7XG5cblx0aWYgKHkubW9kKDIpKSB7IC8qIG9kZCByb3cgKi9cblx0XHR4IC09IHRoaXMuX3NwYWNpbmdYO1xuXHRcdHggPSAxICsgMipNYXRoLmZsb29yKHgvKDIqdGhpcy5fc3BhY2luZ1gpKTtcblx0fSBlbHNlIHtcblx0XHR4ID0gMipNYXRoLmZsb29yKHgvKDIqdGhpcy5fc3BhY2luZ1gpKTtcblx0fVxuXHRcblx0cmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgYXJlIHBpeGVsIHZhbHVlcy4gSWYgXCJ0cmFuc3Bvc2VkXCIgbW9kZSBpcyBlbmFibGVkLCB0aGVuIHRoZXNlIHR3byBhcmUgYWxyZWFkeSBzd2FwcGVkLlxuICovXG5ST1QuRGlzcGxheS5IZXgucHJvdG90eXBlLl9maWxsID0gZnVuY3Rpb24oY3gsIGN5KSB7XG5cdHZhciBhID0gdGhpcy5faGV4U2l6ZTtcblx0dmFyIGIgPSB0aGlzLl9vcHRpb25zLmJvcmRlcjtcblx0XG5cdHRoaXMuX2NvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0aWYgKHRoaXMuX29wdGlvbnMudHJhbnNwb3NlKSB7XG5cdFx0dGhpcy5fY29udGV4dC5tb3ZlVG8oY3gtYStiLFx0Y3kpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4LWEvMitiLFx0Y3krdGhpcy5fc3BhY2luZ1gtYik7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3grYS8yLWIsXHRjeSt0aGlzLl9zcGFjaW5nWC1iKTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCthLWIsXHRjeSk7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3grYS8yLWIsXHRjeS10aGlzLl9zcGFjaW5nWCtiKTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeC1hLzIrYixcdGN5LXRoaXMuX3NwYWNpbmdYK2IpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4LWErYixcdGN5KTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9jb250ZXh0Lm1vdmVUbyhjeCxcdFx0XHRcdFx0Y3ktYStiKTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeCt0aGlzLl9zcGFjaW5nWC1iLFx0Y3ktYS8yK2IpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4K3RoaXMuX3NwYWNpbmdYLWIsXHRjeSthLzItYik7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3gsXHRcdFx0XHRcdGN5K2EtYik7XG5cdFx0dGhpcy5fY29udGV4dC5saW5lVG8oY3gtdGhpcy5fc3BhY2luZ1grYixcdGN5K2EvMi1iKTtcblx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyhjeC10aGlzLl9zcGFjaW5nWCtiLFx0Y3ktYS8yK2IpO1xuXHRcdHRoaXMuX2NvbnRleHQubGluZVRvKGN4LFx0XHRcdFx0XHRjeS1hK2IpO1xuXHR9XG5cdHRoaXMuX2NvbnRleHQuZmlsbCgpO1xufVxuLyoqXG4gKiBAY2xhc3MgVGlsZSBiYWNrZW5kXG4gKiBAcHJpdmF0ZVxuICovXG5ST1QuRGlzcGxheS5UaWxlID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRST1QuRGlzcGxheS5SZWN0LmNhbGwodGhpcywgY29udGV4dCk7XG5cdFxuXHR0aGlzLl9vcHRpb25zID0ge307XG5cdHRoaXMuX2NvbG9yQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbn1cblJPVC5EaXNwbGF5LlRpbGUuZXh0ZW5kKFJPVC5EaXNwbGF5LlJlY3QpO1xuXG5ST1QuRGlzcGxheS5UaWxlLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblx0dGhpcy5fY29udGV4dC5jYW52YXMud2lkdGggPSBvcHRpb25zLndpZHRoICogb3B0aW9ucy50aWxlV2lkdGg7XG5cdHRoaXMuX2NvbnRleHQuY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICogb3B0aW9ucy50aWxlSGVpZ2h0O1xuXHR0aGlzLl9jb2xvckNhbnZhcy53aWR0aCA9IG9wdGlvbnMudGlsZVdpZHRoO1xuXHR0aGlzLl9jb2xvckNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLnRpbGVIZWlnaHQ7XG59XG5cblJPVC5EaXNwbGF5LlRpbGUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihkYXRhLCBjbGVhckJlZm9yZSkge1xuXHR2YXIgeCA9IGRhdGFbMF07XG5cdHZhciB5ID0gZGF0YVsxXTtcblx0dmFyIGNoID0gZGF0YVsyXTtcblx0dmFyIGZnID0gZGF0YVszXTtcblx0dmFyIGJnID0gZGF0YVs0XTtcblxuXHR2YXIgdGlsZVdpZHRoID0gdGhpcy5fb3B0aW9ucy50aWxlV2lkdGg7XG5cdHZhciB0aWxlSGVpZ2h0ID0gdGhpcy5fb3B0aW9ucy50aWxlSGVpZ2h0O1xuXG5cdGlmIChjbGVhckJlZm9yZSkge1xuXHRcdGlmICh0aGlzLl9vcHRpb25zLnRpbGVDb2xvcml6ZSkge1xuXHRcdFx0dGhpcy5fY29udGV4dC5jbGVhclJlY3QoeCp0aWxlV2lkdGgsIHkqdGlsZUhlaWdodCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBiZztcblx0XHRcdHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoeCp0aWxlV2lkdGgsIHkqdGlsZUhlaWdodCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWNoKSB7IHJldHVybjsgfVxuXG5cdHZhciBjaGFycyA9IFtdLmNvbmNhdChjaCk7XG5cdGZvciAodmFyIGk9MDtpPGNoYXJzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX29wdGlvbnMudGlsZU1hcFtjaGFyc1tpXV07XG5cdFx0aWYgKCF0aWxlKSB7IHRocm93IG5ldyBFcnJvcihcIkNoYXIgJ1wiICsgY2hhcnNbaV0gKyBcIicgbm90IGZvdW5kIGluIHRpbGVNYXBcIik7IH1cblx0XHRcblx0XHRpZiAodGhpcy5fb3B0aW9ucy50aWxlQ29sb3JpemUpIHsgLyogYXBwbHkgY29sb3JpemF0aW9uICovXG5cdFx0XHR2YXIgY2FudmFzID0gdGhpcy5fY29sb3JDYW52YXM7XG5cdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0XHRjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpO1xuXG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZShcblx0XHRcdFx0dGhpcy5fb3B0aW9ucy50aWxlU2V0LFxuXHRcdFx0XHR0aWxlWzBdLCB0aWxlWzFdLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsXG5cdFx0XHRcdDAsIDAsIHRpbGVXaWR0aCwgdGlsZUhlaWdodFxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKGZnICE9IFwidHJhbnNwYXJlbnRcIikge1xuXHRcdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IGZnO1xuXHRcdFx0XHRjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWF0b3BcIjtcblx0XHRcdFx0Y29udGV4dC5maWxsUmVjdCgwLCAwLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmcgIT0gXCJ0cmFuc3BhcmVudFwiKSB7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gYmc7XG5cdFx0XHRcdGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1vdmVyXCI7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCB4KnRpbGVXaWR0aCwgeSp0aWxlSGVpZ2h0LCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpO1xuXG5cdFx0fSBlbHNlIHsgLyogbm8gY29sb3JpemluZywgZWFzeSAqL1xuXHRcdFx0dGhpcy5fY29udGV4dC5kcmF3SW1hZ2UoXG5cdFx0XHRcdHRoaXMuX29wdGlvbnMudGlsZVNldCxcblx0XHRcdFx0dGlsZVswXSwgdGlsZVsxXSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LFxuXHRcdFx0XHR4KnRpbGVXaWR0aCwgeSp0aWxlSGVpZ2h0LCB0aWxlV2lkdGgsIHRpbGVIZWlnaHRcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG59XG5cblJPVC5EaXNwbGF5LlRpbGUucHJvdG90eXBlLmNvbXB1dGVTaXplID0gZnVuY3Rpb24oYXZhaWxXaWR0aCwgYXZhaWxIZWlnaHQpIHtcblx0dmFyIHdpZHRoID0gTWF0aC5mbG9vcihhdmFpbFdpZHRoIC8gdGhpcy5fb3B0aW9ucy50aWxlV2lkdGgpO1xuXHR2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihhdmFpbEhlaWdodCAvIHRoaXMuX29wdGlvbnMudGlsZUhlaWdodCk7XG5cdHJldHVybiBbd2lkdGgsIGhlaWdodF07XG59XG5cblJPVC5EaXNwbGF5LlRpbGUucHJvdG90eXBlLmNvbXB1dGVGb250U2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KSB7XG5cdHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYXZhaWxXaWR0aCAvIHRoaXMuX29wdGlvbnMud2lkdGgpO1xuXHR2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihhdmFpbEhlaWdodCAvIHRoaXMuX29wdGlvbnMuaGVpZ2h0KTtcblx0cmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbn1cblxuUk9ULkRpc3BsYXkuVGlsZS5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuXHRyZXR1cm4gW01hdGguZmxvb3IoeC90aGlzLl9vcHRpb25zLnRpbGVXaWR0aCksIE1hdGguZmxvb3IoeS90aGlzLl9vcHRpb25zLnRpbGVIZWlnaHQpXTtcbn1cbi8qKlxuICogQG5hbWVzcGFjZVxuICogVGhpcyBjb2RlIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIEFsZWEgYWxnb3JpdGhtOyAoQykgMjAxMCBKb2hhbm5lcyBCYWFnw7hlLlxuICogQWxlYSBpcyBsaWNlbnNlZCBhY2NvcmRpbmcgdG8gdGhlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UuXG4gKi9cblJPVC5STkcgPSB7XG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBcblx0ICovXG5cdGdldFNlZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWVkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VlZCBTZWVkIHRoZSBudW1iZXIgZ2VuZXJhdG9yXG5cdCAqL1xuXHRzZXRTZWVkOiBmdW5jdGlvbihzZWVkKSB7XG5cdFx0c2VlZCA9IChzZWVkIDwgMSA/IDEvc2VlZCA6IHNlZWQpO1xuXG5cdFx0dGhpcy5fc2VlZCA9IHNlZWQ7XG5cdFx0dGhpcy5fczAgPSAoc2VlZCA+Pj4gMCkgKiB0aGlzLl9mcmFjO1xuXG5cdFx0c2VlZCA9IChzZWVkKjY5MDY5ICsgMSkgPj4+IDA7XG5cdFx0dGhpcy5fczEgPSBzZWVkICogdGhpcy5fZnJhYztcblxuXHRcdHNlZWQgPSAoc2VlZCo2OTA2OSArIDEpID4+PiAwO1xuXHRcdHRoaXMuX3MyID0gc2VlZCAqIHRoaXMuX2ZyYWM7XG5cblx0XHR0aGlzLl9jID0gMTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybnMge2Zsb2F0fSBQc2V1ZG9yYW5kb20gdmFsdWUgWzAsMSksIHVuaWZvcm1seSBkaXN0cmlidXRlZFxuXHQgKi9cblx0Z2V0VW5pZm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHQgPSAyMDkxNjM5ICogdGhpcy5fczAgKyB0aGlzLl9jICogdGhpcy5fZnJhYztcblx0XHR0aGlzLl9zMCA9IHRoaXMuX3MxO1xuXHRcdHRoaXMuX3MxID0gdGhpcy5fczI7XG5cdFx0dGhpcy5fYyA9IHQgfCAwO1xuXHRcdHRoaXMuX3MyID0gdCAtIHRoaXMuX2M7XG5cdFx0cmV0dXJuIHRoaXMuX3MyO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2ludH0gbG93ZXJCb3VuZCBUaGUgbG93ZXIgZW5kIG9mIHRoZSByYW5nZSB0byByZXR1cm4gYSB2YWx1ZSBmcm9tLCBpbmNsdXNpdmVcblx0ICogQHBhcmFtIHtpbnR9IHVwcGVyQm91bmQgVGhlIHVwcGVyIGVuZCBvZiB0aGUgcmFuZ2UgdG8gcmV0dXJuIGEgdmFsdWUgZnJvbSwgaW5jbHVzaXZlXG5cdCAqIEByZXR1cm5zIHtpbnR9IFBzZXVkb3JhbmRvbSB2YWx1ZSBbbG93ZXJCb3VuZCwgdXBwZXJCb3VuZF0sIHVzaW5nIFJPVC5STkcuZ2V0VW5pZm9ybSgpIHRvIGRpc3RyaWJ1dGUgdGhlIHZhbHVlXG5cdCAqL1xuXHRnZXRVbmlmb3JtSW50OiBmdW5jdGlvbihsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG5cdFx0dmFyIG1heCA9IE1hdGgubWF4KGxvd2VyQm91bmQsIHVwcGVyQm91bmQpO1xuXHRcdHZhciBtaW4gPSBNYXRoLm1pbihsb3dlckJvdW5kLCB1cHBlckJvdW5kKTtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcih0aGlzLmdldFVuaWZvcm0oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7ZmxvYXR9IFttZWFuPTBdIE1lYW4gdmFsdWVcblx0ICogQHBhcmFtIHtmbG9hdH0gW3N0ZGRldj0xXSBTdGFuZGFyZCBkZXZpYXRpb24uIH45NSUgb2YgdGhlIGFic29sdXRlIHZhbHVlcyB3aWxsIGJlIGxvd2VyIHRoYW4gMipzdGRkZXYuXG5cdCAqIEByZXR1cm5zIHtmbG9hdH0gQSBub3JtYWxseSBkaXN0cmlidXRlZCBwc2V1ZG9yYW5kb20gdmFsdWVcblx0ICovXG5cdGdldE5vcm1hbDogZnVuY3Rpb24obWVhbiwgc3RkZGV2KSB7XG5cdFx0ZG8ge1xuXHRcdFx0dmFyIHUgPSAyKnRoaXMuZ2V0VW5pZm9ybSgpLTE7XG5cdFx0XHR2YXIgdiA9IDIqdGhpcy5nZXRVbmlmb3JtKCktMTtcblx0XHRcdHZhciByID0gdSp1ICsgdip2O1xuXHRcdH0gd2hpbGUgKHIgPiAxIHx8IHIgPT0gMCk7XG5cblx0XHR2YXIgZ2F1c3MgPSB1ICogTWF0aC5zcXJ0KC0yKk1hdGgubG9nKHIpL3IpO1xuXHRcdHJldHVybiAobWVhbiB8fCAwKSArIGdhdXNzKihzdGRkZXYgfHwgMSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtpbnR9IFBzZXVkb3JhbmRvbSB2YWx1ZSBbMSwxMDBdIGluY2x1c2l2ZSwgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkXG5cdCAqL1xuXHRnZXRQZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gMSArIE1hdGguZmxvb3IodGhpcy5nZXRVbmlmb3JtKCkqMTAwKTtcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBrZXk9d2hhdGV2ZXIsIHZhbHVlPXdlaWdodCAocmVsYXRpdmUgcHJvYmFiaWxpdHkpXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IHdoYXRldmVyXG5cdCAqL1xuXHRnZXRXZWlnaHRlZFZhbHVlOiBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIHRvdGFsID0gMDtcblx0XHRcblx0XHRmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG5cdFx0XHR0b3RhbCArPSBkYXRhW2lkXTtcblx0XHR9XG5cdFx0dmFyIHJhbmRvbSA9IHRoaXMuZ2V0VW5pZm9ybSgpKnRvdGFsO1xuXHRcdFxuXHRcdHZhciBwYXJ0ID0gMDtcblx0XHRmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG5cdFx0XHRwYXJ0ICs9IGRhdGFbaWRdO1xuXHRcdFx0aWYgKHJhbmRvbSA8IHBhcnQpIHsgcmV0dXJuIGlkOyB9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYnkgc29tZSBmbG9hdGluZy1wb2ludCBhbm5veWFuY2Ugd2UgaGF2ZVxuXHRcdC8vIHJhbmRvbSA+PSB0b3RhbCwganVzdCByZXR1cm4gdGhlIGxhc3QgaWQuXG5cdFx0cmV0dXJuIGlkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgUk5HIHN0YXRlLiBVc2VmdWwgZm9yIHN0b3JpbmcgdGhlIHN0YXRlIGFuZCByZS1zZXR0aW5nIGl0IHZpYSBzZXRTdGF0ZS5cblx0ICogQHJldHVybnMgez99IEludGVybmFsIHN0YXRlXG5cdCAqL1xuXHRnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFt0aGlzLl9zMCwgdGhpcy5fczEsIHRoaXMuX3MyLCB0aGlzLl9jXTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IGEgcHJldmlvdXNseSByZXRyaWV2ZWQgc3RhdGUuXG5cdCAqIEBwYXJhbSB7P30gc3RhdGVcblx0ICovXG5cdHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdHRoaXMuX3MwID0gc3RhdGVbMF07XG5cdFx0dGhpcy5fczEgPSBzdGF0ZVsxXTtcblx0XHR0aGlzLl9zMiA9IHN0YXRlWzJdO1xuXHRcdHRoaXMuX2MgID0gc3RhdGVbM107XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZWQgUk5HXG5cdCAqL1xuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcblx0XHRjbG9uZS5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlKCkpO1xuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRfczA6IDAsXG5cdF9zMTogMCxcblx0X3MyOiAwLFxuXHRfYzogMCxcblx0X2ZyYWM6IDIuMzI4MzA2NDM2NTM4Njk2M2UtMTAgLyogMl4tMzIgKi9cbn1cblxuUk9ULlJORy5zZXRTZWVkKERhdGUubm93KCkpO1xuLyoqXG4gKiBAY2xhc3MgKE1hcmtvdiBwcm9jZXNzKS1iYXNlZCBzdHJpbmcgZ2VuZXJhdG9yLiBcbiAqIENvcGllZCBmcm9tIGEgPGEgaHJlZj1cImh0dHA6Ly93d3cucm9ndWViYXNpbi5yb2d1ZWxpa2VkZXZlbG9wbWVudC5vcmcvaW5kZXgucGhwP3RpdGxlPU5hbWVzX2Zyb21fYV9oaWdoX29yZGVyX01hcmtvdl9Qcm9jZXNzX2FuZF9hX3NpbXBsaWZpZWRfS2F0el9iYWNrLW9mZl9zY2hlbWVcIj5Sb2d1ZUJhc2luIGFydGljbGU8L2E+LiBcbiAqIE9mZmVycyBjb25maWd1cmFibGUgb3JkZXIgYW5kIHByaW9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sfSBbb3B0aW9ucy53b3Jkcz1mYWxzZV0gVXNlIHdvcmQgbW9kZT9cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5vcmRlcj0zXVxuICogQHBhcmFtIHtmbG9hdH0gW29wdGlvbnMucHJpb3I9MC4wMDFdXG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0d29yZHM6IGZhbHNlLFxuXHRcdG9yZGVyOiAzLFxuXHRcdHByaW9yOiAwLjAwMVxuXHR9XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxuXG5cdHRoaXMuX2JvdW5kYXJ5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTtcblx0dGhpcy5fc3VmZml4ID0gdGhpcy5fYm91bmRhcnk7XG5cdHRoaXMuX3ByZWZpeCA9IFtdO1xuXHRmb3IgKHZhciBpPTA7aTx0aGlzLl9vcHRpb25zLm9yZGVyO2krKykgeyB0aGlzLl9wcmVmaXgucHVzaCh0aGlzLl9ib3VuZGFyeSk7IH1cblxuXHR0aGlzLl9wcmlvclZhbHVlcyA9IHt9O1xuXHR0aGlzLl9wcmlvclZhbHVlc1t0aGlzLl9ib3VuZGFyeV0gPSB0aGlzLl9vcHRpb25zLnByaW9yO1xuXG5cdHRoaXMuX2RhdGEgPSB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxlYXJuaW5nIGRhdGFcbiAqL1xuUk9ULlN0cmluZ0dlbmVyYXRvci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fZGF0YSA9IHt9O1xuXHR0aGlzLl9wcmlvclZhbHVlcyA9IHt9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEdlbmVyYXRlZCBzdHJpbmdcbiAqL1xuUk9ULlN0cmluZ0dlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHJlc3VsdCA9IFt0aGlzLl9zYW1wbGUodGhpcy5fcHJlZml4KV07XG5cdHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aC0xXSAhPSB0aGlzLl9ib3VuZGFyeSkge1xuXHRcdHJlc3VsdC5wdXNoKHRoaXMuX3NhbXBsZShyZXN1bHQpKTtcblx0fVxuXHRyZXR1cm4gdGhpcy5fam9pbihyZXN1bHQuc2xpY2UoMCwgLTEpKTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlIChsZWFybikgYSBzdHJpbmcgZnJvbSBhIHRyYWluaW5nIHNldFxuICovXG5ST1QuU3RyaW5nR2VuZXJhdG9yLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdHZhciB0b2tlbnMgPSB0aGlzLl9zcGxpdChzdHJpbmcpO1xuXG5cdGZvciAodmFyIGk9MDsgaTx0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLl9wcmlvclZhbHVlc1t0b2tlbnNbaV1dID0gdGhpcy5fb3B0aW9ucy5wcmlvcjtcblx0fVxuXG5cdHRva2VucyA9IHRoaXMuX3ByZWZpeC5jb25jYXQodG9rZW5zKS5jb25jYXQodGhpcy5fc3VmZml4KTsgLyogYWRkIGJvdW5kYXJ5IHN5bWJvbHMgKi9cblxuXHRmb3IgKHZhciBpPXRoaXMuX29wdGlvbnMub3JkZXI7IGk8dG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNvbnRleHQgPSB0b2tlbnMuc2xpY2UoaS10aGlzLl9vcHRpb25zLm9yZGVyLCBpKTtcblx0XHR2YXIgZXZlbnQgPSB0b2tlbnNbaV07XG5cdFx0Zm9yICh2YXIgaj0wOyBqPGNvbnRleHQubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBzdWJjb250ZXh0ID0gY29udGV4dC5zbGljZShqKTtcblx0XHRcdHRoaXMuX29ic2VydmVFdmVudChzdWJjb250ZXh0LCBldmVudCk7XG5cdFx0fVxuXHR9XG59XG5cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBwYXJ0cyA9IFtdO1xuXG5cdHZhciBwcmlvckNvdW50ID0gMDtcblx0Zm9yICh2YXIgcCBpbiB0aGlzLl9wcmlvclZhbHVlcykgeyBwcmlvckNvdW50Kys7IH1cblx0cHJpb3JDb3VudC0tOyAvKiBib3VuZGFyeSAqL1xuXHRwYXJ0cy5wdXNoKFwiZGlzdGluY3Qgc2FtcGxlczogXCIgKyBwcmlvckNvdW50KTtcblxuXHR2YXIgZGF0YUNvdW50ID0gMDtcblx0dmFyIGV2ZW50Q291bnQgPSAwO1xuXHRmb3IgKHZhciBwIGluIHRoaXMuX2RhdGEpIHsgXG5cdFx0ZGF0YUNvdW50Kys7IFxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl9kYXRhW3BdKSB7XG5cdFx0XHRldmVudENvdW50Kys7XG5cdFx0fVxuXHR9XG5cdHBhcnRzLnB1c2goXCJkaWN0aW9uYXJ5IHNpemUgKGNvbnRleHRzKTogXCIgKyBkYXRhQ291bnQpO1xuXHRwYXJ0cy5wdXNoKFwiZGljdGlvbmFyeSBzaXplIChldmVudHMpOiBcIiArIGV2ZW50Q291bnQpO1xuXG5cdHJldHVybiBwYXJ0cy5qb2luKFwiLCBcIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLl9zcGxpdCA9IGZ1bmN0aW9uKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KHRoaXMuX29wdGlvbnMud29yZHMgPyAvXFxzKy8gOiBcIlwiKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfVxuICogQHJldHVybnMge3N0cmluZ30gXG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLl9qb2luID0gZnVuY3Rpb24oYXJyKSB7XG5cdHJldHVybiBhcnIuam9pbih0aGlzLl9vcHRpb25zLndvcmRzID8gXCIgXCIgOiBcIlwiKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjb250ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqL1xuUk9ULlN0cmluZ0dlbmVyYXRvci5wcm90b3R5cGUuX29ic2VydmVFdmVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIGV2ZW50KSB7XG5cdHZhciBrZXkgPSB0aGlzLl9qb2luKGNvbnRleHQpO1xuXHRpZiAoIShrZXkgaW4gdGhpcy5fZGF0YSkpIHsgdGhpcy5fZGF0YVtrZXldID0ge307IH1cblx0dmFyIGRhdGEgPSB0aGlzLl9kYXRhW2tleV07XG5cblx0aWYgKCEoZXZlbnQgaW4gZGF0YSkpIHsgZGF0YVtldmVudF0gPSAwOyB9XG5cdGRhdGFbZXZlbnRdKys7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLl9zYW1wbGUgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdGNvbnRleHQgPSB0aGlzLl9iYWNrb2ZmKGNvbnRleHQpO1xuXHR2YXIga2V5ID0gdGhpcy5fam9pbihjb250ZXh0KTtcblx0dmFyIGRhdGEgPSB0aGlzLl9kYXRhW2tleV07XG5cblx0dmFyIGF2YWlsYWJsZSA9IHt9O1xuXG5cdGlmICh0aGlzLl9vcHRpb25zLnByaW9yKSB7XG5cdFx0Zm9yICh2YXIgZXZlbnQgaW4gdGhpcy5fcHJpb3JWYWx1ZXMpIHsgYXZhaWxhYmxlW2V2ZW50XSA9IHRoaXMuX3ByaW9yVmFsdWVzW2V2ZW50XTsgfVxuXHRcdGZvciAodmFyIGV2ZW50IGluIGRhdGEpIHsgYXZhaWxhYmxlW2V2ZW50XSArPSBkYXRhW2V2ZW50XTsgfVxuXHR9IGVsc2UgeyBcblx0XHRhdmFpbGFibGUgPSBkYXRhO1xuXHR9XG5cblx0cmV0dXJuIFJPVC5STkcuZ2V0V2VpZ2h0ZWRWYWx1ZShhdmFpbGFibGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cblJPVC5TdHJpbmdHZW5lcmF0b3IucHJvdG90eXBlLl9iYWNrb2ZmID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRpZiAoY29udGV4dC5sZW5ndGggPiB0aGlzLl9vcHRpb25zLm9yZGVyKSB7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQuc2xpY2UoLXRoaXMuX29wdGlvbnMub3JkZXIpO1xuXHR9IGVsc2UgaWYgKGNvbnRleHQubGVuZ3RoIDwgdGhpcy5fb3B0aW9ucy5vcmRlcikge1xuXHRcdGNvbnRleHQgPSB0aGlzLl9wcmVmaXguc2xpY2UoMCwgdGhpcy5fb3B0aW9ucy5vcmRlciAtIGNvbnRleHQubGVuZ3RoKS5jb25jYXQoY29udGV4dCk7XG5cdH1cblxuXHR3aGlsZSAoISh0aGlzLl9qb2luKGNvbnRleHQpIGluIHRoaXMuX2RhdGEpICYmIGNvbnRleHQubGVuZ3RoID4gMCkgeyBjb250ZXh0ID0gY29udGV4dC5zbGljZSgxKTsgfVxuXG5cdHJldHVybiBjb250ZXh0O1xufVxuLyoqXG4gKiBAY2xhc3MgR2VuZXJpYyBldmVudCBxdWV1ZTogc3RvcmVzIGV2ZW50cyBhbmQgcmV0cmlldmVzIHRoZW0gYmFzZWQgb24gdGhlaXIgdGltZVxuICovXG5ST1QuRXZlbnRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl90aW1lID0gMDtcblx0dGhpcy5fZXZlbnRzID0gW107XG5cdHRoaXMuX2V2ZW50VGltZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBFbGFwc2VkIHRpbWVcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX3RpbWU7XG59XG5cbi8qKlxuICogQ2xlYXIgYWxsIHNjaGVkdWxlZCBldmVudHNcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX2V2ZW50cyA9IFtdO1xuXHR0aGlzLl9ldmVudFRpbWVzID0gW107XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7P30gZXZlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gKi9cblJPVC5FdmVudFF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihldmVudCwgdGltZSkge1xuXHR2YXIgaW5kZXggPSB0aGlzLl9ldmVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpPTA7aTx0aGlzLl9ldmVudFRpbWVzLmxlbmd0aDtpKyspIHtcblx0XHRpZiAodGhpcy5fZXZlbnRUaW1lc1tpXSA+IHRpbWUpIHtcblx0XHRcdGluZGV4ID0gaTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMuX2V2ZW50cy5zcGxpY2UoaW5kZXgsIDAsIGV2ZW50KTtcblx0dGhpcy5fZXZlbnRUaW1lcy5zcGxpY2UoaW5kZXgsIDAsIHRpbWUpO1xufVxuXG4vKipcbiAqIExvY2F0ZXMgdGhlIG5lYXJlc3QgZXZlbnQsIGFkdmFuY2VzIHRpbWUgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIHRoYXQgZXZlbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcXVldWUuXG4gKiBAcmV0dXJucyB7PyB8fCBudWxsfSBUaGUgZXZlbnQgcHJldmlvdXNseSBhZGRlZCBieSBhZGRFdmVudCwgbnVsbCBpZiBubyBldmVudCBhdmFpbGFibGVcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuX2V2ZW50cy5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblxuXHR2YXIgdGltZSA9IHRoaXMuX2V2ZW50VGltZXMuc3BsaWNlKDAsIDEpWzBdO1xuXHRpZiAodGltZSA+IDApIHsgLyogYWR2YW5jZSAqL1xuXHRcdHRoaXMuX3RpbWUgKz0gdGltZTtcblx0XHRmb3IgKHZhciBpPTA7aTx0aGlzLl9ldmVudFRpbWVzLmxlbmd0aDtpKyspIHsgdGhpcy5fZXZlbnRUaW1lc1tpXSAtPSB0aW1lOyB9XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5fZXZlbnRzLnNwbGljZSgwLCAxKVswXTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgcXVldWVcbiAqIEBwYXJhbSB7P30gZXZlbnRcbiAqIEByZXR1cm5zIHtib29sfSBzdWNjZXNzP1xuICovXG5ST1QuRXZlbnRRdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0dmFyIGluZGV4ID0gdGhpcy5fZXZlbnRzLmluZGV4T2YoZXZlbnQpO1xuXHRpZiAoaW5kZXggPT0gLTEpIHsgcmV0dXJuIGZhbHNlIH1cblx0dGhpcy5fcmVtb3ZlKGluZGV4KTtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGZyb20gdGhlIHF1ZXVlXG4gKiBAcGFyYW0ge2ludH0gaW5kZXhcbiAqL1xuUk9ULkV2ZW50UXVldWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbihpbmRleCkge1xuXHR0aGlzLl9ldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcblx0dGhpcy5fZXZlbnRUaW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xufVxuLyoqXG4gKiBAY2xhc3MgQWJzdHJhY3Qgc2NoZWR1bGVyXG4gKi9cblJPVC5TY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fcXVldWUgPSBuZXcgUk9ULkV2ZW50UXVldWUoKTtcblx0dGhpcy5fcmVwZWF0ID0gW107XG5cdHRoaXMuX2N1cnJlbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgUk9ULkV2ZW50UXVldWUjZ2V0VGltZVxuICovXG5ST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9xdWV1ZS5nZXRUaW1lKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/fSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2x9IHJlcGVhdFxuICovXG5ST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtLCByZXBlYXQpIHtcblx0aWYgKHJlcGVhdCkgeyB0aGlzLl9yZXBlYXQucHVzaChpdGVtKTsgfVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgaXRlbXNcbiAqL1xuUk9ULlNjaGVkdWxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fcXVldWUuY2xlYXIoKTtcblx0dGhpcy5fcmVwZWF0ID0gW107XG5cdHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBwcmV2aW91c2x5IGFkZGVkIGl0ZW1cbiAqIEBwYXJhbSB7P30gaXRlbVxuICogQHJldHVybnMge2Jvb2x9IHN1Y2Nlc3NmdWw/XG4gKi9cblJPVC5TY2hlZHVsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0dmFyIHJlc3VsdCA9IHRoaXMuX3F1ZXVlLnJlbW92ZShpdGVtKTtcblxuXHR2YXIgaW5kZXggPSB0aGlzLl9yZXBlYXQuaW5kZXhPZihpdGVtKTtcblx0aWYgKGluZGV4ICE9IC0xKSB7IHRoaXMuX3JlcGVhdC5zcGxpY2UoaW5kZXgsIDEpOyB9XG5cblx0aWYgKHRoaXMuX2N1cnJlbnQgPT0gaXRlbSkgeyB0aGlzLl9jdXJyZW50ID0gbnVsbDsgfVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogU2NoZWR1bGUgbmV4dCBpdGVtXG4gKiBAcmV0dXJucyB7P31cbiAqL1xuUk9ULlNjaGVkdWxlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9jdXJyZW50ID0gdGhpcy5fcXVldWUuZ2V0KCk7XG5cdHJldHVybiB0aGlzLl9jdXJyZW50O1xufVxuLyoqXG4gKiBAY2xhc3MgU2ltcGxlIGZhaXIgc2NoZWR1bGVyIChyb3VuZC1yb2JpbiBzdHlsZSlcbiAqIEBhdWdtZW50cyBST1QuU2NoZWR1bGVyXG4gKi9cblJPVC5TY2hlZHVsZXIuU2ltcGxlID0gZnVuY3Rpb24oKSB7XG5cdFJPVC5TY2hlZHVsZXIuY2FsbCh0aGlzKTtcbn1cblJPVC5TY2hlZHVsZXIuU2ltcGxlLmV4dGVuZChST1QuU2NoZWR1bGVyKTtcblxuLyoqXG4gKiBAc2VlIFJPVC5TY2hlZHVsZXIjYWRkXG4gKi9cblJPVC5TY2hlZHVsZXIuU2ltcGxlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtLCByZXBlYXQpIHtcblx0dGhpcy5fcXVldWUuYWRkKGl0ZW0sIDApO1xuXHRyZXR1cm4gUk9ULlNjaGVkdWxlci5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgaXRlbSwgcmVwZWF0KTtcbn1cblxuLyoqXG4gKiBAc2VlIFJPVC5TY2hlZHVsZXIjbmV4dFxuICovXG5ST1QuU2NoZWR1bGVyLlNpbXBsZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9yZXBlYXQuaW5kZXhPZih0aGlzLl9jdXJyZW50KSAhPSAtMSkge1xuXHRcdHRoaXMuX3F1ZXVlLmFkZCh0aGlzLl9jdXJyZW50LCAwKTtcblx0fVxuXHRyZXR1cm4gUk9ULlNjaGVkdWxlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMpO1xufVxuLyoqXG4gKiBAY2xhc3MgU3BlZWQtYmFzZWQgc2NoZWR1bGVyXG4gKiBAYXVnbWVudHMgUk9ULlNjaGVkdWxlclxuICovXG5ST1QuU2NoZWR1bGVyLlNwZWVkID0gZnVuY3Rpb24oKSB7XG5cdFJPVC5TY2hlZHVsZXIuY2FsbCh0aGlzKTtcbn1cblJPVC5TY2hlZHVsZXIuU3BlZWQuZXh0ZW5kKFJPVC5TY2hlZHVsZXIpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGFueXRoaW5nIHdpdGggXCJnZXRTcGVlZFwiIG1ldGhvZFxuICogQHBhcmFtIHtib29sfSByZXBlYXRcbiAqIEBzZWUgUk9ULlNjaGVkdWxlciNhZGRcbiAqL1xuUk9ULlNjaGVkdWxlci5TcGVlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSwgcmVwZWF0KSB7XG5cdHRoaXMuX3F1ZXVlLmFkZChpdGVtLCAxL2l0ZW0uZ2V0U3BlZWQoKSk7XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBpdGVtLCByZXBlYXQpO1xufVxuXG4vKipcbiAqIEBzZWUgUk9ULlNjaGVkdWxlciNuZXh0XG4gKi9cblJPVC5TY2hlZHVsZXIuU3BlZWQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX2N1cnJlbnQgJiYgdGhpcy5fcmVwZWF0LmluZGV4T2YodGhpcy5fY3VycmVudCkgIT0gLTEpIHtcblx0XHR0aGlzLl9xdWV1ZS5hZGQodGhpcy5fY3VycmVudCwgMS90aGlzLl9jdXJyZW50LmdldFNwZWVkKCkpO1xuXHR9XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcyk7XG59XG4vKipcbiAqIEBjbGFzcyBBY3Rpb24tYmFzZWQgc2NoZWR1bGVyXG4gKiBAYXVnbWVudHMgUk9ULlNjaGVkdWxlclxuICovXG5ST1QuU2NoZWR1bGVyLkFjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRST1QuU2NoZWR1bGVyLmNhbGwodGhpcyk7XG5cdHRoaXMuX2RlZmF1bHREdXJhdGlvbiA9IDE7IC8qIGZvciBuZXdseSBhZGRlZCAqL1xuXHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX2RlZmF1bHREdXJhdGlvbjsgLyogZm9yIHRoaXMuX2N1cnJlbnQgKi9cbn1cblJPVC5TY2hlZHVsZXIuQWN0aW9uLmV4dGVuZChST1QuU2NoZWR1bGVyKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaXRlbVxuICogQHBhcmFtIHtib29sfSByZXBlYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT0xXVxuICogQHNlZSBST1QuU2NoZWR1bGVyI2FkZFxuICovXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSwgcmVwZWF0LCB0aW1lKSB7XG5cdHRoaXMuX3F1ZXVlLmFkZChpdGVtLCB0aW1lIHx8IHRoaXMuX2RlZmF1bHREdXJhdGlvbik7XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBpdGVtLCByZXBlYXQpO1xufVxuXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl9kZWZhdWx0RHVyYXRpb247XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMpO1xufVxuXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaXRlbSkge1xuXHRpZiAoaXRlbSA9PSB0aGlzLl9jdXJyZW50KSB7IHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fZGVmYXVsdER1cmF0aW9uOyB9XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBpdGVtKTtcbn1cblxuLyoqXG4gKiBAc2VlIFJPVC5TY2hlZHVsZXIjbmV4dFxuICovXG5ST1QuU2NoZWR1bGVyLkFjdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9yZXBlYXQuaW5kZXhPZih0aGlzLl9jdXJyZW50KSAhPSAtMSkge1xuXHRcdHRoaXMuX3F1ZXVlLmFkZCh0aGlzLl9jdXJyZW50LCB0aGlzLl9kdXJhdGlvbiB8fCB0aGlzLl9kZWZhdWx0RHVyYXRpb24pO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fZGVmYXVsdER1cmF0aW9uO1xuXHR9XG5cdHJldHVybiBST1QuU2NoZWR1bGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcyk7XG59XG5cbi8qKlxuICogU2V0IGR1cmF0aW9uIGZvciB0aGUgYWN0aXZlIGl0ZW1cbiAqL1xuUk9ULlNjaGVkdWxlci5BY3Rpb24ucHJvdG90eXBlLnNldER1cmF0aW9uID0gZnVuY3Rpb24odGltZSkge1xuXHRpZiAodGhpcy5fY3VycmVudCkgeyB0aGlzLl9kdXJhdGlvbiA9IHRpbWU7IH1cblx0cmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEBjbGFzcyBBc3luY2hyb25vdXMgbWFpbiBsb29wXG4gKiBAcGFyYW0ge1JPVC5TY2hlZHVsZXJ9IHNjaGVkdWxlclxuICovXG5ST1QuRW5naW5lID0gZnVuY3Rpb24oc2NoZWR1bGVyKSB7XG5cdHRoaXMuX3NjaGVkdWxlciA9IHNjaGVkdWxlcjtcblx0dGhpcy5fbG9jayA9IDE7XG59XG5cbi8qKlxuICogU3RhcnQgdGhlIG1haW4gbG9vcC4gV2hlbiB0aGlzIGNhbGwgcmV0dXJucywgdGhlIGxvb3AgaXMgbG9ja2VkLlxuICovXG5ST1QuRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy51bmxvY2soKTtcbn1cblxuLyoqXG4gKiBJbnRlcnJ1cHQgdGhlIGVuZ2luZSBieSBhbiBhc3luY2hyb25vdXMgYWN0aW9uXG4gKi9cblJPVC5FbmdpbmUucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fbG9jaysrO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBSZXN1bWUgZXhlY3V0aW9uIChwYXVzZWQgYnkgYSBwcmV2aW91cyBsb2NrKVxuICovXG5ST1QuRW5naW5lLnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLl9sb2NrKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1bmxvY2sgdW5sb2NrZWQgZW5naW5lXCIpOyB9XG5cdHRoaXMuX2xvY2stLTtcblxuXHR3aGlsZSAoIXRoaXMuX2xvY2spIHtcblx0XHR2YXIgYWN0b3IgPSB0aGlzLl9zY2hlZHVsZXIubmV4dCgpO1xuXHRcdGlmICghYWN0b3IpIHsgcmV0dXJuIHRoaXMubG9jaygpOyB9IC8qIG5vIGFjdG9ycyAqL1xuXHRcdHZhciByZXN1bHQgPSBhY3Rvci5hY3QoKTtcblx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7IC8qIGFjdG9yIHJldHVybmVkIGEgXCJ0aGVuYWJsZVwiLCBsb29rcyBsaWtlIGEgUHJvbWlzZSAqL1xuXHRcdFx0dGhpcy5sb2NrKCk7XG5cdFx0XHRyZXN1bHQudGhlbih0aGlzLnVubG9jay5iaW5kKHRoaXMpKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cbi8qKlxuICogQGNsYXNzIEJhc2UgbWFwIGdlbmVyYXRvclxuICogQHBhcmFtIHtpbnR9IFt3aWR0aD1ST1QuREVGQVVMVF9XSURUSF1cbiAqIEBwYXJhbSB7aW50fSBbaGVpZ2h0PVJPVC5ERUZBVUxUX0hFSUdIVF1cbiAqL1xuUk9ULk1hcCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0dGhpcy5fd2lkdGggPSB3aWR0aCB8fCBST1QuREVGQVVMVF9XSURUSDtcblx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0IHx8IFJPVC5ERUZBVUxUX0hFSUdIVDtcbn07XG5cblJPVC5NYXAucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7fVxuXG5ST1QuTWFwLnByb3RvdHlwZS5fZmlsbE1hcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHZhciBtYXAgPSBbXTtcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fd2lkdGg7aSsrKSB7XG5cdFx0bWFwLnB1c2goW10pO1xuXHRcdGZvciAodmFyIGo9MDtqPHRoaXMuX2hlaWdodDtqKyspIHsgbWFwW2ldLnB1c2godmFsdWUpOyB9XG5cdH1cblx0cmV0dXJuIG1hcDtcbn1cbi8qKlxuICogQGNsYXNzIFNpbXBsZSBlbXB0eSByZWN0YW5ndWxhciByb29tXG4gKiBAYXVnbWVudHMgUk9ULk1hcFxuICovXG5ST1QuTWFwLkFyZW5hID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG59XG5ST1QuTWFwLkFyZW5hLmV4dGVuZChST1QuTWFwKTtcblxuUk9ULk1hcC5BcmVuYS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dmFyIHcgPSB0aGlzLl93aWR0aC0xO1xuXHR2YXIgaCA9IHRoaXMuX2hlaWdodC0xO1xuXHRmb3IgKHZhciBpPTA7aTw9dztpKyspIHtcblx0XHRmb3IgKHZhciBqPTA7ajw9aDtqKyspIHtcblx0XHRcdHZhciBlbXB0eSA9IChpICYmIGogJiYgaTx3ICYmIGo8aCk7XG5cdFx0XHRjYWxsYmFjayhpLCBqLCBlbXB0eSA/IDAgOiAxKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEBjbGFzcyBSZWN1cnNpdmVseSBkaXZpZGVkIG1hemUsIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF6ZV9nZW5lcmF0aW9uX2FsZ29yaXRobSNSZWN1cnNpdmVfZGl2aXNpb25fbWV0aG9kXG4gKiBAYXVnbWVudHMgUk9ULk1hcFxuICovXG5ST1QuTWFwLkRpdmlkZWRNYXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG5cdHRoaXMuX3N0YWNrID0gW107XG59XG5ST1QuTWFwLkRpdmlkZWRNYXplLmV4dGVuZChST1QuTWFwKTtcblxuUk9ULk1hcC5EaXZpZGVkTWF6ZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dmFyIHcgPSB0aGlzLl93aWR0aDtcblx0dmFyIGggPSB0aGlzLl9oZWlnaHQ7XG5cdFxuXHR0aGlzLl9tYXAgPSBbXTtcblx0XG5cdGZvciAodmFyIGk9MDtpPHc7aSsrKSB7XG5cdFx0dGhpcy5fbWFwLnB1c2goW10pO1xuXHRcdGZvciAodmFyIGo9MDtqPGg7aisrKSB7XG5cdFx0XHR2YXIgYm9yZGVyID0gKGkgPT0gMCB8fCBqID09IDAgfHwgaSsxID09IHcgfHwgaisxID09IGgpO1xuXHRcdFx0dGhpcy5fbWFwW2ldLnB1c2goYm9yZGVyID8gMSA6IDApO1xuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5fc3RhY2sgPSBbXG5cdFx0WzEsIDEsIHctMiwgaC0yXVxuXHRdO1xuXHR0aGlzLl9wcm9jZXNzKCk7XG5cdFxuXHRmb3IgKHZhciBpPTA7aTx3O2krKykge1xuXHRcdGZvciAodmFyIGo9MDtqPGg7aisrKSB7XG5cdFx0XHRjYWxsYmFjayhpLCBqLCB0aGlzLl9tYXBbaV1bal0pO1xuXHRcdH1cblx0fVxuXHR0aGlzLl9tYXAgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5EaXZpZGVkTWF6ZS5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0d2hpbGUgKHRoaXMuX3N0YWNrLmxlbmd0aCkge1xuXHRcdHZhciByb29tID0gdGhpcy5fc3RhY2suc2hpZnQoKTsgLyogW2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbV0gKi9cblx0XHR0aGlzLl9wYXJ0aXRpb25Sb29tKHJvb20pO1xuXHR9XG59XG5cblJPVC5NYXAuRGl2aWRlZE1hemUucHJvdG90eXBlLl9wYXJ0aXRpb25Sb29tID0gZnVuY3Rpb24ocm9vbSkge1xuXHR2YXIgYXZhaWxYID0gW107XG5cdHZhciBhdmFpbFkgPSBbXTtcblx0XG5cdGZvciAodmFyIGk9cm9vbVswXSsxO2k8cm9vbVsyXTtpKyspIHtcblx0XHR2YXIgdG9wID0gdGhpcy5fbWFwW2ldW3Jvb21bMV0tMV07XG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX21hcFtpXVtyb29tWzNdKzFdO1xuXHRcdGlmICh0b3AgJiYgYm90dG9tICYmICEoaSAlIDIpKSB7IGF2YWlsWC5wdXNoKGkpOyB9XG5cdH1cblx0XG5cdGZvciAodmFyIGo9cm9vbVsxXSsxO2o8cm9vbVszXTtqKyspIHtcblx0XHR2YXIgbGVmdCA9IHRoaXMuX21hcFtyb29tWzBdLTFdW2pdO1xuXHRcdHZhciByaWdodCA9IHRoaXMuX21hcFtyb29tWzJdKzFdW2pdO1xuXHRcdGlmIChsZWZ0ICYmIHJpZ2h0ICYmICEoaiAlIDIpKSB7IGF2YWlsWS5wdXNoKGopOyB9XG5cdH1cblxuXHRpZiAoIWF2YWlsWC5sZW5ndGggfHwgIWF2YWlsWS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cblx0dmFyIHggPSBhdmFpbFgucmFuZG9tKCk7XG5cdHZhciB5ID0gYXZhaWxZLnJhbmRvbSgpO1xuXHRcblx0dGhpcy5fbWFwW3hdW3ldID0gMTtcblx0XG5cdHZhciB3YWxscyA9IFtdO1xuXHRcblx0dmFyIHcgPSBbXTsgd2FsbHMucHVzaCh3KTsgLyogbGVmdCBwYXJ0ICovXG5cdGZvciAodmFyIGk9cm9vbVswXTsgaTx4OyBpKyspIHsgXG5cdFx0dGhpcy5fbWFwW2ldW3ldID0gMTtcblx0XHR3LnB1c2goW2ksIHldKTsgXG5cdH1cblx0XG5cdHZhciB3ID0gW107IHdhbGxzLnB1c2godyk7IC8qIHJpZ2h0IHBhcnQgKi9cblx0Zm9yICh2YXIgaT14KzE7IGk8PXJvb21bMl07IGkrKykgeyBcblx0XHR0aGlzLl9tYXBbaV1beV0gPSAxO1xuXHRcdHcucHVzaChbaSwgeV0pOyBcblx0fVxuXG5cdHZhciB3ID0gW107IHdhbGxzLnB1c2godyk7IC8qIHRvcCBwYXJ0ICovXG5cdGZvciAodmFyIGo9cm9vbVsxXTsgajx5OyBqKyspIHsgXG5cdFx0dGhpcy5fbWFwW3hdW2pdID0gMTtcblx0XHR3LnB1c2goW3gsIGpdKTsgXG5cdH1cblx0XG5cdHZhciB3ID0gW107IHdhbGxzLnB1c2godyk7IC8qIGJvdHRvbSBwYXJ0ICovXG5cdGZvciAodmFyIGo9eSsxOyBqPD1yb29tWzNdOyBqKyspIHsgXG5cdFx0dGhpcy5fbWFwW3hdW2pdID0gMTtcblx0XHR3LnB1c2goW3gsIGpdKTsgXG5cdH1cblx0XHRcblx0dmFyIHNvbGlkID0gd2FsbHMucmFuZG9tKCk7XG5cdGZvciAodmFyIGk9MDtpPHdhbGxzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgdyA9IHdhbGxzW2ldO1xuXHRcdGlmICh3ID09IHNvbGlkKSB7IGNvbnRpbnVlOyB9XG5cdFx0XG5cdFx0dmFyIGhvbGUgPSB3LnJhbmRvbSgpO1xuXHRcdHRoaXMuX21hcFtob2xlWzBdXVtob2xlWzFdXSA9IDA7XG5cdH1cblxuXHR0aGlzLl9zdGFjay5wdXNoKFtyb29tWzBdLCByb29tWzFdLCB4LTEsIHktMV0pOyAvKiBsZWZ0IHRvcCAqL1xuXHR0aGlzLl9zdGFjay5wdXNoKFt4KzEsIHJvb21bMV0sIHJvb21bMl0sIHktMV0pOyAvKiByaWdodCB0b3AgKi9cblx0dGhpcy5fc3RhY2sucHVzaChbcm9vbVswXSwgeSsxLCB4LTEsIHJvb21bM11dKTsgLyogbGVmdCBib3R0b20gKi9cblx0dGhpcy5fc3RhY2sucHVzaChbeCsxLCB5KzEsIHJvb21bMl0sIHJvb21bM11dKTsgLyogcmlnaHQgYm90dG9tICovXG59XG4vKipcbiAqIEBjbGFzcyBJY2V5J3MgTWF6ZSBnZW5lcmF0b3JcbiAqIFNlZSBodHRwOi8vd3d3LnJvZ3VlYmFzaW4ucm9ndWVsaWtlZGV2ZWxvcG1lbnQub3JnL2luZGV4LnBocD90aXRsZT1TaW1wbGVfbWF6ZSBmb3IgZXhwbGFuYXRpb25cbiAqIEBhdWdtZW50cyBST1QuTWFwXG4gKi9cblJPVC5NYXAuSWNleU1hemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByZWd1bGFyaXR5KSB7XG5cdFJPVC5NYXAuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcblx0dGhpcy5fcmVndWxhcml0eSA9IHJlZ3VsYXJpdHkgfHwgMDtcbn1cblJPVC5NYXAuSWNleU1hemUuZXh0ZW5kKFJPVC5NYXApO1xuXG5ST1QuTWFwLkljZXlNYXplLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHR2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcblx0dmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblx0XG5cdHZhciBtYXAgPSB0aGlzLl9maWxsTWFwKDEpO1xuXHRcblx0d2lkdGggLT0gKHdpZHRoICUgMiA/IDEgOiAyKTtcblx0aGVpZ2h0IC09IChoZWlnaHQgJSAyID8gMSA6IDIpO1xuXG5cdHZhciBjeCA9IDA7XG5cdHZhciBjeSA9IDA7XG5cdHZhciBueCA9IDA7XG5cdHZhciBueSA9IDA7XG5cblx0dmFyIGRvbmUgPSAwO1xuXHR2YXIgYmxvY2tlZCA9IGZhbHNlO1xuXHR2YXIgZGlycyA9IFtcblx0XHRbMCwgMF0sXG5cdFx0WzAsIDBdLFxuXHRcdFswLCAwXSxcblx0XHRbMCwgMF1cblx0XTtcblx0ZG8ge1xuXHRcdGN4ID0gMSArIDIqTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSood2lkdGgtMSkgLyAyKTtcblx0XHRjeSA9IDEgKyAyKk1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKGhlaWdodC0xKSAvIDIpO1xuXG5cdFx0aWYgKCFkb25lKSB7IG1hcFtjeF1bY3ldID0gMDsgfVxuXHRcdFxuXHRcdGlmICghbWFwW2N4XVtjeV0pIHtcblx0XHRcdHRoaXMuX3JhbmRvbWl6ZShkaXJzKTtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqKHRoaXMuX3JlZ3VsYXJpdHkrMSkpID09IDApIHsgdGhpcy5fcmFuZG9taXplKGRpcnMpOyB9XG5cdFx0XHRcdGJsb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7aTw0O2krKykge1xuXHRcdFx0XHRcdG54ID0gY3ggKyBkaXJzW2ldWzBdKjI7XG5cdFx0XHRcdFx0bnkgPSBjeSArIGRpcnNbaV1bMV0qMjtcblx0XHRcdFx0XHRpZiAodGhpcy5faXNGcmVlKG1hcCwgbngsIG55LCB3aWR0aCwgaGVpZ2h0KSkge1xuXHRcdFx0XHRcdFx0bWFwW254XVtueV0gPSAwO1xuXHRcdFx0XHRcdFx0bWFwW2N4ICsgZGlyc1tpXVswXV1bY3kgKyBkaXJzW2ldWzFdXSA9IDA7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGN4ID0gbng7XG5cdFx0XHRcdFx0XHRjeSA9IG55O1xuXHRcdFx0XHRcdFx0YmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0ZG9uZSsrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICghYmxvY2tlZCk7XG5cdFx0fVxuXHR9IHdoaWxlIChkb25lKzEgPCB3aWR0aCpoZWlnaHQvNCk7XG5cdFxuXHRmb3IgKHZhciBpPTA7aTx0aGlzLl93aWR0aDtpKyspIHtcblx0XHRmb3IgKHZhciBqPTA7ajx0aGlzLl9oZWlnaHQ7aisrKSB7XG5cdFx0XHRjYWxsYmFjayhpLCBqLCBtYXBbaV1bal0pO1xuXHRcdH1cblx0fVxuXHR0aGlzLl9tYXAgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5JY2V5TWF6ZS5wcm90b3R5cGUuX3JhbmRvbWl6ZSA9IGZ1bmN0aW9uKGRpcnMpIHtcblx0Zm9yICh2YXIgaT0wO2k8NDtpKyspIHtcblx0XHRkaXJzW2ldWzBdID0gMDtcblx0XHRkaXJzW2ldWzFdID0gMDtcblx0fVxuXHRcblx0c3dpdGNoIChNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpKjQpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0ZGlyc1swXVswXSA9IC0xOyBkaXJzWzFdWzBdID0gMTtcblx0XHRcdGRpcnNbMl1bMV0gPSAtMTsgZGlyc1szXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0ZGlyc1szXVswXSA9IC0xOyBkaXJzWzJdWzBdID0gMTtcblx0XHRcdGRpcnNbMV1bMV0gPSAtMTsgZGlyc1swXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0ZGlyc1syXVswXSA9IC0xOyBkaXJzWzNdWzBdID0gMTtcblx0XHRcdGRpcnNbMF1bMV0gPSAtMTsgZGlyc1sxXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0ZGlyc1sxXVswXSA9IC0xOyBkaXJzWzBdWzBdID0gMTtcblx0XHRcdGRpcnNbM11bMV0gPSAtMTsgZGlyc1syXVsxXSA9IDE7XG5cdFx0YnJlYWs7XG5cdH1cbn1cblxuUk9ULk1hcC5JY2V5TWF6ZS5wcm90b3R5cGUuX2lzRnJlZSA9IGZ1bmN0aW9uKG1hcCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRpZiAoeCA8IDEgfHwgeSA8IDEgfHwgeCA+PSB3aWR0aCB8fCB5ID49IGhlaWdodCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIG1hcFt4XVt5XTtcbn1cbi8qKlxuICogQGNsYXNzIE1hemUgZ2VuZXJhdG9yIC0gRWxsZXIncyBhbGdvcml0aG1cbiAqIFNlZSBodHRwOi8vaG9tZXBhZ2VzLmN3aS5ubC9+dHJvbXAvbWF6ZS5odG1sIGZvciBleHBsYW5hdGlvblxuICogQGF1Z21lbnRzIFJPVC5NYXBcbiAqL1xuUk9ULk1hcC5FbGxlck1hemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFJPVC5NYXAuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbn1cblJPVC5NYXAuRWxsZXJNYXplLmV4dGVuZChST1QuTWFwKTtcblxuUk9ULk1hcC5FbGxlck1hemUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciBtYXAgPSB0aGlzLl9maWxsTWFwKDEpO1xuXHR2YXIgdyA9IE1hdGguY2VpbCgodGhpcy5fd2lkdGgtMikvMik7XG5cdFxuXHR2YXIgcmFuZCA9IDkvMjQ7XG5cdFxuXHR2YXIgTCA9IFtdO1xuXHR2YXIgUiA9IFtdO1xuXHRcblx0Zm9yICh2YXIgaT0wO2k8dztpKyspIHtcblx0XHRMLnB1c2goaSk7XG5cdFx0Ui5wdXNoKGkpO1xuXHR9XG5cdEwucHVzaCh3LTEpOyAvKiBmYWtlIHN0b3AtYmxvY2sgYXQgdGhlIHJpZ2h0IHNpZGUgKi9cblxuXHRmb3IgKHZhciBqPTE7aiszPHRoaXMuX2hlaWdodDtqKz0yKSB7XG5cdFx0Lyogb25lIHJvdyAqL1xuXHRcdGZvciAodmFyIGk9MDtpPHc7aSsrKSB7XG5cdFx0XHQvKiBjZWxsIGNvb3JkcyAod2lsbCBiZSBhbHdheXMgZW1wdHkpICovXG5cdFx0XHR2YXIgeCA9IDIqaSsxO1xuXHRcdFx0dmFyIHkgPSBqO1xuXHRcdFx0bWFwW3hdW3ldID0gMDtcblx0XHRcdFxuXHRcdFx0LyogcmlnaHQgY29ubmVjdGlvbiAqL1xuXHRcdFx0aWYgKGkgIT0gTFtpKzFdICYmIFJPVC5STkcuZ2V0VW5pZm9ybSgpID4gcmFuZCkge1xuXHRcdFx0XHR0aGlzLl9hZGRUb0xpc3QoaSwgTCwgUik7XG5cdFx0XHRcdG1hcFt4KzFdW3ldID0gMDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyogYm90dG9tIGNvbm5lY3Rpb24gKi9cblx0XHRcdGlmIChpICE9IExbaV0gJiYgUk9ULlJORy5nZXRVbmlmb3JtKCkgPiByYW5kKSB7XG5cdFx0XHRcdC8qIHJlbW92ZSBjb25uZWN0aW9uICovXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21MaXN0KGksIEwsIFIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogY3JlYXRlIGNvbm5lY3Rpb24gKi9cblx0XHRcdFx0bWFwW3hdW3krMV0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qIGxhc3Qgcm93ICovXG5cdGZvciAodmFyIGk9MDtpPHc7aSsrKSB7XG5cdFx0LyogY2VsbCBjb29yZHMgKHdpbGwgYmUgYWx3YXlzIGVtcHR5KSAqL1xuXHRcdHZhciB4ID0gMippKzE7XG5cdFx0dmFyIHkgPSBqO1xuXHRcdG1hcFt4XVt5XSA9IDA7XG5cdFx0XG5cdFx0LyogcmlnaHQgY29ubmVjdGlvbiAqL1xuXHRcdGlmIChpICE9IExbaSsxXSAmJiAoaSA9PSBMW2ldIHx8IFJPVC5STkcuZ2V0VW5pZm9ybSgpID4gcmFuZCkpIHtcblx0XHRcdC8qIGRpZyByaWdodCBhbHNvIGlmIHRoZSBjZWxsIGlzIHNlcGFyYXRlZCwgc28gaXQgZ2V0cyBjb25uZWN0ZWQgdG8gdGhlIHJlc3Qgb2YgbWF6ZSAqL1xuXHRcdFx0dGhpcy5fYWRkVG9MaXN0KGksIEwsIFIpO1xuXHRcdFx0bWFwW3grMV1beV0gPSAwO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9yZW1vdmVGcm9tTGlzdChpLCBMLCBSKTtcblx0fVxuXHRcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fd2lkdGg7aSsrKSB7XG5cdFx0Zm9yICh2YXIgaj0wO2o8dGhpcy5faGVpZ2h0O2orKykge1xuXHRcdFx0Y2FsbGJhY2soaSwgaiwgbWFwW2ldW2pdKTtcblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJlbW92ZSBcImlcIiBmcm9tIGl0cyBsaXN0XG4gKi9cblJPVC5NYXAuRWxsZXJNYXplLnByb3RvdHlwZS5fcmVtb3ZlRnJvbUxpc3QgPSBmdW5jdGlvbihpLCBMLCBSKSB7XG5cdFJbTFtpXV0gPSBSW2ldO1xuXHRMW1JbaV1dID0gTFtpXTtcblx0UltpXSA9IGk7XG5cdExbaV0gPSBpO1xufVxuXG4vKipcbiAqIEpvaW4gbGlzdHMgd2l0aCBcImlcIiBhbmQgXCJpKzFcIlxuICovXG5ST1QuTWFwLkVsbGVyTWF6ZS5wcm90b3R5cGUuX2FkZFRvTGlzdCA9IGZ1bmN0aW9uKGksIEwsIFIpIHtcblx0UltMW2krMV1dID0gUltpXTtcblx0TFtSW2ldXSA9IExbaSsxXTtcblx0UltpXSA9IGkrMTtcblx0TFtpKzFdID0gaTtcbn1cbi8qKlxuICogQGNsYXNzIENlbGx1bGFyIGF1dG9tYXRvbiBtYXAgZ2VuZXJhdG9yXG4gKiBAYXVnbWVudHMgUk9ULk1hcFxuICogQHBhcmFtIHtpbnR9IFt3aWR0aD1ST1QuREVGQVVMVF9XSURUSF1cbiAqIEBwYXJhbSB7aW50fSBbaGVpZ2h0PVJPVC5ERUZBVUxUX0hFSUdIVF1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuYm9ybl0gTGlzdCBvZiBuZWlnaGJvciBjb3VudHMgZm9yIGEgbmV3IGNlbGwgdG8gYmUgYm9ybiBpbiBlbXB0eSBzcGFjZVxuICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuc3Vydml2ZV0gTGlzdCBvZiBuZWlnaGJvciBjb3VudHMgZm9yIGFuIGV4aXN0aW5nICBjZWxsIHRvIHN1cnZpdmVcbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy50b3BvbG9neV0gVG9wb2xvZ3kgNCBvciA2IG9yIDhcbiAqL1xuUk9ULk1hcC5DZWxsdWxhciA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblx0Uk9ULk1hcC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuXHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdGJvcm46IFs1LCA2LCA3LCA4XSxcblx0XHRzdXJ2aXZlOiBbNCwgNSwgNiwgNywgOF0sXG5cdFx0dG9wb2xvZ3k6IDgsXG5cdFx0Y29ubmVjdGVkOiBmYWxzZVxuXHR9O1xuXHR0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFxuXHR0aGlzLl9kaXJzID0gUk9ULkRJUlNbdGhpcy5fb3B0aW9ucy50b3BvbG9neV07XG5cdHRoaXMuX21hcCA9IHRoaXMuX2ZpbGxNYXAoMCk7XG59XG5ST1QuTWFwLkNlbGx1bGFyLmV4dGVuZChST1QuTWFwKTtcblxuLyoqXG4gKiBGaWxsIHRoZSBtYXAgd2l0aCByYW5kb20gdmFsdWVzXG4gKiBAcGFyYW0ge2Zsb2F0fSBwcm9iYWJpbGl0eSBQcm9iYWJpbGl0eSBmb3IgYSBjZWxsIHRvIGJlY29tZSBhbGl2ZTsgMCA9IGFsbCBlbXB0eSwgMSA9IGFsbCBmdWxsXG4gKi9cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLnJhbmRvbWl6ZSA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5KSB7XG5cdGZvciAodmFyIGk9MDtpPHRoaXMuX3dpZHRoO2krKykge1xuXHRcdGZvciAodmFyIGo9MDtqPHRoaXMuX2hlaWdodDtqKyspIHtcblx0XHRcdHRoaXMuX21hcFtpXVtqXSA9IChST1QuUk5HLmdldFVuaWZvcm0oKSA8IHByb2JhYmlsaXR5ID8gMSA6IDApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGFuZ2Ugb3B0aW9ucy5cbiAqIEBzZWUgUk9ULk1hcC5DZWxsdWxhclxuICovXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRmb3IgKHZhciBwIGluIG9wdGlvbnMpIHsgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07IH1cbn1cblxuUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcblx0dGhpcy5fbWFwW3hdW3ldID0gdmFsdWU7XG59XG5cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciBuZXdNYXAgPSB0aGlzLl9maWxsTWFwKDApO1xuXHR2YXIgYm9ybiA9IHRoaXMuX29wdGlvbnMuYm9ybjtcblx0dmFyIHN1cnZpdmUgPSB0aGlzLl9vcHRpb25zLnN1cnZpdmU7XG5cblxuXHRmb3IgKHZhciBqPTA7ajx0aGlzLl9oZWlnaHQ7aisrKSB7XG5cdFx0dmFyIHdpZHRoU3RlcCA9IDE7XG5cdFx0dmFyIHdpZHRoU3RhcnQgPSAwO1xuXHRcdGlmICh0aGlzLl9vcHRpb25zLnRvcG9sb2d5ID09IDYpIHsgXG5cdFx0XHR3aWR0aFN0ZXAgPSAyO1xuXHRcdFx0d2lkdGhTdGFydCA9IGolMjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpPXdpZHRoU3RhcnQ7IGk8dGhpcy5fd2lkdGg7IGkrPXdpZHRoU3RlcCkge1xuXG5cdFx0XHR2YXIgY3VyID0gdGhpcy5fbWFwW2ldW2pdO1xuXHRcdFx0dmFyIG5jb3VudCA9IHRoaXMuX2dldE5laWdoYm9ycyhpLCBqKTtcblx0XHRcdFxuXHRcdFx0aWYgKGN1ciAmJiBzdXJ2aXZlLmluZGV4T2YobmNvdW50KSAhPSAtMSkgeyAvKiBzdXJ2aXZlICovXG5cdFx0XHRcdG5ld01hcFtpXVtqXSA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKCFjdXIgJiYgYm9ybi5pbmRleE9mKG5jb3VudCkgIT0gLTEpIHsgLyogYm9ybiAqL1xuXHRcdFx0XHRuZXdNYXBbaV1bal0gPSAxO1xuXHRcdFx0fVx0XHRcdFxuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5fbWFwID0gbmV3TWFwO1xuXG5cdGlmICh0aGlzLl9vcHRpb25zLmNvbm5lY3RlZCkgeyB0aGlzLl9jb21wbGV0ZU1hemUoKTsgfSAvLyBvcHRpb25hbGx5IGNvbm5lY3QgZXZlcnkgc3BhY2VcblxuXHRpZiAoIWNhbGxiYWNrKSB7IHJldHVybjsgfVxuXG5cdGZvciAodmFyIGo9MDtqPHRoaXMuX2hlaWdodDtqKyspIHtcblx0XHR2YXIgd2lkdGhTdGVwID0gMTtcblx0XHR2YXIgd2lkdGhTdGFydCA9IDA7XG5cdFx0aWYgKHRoaXMuX29wdGlvbnMudG9wb2xvZ3kgPT0gNikgeyBcblx0XHRcdHdpZHRoU3RlcCA9IDI7XG5cdFx0XHR3aWR0aFN0YXJ0ID0gaiUyO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpPXdpZHRoU3RhcnQ7IGk8dGhpcy5fd2lkdGg7IGkrPXdpZHRoU3RlcCkge1xuXHRcdFx0Y2FsbGJhY2soaSwgaiwgbmV3TWFwW2ldW2pdKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBHZXQgbmVpZ2hib3IgY291bnQgYXQgW2ksal0gaW4gdGhpcy5fbWFwXG4gKi9cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihjeCwgY3kpIHtcblx0dmFyIHJlc3VsdCA9IDA7XG5cdGZvciAodmFyIGk9MDtpPHRoaXMuX2RpcnMubGVuZ3RoO2krKykge1xuXHRcdHZhciBkaXIgPSB0aGlzLl9kaXJzW2ldO1xuXHRcdHZhciB4ID0gY3ggKyBkaXJbMF07XG5cdFx0dmFyIHkgPSBjeSArIGRpclsxXTtcblx0XHRcblx0XHRpZiAoeCA8IDAgfHwgeCA+PSB0aGlzLl93aWR0aCB8fCB4IDwgMCB8fCB5ID49IHRoaXMuX3dpZHRoKSB7IGNvbnRpbnVlOyB9XG5cdFx0cmVzdWx0ICs9ICh0aGlzLl9tYXBbeF1beV0gPT0gMSA/IDEgOiAwKTtcblx0fVxuXHRcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgZXZlcnkgbm9uLXdhbGwgc3BhY2UgaXMgYWNjZXNzaWJsZS5cbiAqL1xuUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX2NvbXBsZXRlTWF6ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYWxsRnJlZVNwYWNlID0gW107XG5cdHZhciBub3RDb25uZWN0ZWQgPSB7fTtcblx0Ly8gZmluZCBhbGwgZnJlZSBzcGFjZVxuXHRmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuX3dpZHRoOyB4KyspIHtcblx0XHRmb3IgKHZhciB5ID0gMDsgeSA8IHRoaXMuX2hlaWdodDsgeSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fZnJlZVNwYWNlKHgsIHkpKSB7XG5cdFx0XHRcdHZhciBwID0gW3gsIHldO1xuXHRcdFx0XHRub3RDb25uZWN0ZWRbdGhpcy5fcG9pbnRLZXkocCldID0gcDtcblx0XHRcdFx0YWxsRnJlZVNwYWNlLnB1c2goW3gsIHldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dmFyIHN0YXJ0ID0gYWxsRnJlZVNwYWNlW1JPVC5STkcuZ2V0VW5pZm9ybUludCgwLCBhbGxGcmVlU3BhY2UubGVuZ3RoIC0gMSldO1xuXG5cdHZhciBrZXkgPSB0aGlzLl9wb2ludEtleShzdGFydCk7XG5cdHZhciBjb25uZWN0ZWQgPSB7fTtcblx0Y29ubmVjdGVkW2tleV0gPSBzdGFydDtcblx0ZGVsZXRlIG5vdENvbm5lY3RlZFtrZXldXG5cblx0Ly8gZmluZCB3aGF0J3MgY29ubmVjdGVkIHRvIHRoZSBzdGFydGluZyBwb2ludFxuXHR0aGlzLl9maW5kQ29ubmVjdGVkKGNvbm5lY3RlZCwgbm90Q29ubmVjdGVkLCBbc3RhcnRdKTtcblxuXHR3aGlsZSAoT2JqZWN0LmtleXMobm90Q29ubmVjdGVkKS5sZW5ndGggPiAwKSB7XG5cblx0XHQvLyBmaW5kIHR3byBwb2ludHMgZnJvbSBub3RDb25uZWN0ZWQgdG8gY29ubmVjdGVkXG5cdFx0dmFyIHAgPSB0aGlzLl9nZXRGcm9tVG8oY29ubmVjdGVkLCBub3RDb25uZWN0ZWQpO1xuXHRcdHZhciBmcm9tID0gcFswXTsgLy8gbm90Q29ubmVjdGVkXG5cdFx0dmFyIHRvID0gcFsxXTsgLy8gY29ubmVjdGVkXG5cblx0XHQvLyBmaW5kIGV2ZXJ5dGhpbmcgY29ubmVjdGVkIHRvIHRoZSBzdGFydGluZyBwb2ludFxuXHRcdHZhciBsb2NhbCA9IHt9O1xuXHRcdGxvY2FsW3RoaXMuX3BvaW50S2V5KGZyb20pXSA9IGZyb207XG5cdFx0dGhpcy5fZmluZENvbm5lY3RlZChsb2NhbCwgbm90Q29ubmVjdGVkLCBbZnJvbV0sIHRydWUpO1xuXG5cdFx0Ly8gY29ubmVjdCB0byBhIGNvbm5lY3RlZCBzcXVhcmVcblx0XHR0aGlzLl90dW5uZWxUb0Nvbm5lY3RlZCh0bywgZnJvbSwgY29ubmVjdGVkLCBub3RDb25uZWN0ZWQpO1xuXG5cdFx0Ly8gbm93IGFsbCBvZiBsb2NhbCBpcyBjb25uZWN0ZWRcblx0XHRmb3IgKHZhciBrIGluIGxvY2FsKSB7XG5cdFx0XHR2YXIgcHAgPSBsb2NhbFtrXTtcblx0XHRcdHRoaXMuX21hcFtwcFswXV1bcHBbMV1dID0gMDtcblx0XHRcdGNvbm5lY3RlZFtrXSA9IHBwO1xuXHRcdFx0ZGVsZXRlIG5vdENvbm5lY3RlZFtrXTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBGaW5kIHJhbmRvbSBwb2ludHMgdG8gY29ubmVjdC4gU2VhcmNoIGZvciB0aGUgY2xvc2VzdCBwb2ludCBpbiB0aGUgbGFyZ2VyIHNwYWNlLiBcbiAqIFRoaXMgaXMgdG8gbWluaW1pemUgdGhlIGxlbmd0aCBvZiB0aGUgcGFzc2FnZSB3aGlsZSBtYWludGFpbmluZyBnb29kIHBlcmZvcm1hbmNlLlxuICovXG5ST1QuTWFwLkNlbGx1bGFyLnByb3RvdHlwZS5fZ2V0RnJvbVRvID0gZnVuY3Rpb24oY29ubmVjdGVkLCBub3RDb25uZWN0ZWQpIHtcblx0dmFyIGZyb20sIHRvLCBkO1xuXHR2YXIgY29ubmVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGNvbm5lY3RlZCk7XG5cdHZhciBub3RDb25uZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMobm90Q29ubmVjdGVkKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcblx0XHRpZiAoY29ubmVjdGVkS2V5cy5sZW5ndGggPCBub3RDb25uZWN0ZWRLZXlzLmxlbmd0aCkge1xuXHRcdFx0dmFyIGtleXMgPSBjb25uZWN0ZWRLZXlzO1xuXHRcdFx0dG8gPSBjb25uZWN0ZWRba2V5c1tST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwga2V5cy5sZW5ndGggLSAxKV1dXG5cdFx0XHRmcm9tID0gdGhpcy5fZ2V0Q2xvc2VzdCh0bywgbm90Q29ubmVjdGVkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGtleXMgPSBub3RDb25uZWN0ZWRLZXlzO1xuXHRcdFx0ZnJvbSA9IG5vdENvbm5lY3RlZFtrZXlzW1JPVC5STkcuZ2V0VW5pZm9ybUludCgwLCBrZXlzLmxlbmd0aCAtIDEpXV1cblx0XHRcdHRvID0gdGhpcy5fZ2V0Q2xvc2VzdChmcm9tLCBjb25uZWN0ZWQpO1xuXHRcdH1cblx0XHRkID0gKGZyb21bMF0gLSB0b1swXSkgKiAoZnJvbVswXSAtIHRvWzBdKSArIChmcm9tWzFdIC0gdG9bMV0pICogKGZyb21bMV0gLSB0b1sxXSk7XG5cdFx0aWYgKGQgPCA2NCkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdC8vIGNvbnNvbGUubG9nKFwiPj4+IGNvbm5lY3RlZD1cIiArIHRvICsgXCIgbm90Q29ubmVjdGVkPVwiICsgZnJvbSArIFwiIGRpc3Q9XCIgKyBkKTtcblx0cmV0dXJuIFtmcm9tLCB0b107XG59XG5cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9nZXRDbG9zZXN0ID0gZnVuY3Rpb24ocG9pbnQsIHNwYWNlKSB7XG5cdHZhciBtaW5Qb2ludCA9IG51bGw7XG5cdHZhciBtaW5EaXN0ID0gbnVsbDtcblx0Zm9yIChrIGluIHNwYWNlKSB7XG5cdFx0dmFyIHAgPSBzcGFjZVtrXTtcblx0XHR2YXIgZCA9IChwWzBdIC0gcG9pbnRbMF0pICogKHBbMF0gLSBwb2ludFswXSkgKyAocFsxXSAtIHBvaW50WzFdKSAqIChwWzFdIC0gcG9pbnRbMV0pO1xuXHRcdGlmIChtaW5EaXN0ID09IG51bGwgfHwgZCA8IG1pbkRpc3QpIHtcblx0XHRcdG1pbkRpc3QgPSBkO1xuXHRcdFx0bWluUG9pbnQgPSBwO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWluUG9pbnQ7XG59XG5cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9maW5kQ29ubmVjdGVkID0gZnVuY3Rpb24oY29ubmVjdGVkLCBub3RDb25uZWN0ZWQsIHN0YWNrLCBrZWVwTm90Q29ubmVjdGVkKSB7XG5cdHdoaWxlKHN0YWNrLmxlbmd0aCA+IDApIHtcblx0XHR2YXIgcCA9IHN0YWNrLnNwbGljZSgwLCAxKVswXTtcblx0XHR2YXIgdGVzdHMgPSBbXG5cdFx0XHRbcFswXSArIDEsIHBbMV1dLFxuXHRcdFx0W3BbMF0gLSAxLCBwWzFdXSxcblx0XHRcdFtwWzBdLCAgICAgcFsxXSArIDFdLFxuXHRcdFx0W3BbMF0sICAgICBwWzFdIC0gMV1cblx0XHRdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0aGlzLl9wb2ludEtleSh0ZXN0c1tpXSk7XG5cdFx0XHRpZiAoY29ubmVjdGVkW2tleV0gPT0gbnVsbCAmJiB0aGlzLl9mcmVlU3BhY2UodGVzdHNbaV1bMF0sIHRlc3RzW2ldWzFdKSkge1xuXHRcdFx0XHRjb25uZWN0ZWRba2V5XSA9IHRlc3RzW2ldO1xuXHRcdFx0XHRpZiAoIWtlZXBOb3RDb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRkZWxldGUgbm90Q29ubmVjdGVkW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhY2sucHVzaCh0ZXN0c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl90dW5uZWxUb0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBjb25uZWN0ZWQsIG5vdENvbm5lY3RlZCkge1xuXHR2YXIga2V5ID0gdGhpcy5fcG9pbnRLZXkoZnJvbSk7XG5cdHZhciBhLCBiO1xuXHRpZiAoZnJvbVswXSA8IHRvWzBdKSB7XG5cdFx0YSA9IGZyb207XG5cdFx0YiA9IHRvO1xuXHR9IGVsc2Uge1xuXHRcdGEgPSB0bztcblx0XHRiID0gZnJvbTtcblx0fVxuXHRmb3IgKHZhciB4eCA9IGFbMF07IHh4IDw9IGJbMF07IHh4KyspIHtcblx0XHR0aGlzLl9tYXBbeHhdW2FbMV1dID0gMDtcblx0XHR2YXIgcCA9IFt4eCwgYVsxXV07XG5cdFx0dmFyIHBrZXkgPSB0aGlzLl9wb2ludEtleShwKTtcblx0XHRjb25uZWN0ZWRbcGtleV0gPSBwO1xuXHRcdGRlbGV0ZSBub3RDb25uZWN0ZWRbcGtleV07XG5cdH1cblxuXHQvLyB4IGlzIG5vdyBmaXhlZFxuXHR2YXIgeCA9IGJbMF07XG5cblx0aWYgKGZyb21bMV0gPCB0b1sxXSkge1xuXHRcdGEgPSBmcm9tO1xuXHRcdGIgPSB0bztcblx0fSBlbHNlIHtcblx0XHRhID0gdG87XG5cdFx0YiA9IGZyb207XG5cdH1cblx0Zm9yICh2YXIgeXkgPSBhWzFdOyB5eSA8IGJbMV07IHl5KyspIHtcblx0XHR0aGlzLl9tYXBbeF1beXldID0gMDtcblx0XHR2YXIgcCA9IFt4LCB5eV07XG5cdFx0dmFyIHBrZXkgPSB0aGlzLl9wb2ludEtleShwKTtcblx0XHRjb25uZWN0ZWRbcGtleV0gPSBwO1xuXHRcdGRlbGV0ZSBub3RDb25uZWN0ZWRbcGtleV07XG5cdH1cbn1cblxuUk9ULk1hcC5DZWxsdWxhci5wcm90b3R5cGUuX2ZyZWVTcGFjZSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0cmV0dXJuIHggPj0gMCAmJiB4IDwgdGhpcy5fd2lkdGggJiYgeSA+PSAwICYmIHkgPCB0aGlzLl9oZWlnaHQgJiYgdGhpcy5fbWFwW3hdW3ldICE9IDE7XG59XG5cblJPVC5NYXAuQ2VsbHVsYXIucHJvdG90eXBlLl9wb2ludEtleSA9IGZ1bmN0aW9uKHApIHtcblx0cmV0dXJuIHBbMF0gKyBcIi5cIiArIHBbMV07XG59XG5cbi8qKlxuICogQGNsYXNzIER1bmdlb24gbWFwOiBoYXMgcm9vbXMgYW5kIGNvcnJpZG9yc1xuICogQGF1Z21lbnRzIFJPVC5NYXBcbiAqL1xuUk9ULk1hcC5EdW5nZW9uID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRST1QuTWFwLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG5cdHRoaXMuX3Jvb21zID0gW107IC8qIGxpc3Qgb2YgYWxsIHJvb21zICovXG5cdHRoaXMuX2NvcnJpZG9ycyA9IFtdO1xufVxuUk9ULk1hcC5EdW5nZW9uLmV4dGVuZChST1QuTWFwKTtcblxuLyoqXG4gKiBHZXQgYWxsIGdlbmVyYXRlZCByb29tc1xuICogQHJldHVybnMge1JPVC5NYXAuRmVhdHVyZS5Sb29tW119XG4gKi9cblJPVC5NYXAuRHVuZ2Vvbi5wcm90b3R5cGUuZ2V0Um9vbXMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX3Jvb21zO1xufVxuXG4vKipcbiAqIEdldCBhbGwgZ2VuZXJhdGVkIGNvcnJpZG9yc1xuICogQHJldHVybnMge1JPVC5NYXAuRmVhdHVyZS5Db3JyaWRvcltdfVxuICovXG5ST1QuTWFwLkR1bmdlb24ucHJvdG90eXBlLmdldENvcnJpZG9ycyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5fY29ycmlkb3JzO1xufVxuLyoqXG4gKiBAY2xhc3MgUmFuZG9tIGR1bmdlb24gZ2VuZXJhdG9yIHVzaW5nIGh1bWFuLWxpa2UgZGlnZ2luZyBwYXR0ZXJucy5cbiAqIEhlYXZpbHkgYmFzZWQgb24gTWlrZSBBbmRlcnNvbidzIGlkZWFzIGZyb20gdGhlIFwiVHlyYW50XCIgYWxnbywgbWVudGlvbmVkIGF0IFxuICogaHR0cDovL3d3dy5yb2d1ZWJhc2luLnJvZ3VlbGlrZWRldmVsb3BtZW50Lm9yZy9pbmRleC5waHA/dGl0bGU9RHVuZ2Vvbi1CdWlsZGluZ19BbGdvcml0aG0uXG4gKiBAYXVnbWVudHMgUk9ULk1hcC5EdW5nZW9uXG4gKi9cblJPVC5NYXAuRGlnZ2VyID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuXHRST1QuTWFwLkR1bmdlb24uY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcblx0XG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0cm9vbVdpZHRoOiBbMywgOV0sIC8qIHJvb20gbWluaW11bSBhbmQgbWF4aW11bSB3aWR0aCAqL1xuXHRcdHJvb21IZWlnaHQ6IFszLCA1XSwgLyogcm9vbSBtaW5pbXVtIGFuZCBtYXhpbXVtIGhlaWdodCAqL1xuXHRcdGNvcnJpZG9yTGVuZ3RoOiBbMywgMTBdLCAvKiBjb3JyaWRvciBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCAqL1xuXHRcdGR1Z1BlcmNlbnRhZ2U6IDAuMiwgLyogd2Ugc3RvcCBhZnRlciB0aGlzIHBlcmNlbnRhZ2Ugb2YgbGV2ZWwgYXJlYSBoYXMgYmVlbiBkdWcgb3V0ICovXG5cdFx0dGltZUxpbWl0OiAxMDAwIC8qIHdlIHN0b3AgYWZ0ZXIgdGhpcyBtdWNoIHRpbWUgaGFzIHBhc3NlZCAobXNlYykgKi9cblx0fVxuXHRmb3IgKHZhciBwIGluIG9wdGlvbnMpIHsgdGhpcy5fb3B0aW9uc1twXSA9IG9wdGlvbnNbcF07IH1cblx0XG5cdHRoaXMuX2ZlYXR1cmVzID0ge1xuXHRcdFwiUm9vbVwiOiA0LFxuXHRcdFwiQ29ycmlkb3JcIjogNFxuXHR9XG5cdHRoaXMuX2ZlYXR1cmVBdHRlbXB0cyA9IDIwOyAvKiBob3cgbWFueSB0aW1lcyBkbyB3ZSB0cnkgdG8gY3JlYXRlIGEgZmVhdHVyZSBvbiBhIHN1aXRhYmxlIHdhbGwgKi9cblx0dGhpcy5fd2FsbHMgPSB7fTsgLyogdGhlc2UgYXJlIGF2YWlsYWJsZSBmb3IgZGlnZ2luZyAqL1xuXHRcblx0dGhpcy5fZGlnQ2FsbGJhY2sgPSB0aGlzLl9kaWdDYWxsYmFjay5iaW5kKHRoaXMpO1xuXHR0aGlzLl9jYW5CZUR1Z0NhbGxiYWNrID0gdGhpcy5fY2FuQmVEdWdDYWxsYmFjay5iaW5kKHRoaXMpO1xuXHR0aGlzLl9pc1dhbGxDYWxsYmFjayA9IHRoaXMuX2lzV2FsbENhbGxiYWNrLmJpbmQodGhpcyk7XG5cdHRoaXMuX3ByaW9yaXR5V2FsbENhbGxiYWNrID0gdGhpcy5fcHJpb3JpdHlXYWxsQ2FsbGJhY2suYmluZCh0aGlzKTtcbn1cblJPVC5NYXAuRGlnZ2VyLmV4dGVuZChST1QuTWFwLkR1bmdlb24pO1xuXG4vKipcbiAqIENyZWF0ZSBhIG1hcFxuICogQHNlZSBST1QuTWFwI2NyZWF0ZVxuICovXG5ST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dGhpcy5fcm9vbXMgPSBbXTtcblx0dGhpcy5fY29ycmlkb3JzID0gW107XG5cdHRoaXMuX21hcCA9IHRoaXMuX2ZpbGxNYXAoMSk7XG5cdHRoaXMuX3dhbGxzID0ge307XG5cdHRoaXMuX2R1ZyA9IDA7XG5cdHZhciBhcmVhID0gKHRoaXMuX3dpZHRoLTIpICogKHRoaXMuX2hlaWdodC0yKTtcblxuXHR0aGlzLl9maXJzdFJvb20oKTtcblx0XG5cdHZhciB0MSA9IERhdGUubm93KCk7XG5cblx0ZG8ge1xuXHRcdHZhciB0MiA9IERhdGUubm93KCk7XG5cdFx0aWYgKHQyIC0gdDEgPiB0aGlzLl9vcHRpb25zLnRpbWVMaW1pdCkgeyBicmVhazsgfVxuXG5cdFx0LyogZmluZCBhIGdvb2Qgd2FsbCAqL1xuXHRcdHZhciB3YWxsID0gdGhpcy5fZmluZFdhbGwoKTtcblx0XHRpZiAoIXdhbGwpIHsgYnJlYWs7IH0gLyogbm8gbW9yZSB3YWxscyAqL1xuXHRcdFxuXHRcdHZhciBwYXJ0cyA9IHdhbGwuc3BsaXQoXCIsXCIpO1xuXHRcdHZhciB4ID0gcGFyc2VJbnQocGFydHNbMF0pO1xuXHRcdHZhciB5ID0gcGFyc2VJbnQocGFydHNbMV0pO1xuXHRcdHZhciBkaXIgPSB0aGlzLl9nZXREaWdnaW5nRGlyZWN0aW9uKHgsIHkpO1xuXHRcdGlmICghZGlyKSB7IGNvbnRpbnVlOyB9IC8qIHRoaXMgd2FsbCBpcyBub3Qgc3VpdGFibGUgKi9cblx0XHRcbi8vXHRcdGNvbnNvbGUubG9nKFwid2FsbFwiLCB4LCB5KTtcblxuXHRcdC8qIHRyeSBhZGRpbmcgYSBmZWF0dXJlICovXG5cdFx0dmFyIGZlYXR1cmVBdHRlbXB0cyA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0ZmVhdHVyZUF0dGVtcHRzKys7XG5cdFx0XHRpZiAodGhpcy5fdHJ5RmVhdHVyZSh4LCB5LCBkaXJbMF0sIGRpclsxXSkpIHsgLyogZmVhdHVyZSBhZGRlZCAqL1xuXHRcdFx0XHQvL2lmICh0aGlzLl9yb29tcy5sZW5ndGggKyB0aGlzLl9jb3JyaWRvcnMubGVuZ3RoID09IDIpIHsgdGhpcy5fcm9vbXNbMF0uYWRkRG9vcih4LCB5KTsgfSAvKiBmaXJzdCByb29tIG9maWNpYWxseSBoYXMgZG9vcnMgKi9cblx0XHRcdFx0dGhpcy5fcmVtb3ZlU3Vycm91bmRpbmdXYWxscyh4LCB5KTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlU3Vycm91bmRpbmdXYWxscyh4LWRpclswXSwgeS1kaXJbMV0pO1xuXHRcdFx0XHRicmVhazsgXG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoZmVhdHVyZUF0dGVtcHRzIDwgdGhpcy5fZmVhdHVyZUF0dGVtcHRzKTtcblx0XHRcblx0XHR2YXIgcHJpb3JpdHlXYWxscyA9IDA7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fd2FsbHMpIHsgXG5cdFx0XHRpZiAodGhpcy5fd2FsbHNbaWRdID4gMSkgeyBwcmlvcml0eVdhbGxzKys7IH1cblx0XHR9XG5cblx0fSB3aGlsZSAodGhpcy5fZHVnL2FyZWEgPCB0aGlzLl9vcHRpb25zLmR1Z1BlcmNlbnRhZ2UgfHwgcHJpb3JpdHlXYWxscyk7IC8qIGZpeG1lIG51bWJlciBvZiBwcmlvcml0eSB3YWxscyAqL1xuXG5cdHRoaXMuX2FkZERvb3JzKCk7XG5cblx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fd2lkdGg7aSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqPTA7ajx0aGlzLl9oZWlnaHQ7aisrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGksIGosIHRoaXMuX21hcFtpXVtqXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHR0aGlzLl93YWxscyA9IHt9O1xuXHR0aGlzLl9tYXAgPSBudWxsO1xuXG5cdHJldHVybiB0aGlzO1xufVxuXG5ST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2RpZ0NhbGxiYWNrID0gZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlID09IDAgfHwgdmFsdWUgPT0gMikgeyAvKiBlbXB0eSAqL1xuXHRcdHRoaXMuX21hcFt4XVt5XSA9IDA7XG5cdFx0dGhpcy5fZHVnKys7XG5cdH0gZWxzZSB7IC8qIHdhbGwgKi9cblx0XHR0aGlzLl93YWxsc1t4K1wiLFwiK3ldID0gMTtcblx0fVxufVxuXG5ST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2lzV2FsbENhbGxiYWNrID0gZnVuY3Rpb24oeCwgeSkge1xuXHRpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+PSB0aGlzLl93aWR0aCB8fCB5ID49IHRoaXMuX2hlaWdodCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuICh0aGlzLl9tYXBbeF1beV0gPT0gMSk7XG59XG5cblJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fY2FuQmVEdWdDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0aWYgKHggPCAxIHx8IHkgPCAxIHx8IHgrMSA+PSB0aGlzLl93aWR0aCB8fCB5KzEgPj0gdGhpcy5faGVpZ2h0KSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gKHRoaXMuX21hcFt4XVt5XSA9PSAxKTtcbn1cblxuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9wcmlvcml0eVdhbGxDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0dGhpcy5fd2FsbHNbeCtcIixcIit5XSA9IDI7XG59XG5cblJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fZmlyc3RSb29tID0gZnVuY3Rpb24oKSB7XG5cdHZhciBjeCA9IE1hdGguZmxvb3IodGhpcy5fd2lkdGgvMik7XG5cdHZhciBjeSA9IE1hdGguZmxvb3IodGhpcy5faGVpZ2h0LzIpO1xuXHR2YXIgcm9vbSA9IFJPVC5NYXAuRmVhdHVyZS5Sb29tLmNyZWF0ZVJhbmRvbUNlbnRlcihjeCwgY3ksIHRoaXMuX29wdGlvbnMpO1xuXHR0aGlzLl9yb29tcy5wdXNoKHJvb20pO1xuXHRyb29tLmNyZWF0ZSh0aGlzLl9kaWdDYWxsYmFjayk7XG59XG5cbi8qKlxuICogR2V0IGEgc3VpdGFibGUgd2FsbFxuICovXG5ST1QuTWFwLkRpZ2dlci5wcm90b3R5cGUuX2ZpbmRXYWxsID0gZnVuY3Rpb24oKSB7XG5cdHZhciBwcmlvMSA9IFtdO1xuXHR2YXIgcHJpbzIgPSBbXTtcblx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fd2FsbHMpIHtcblx0XHR2YXIgcHJpbyA9IHRoaXMuX3dhbGxzW2lkXTtcblx0XHRpZiAocHJpbyA9PSAyKSB7IFxuXHRcdFx0cHJpbzIucHVzaChpZCk7IFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmlvMS5wdXNoKGlkKTtcblx0XHR9XG5cdH1cblx0XG5cdHZhciBhcnIgPSAocHJpbzIubGVuZ3RoID8gcHJpbzIgOiBwcmlvMSk7XG5cdGlmICghYXJyLmxlbmd0aCkgeyByZXR1cm4gbnVsbDsgfSAvKiBubyB3YWxscyA6LyAqL1xuXHRcblx0dmFyIGlkID0gYXJyLnJhbmRvbSgpO1xuXHRkZWxldGUgdGhpcy5fd2FsbHNbaWRdO1xuXG5cdHJldHVybiBpZDtcbn1cblxuLyoqXG4gKiBUcmllcyBhZGRpbmcgYSBmZWF0dXJlXG4gKiBAcmV0dXJucyB7Ym9vbH0gd2FzIHRoaXMgYSBzdWNjZXNzZnVsIHRyeT9cbiAqL1xuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl90cnlGZWF0dXJlID0gZnVuY3Rpb24oeCwgeSwgZHgsIGR5KSB7XG5cdHZhciBmZWF0dXJlID0gUk9ULlJORy5nZXRXZWlnaHRlZFZhbHVlKHRoaXMuX2ZlYXR1cmVzKTtcblx0ZmVhdHVyZSA9IFJPVC5NYXAuRmVhdHVyZVtmZWF0dXJlXS5jcmVhdGVSYW5kb21BdCh4LCB5LCBkeCwgZHksIHRoaXMuX29wdGlvbnMpO1xuXHRcblx0aWYgKCFmZWF0dXJlLmlzVmFsaWQodGhpcy5faXNXYWxsQ2FsbGJhY2ssIHRoaXMuX2NhbkJlRHVnQ2FsbGJhY2spKSB7XG4vL1x0XHRjb25zb2xlLmxvZyhcIm5vdCB2YWxpZFwiKTtcbi8vXHRcdGZlYXR1cmUuZGVidWcoKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdGZlYXR1cmUuY3JlYXRlKHRoaXMuX2RpZ0NhbGxiYWNrKTtcbi8vXHRmZWF0dXJlLmRlYnVnKCk7XG5cblx0aWYgKGZlYXR1cmUgaW5zdGFuY2VvZiBST1QuTWFwLkZlYXR1cmUuUm9vbSkgeyB0aGlzLl9yb29tcy5wdXNoKGZlYXR1cmUpOyB9XG5cdGlmIChmZWF0dXJlIGluc3RhbmNlb2YgUk9ULk1hcC5GZWF0dXJlLkNvcnJpZG9yKSB7IFxuXHRcdGZlYXR1cmUuY3JlYXRlUHJpb3JpdHlXYWxscyh0aGlzLl9wcmlvcml0eVdhbGxDYWxsYmFjayk7XG5cdFx0dGhpcy5fY29ycmlkb3JzLnB1c2goZmVhdHVyZSk7IFxuXHR9XG5cdFxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9yZW1vdmVTdXJyb3VuZGluZ1dhbGxzID0gZnVuY3Rpb24oY3gsIGN5KSB7XG5cdHZhciBkZWx0YXMgPSBST1QuRElSU1s0XTtcblxuXHRmb3IgKHZhciBpPTA7aTxkZWx0YXMubGVuZ3RoO2krKykge1xuXHRcdHZhciBkZWx0YSA9IGRlbHRhc1tpXTtcblx0XHR2YXIgeCA9IGN4ICsgZGVsdGFbMF07XG5cdFx0dmFyIHkgPSBjeSArIGRlbHRhWzFdO1xuXHRcdGRlbGV0ZSB0aGlzLl93YWxsc1t4K1wiLFwiK3ldO1xuXHRcdHZhciB4ID0gY3ggKyAyKmRlbHRhWzBdO1xuXHRcdHZhciB5ID0gY3kgKyAyKmRlbHRhWzFdO1xuXHRcdGRlbGV0ZSB0aGlzLl93YWxsc1t4K1wiLFwiK3ldO1xuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyB2ZWN0b3IgaW4gXCJkaWdnaW5nXCIgZGlyZWN0aW9uLCBvciBmYWxzZSwgaWYgdGhpcyBkb2VzIG5vdCBleGlzdCAob3IgaXMgbm90IHVuaXF1ZSlcbiAqL1xuUk9ULk1hcC5EaWdnZXIucHJvdG90eXBlLl9nZXREaWdnaW5nRGlyZWN0aW9uID0gZnVuY3Rpb24oY3gsIGN5KSB7XG5cdGlmIChjeCA8PSAwIHx8IGN5IDw9IDAgfHwgY3ggPj0gdGhpcy5fd2lkdGggLSAxIHx8IGN5ID49IHRoaXMuX2hlaWdodCAtIDEpIHsgcmV0dXJuIG51bGw7IH1cblxuXHR2YXIgcmVzdWx0ID0gbnVsbDtcblx0dmFyIGRlbHRhcyA9IFJPVC5ESVJTWzRdO1xuXHRcblx0Zm9yICh2YXIgaT0wO2k8ZGVsdGFzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG5cdFx0dmFyIHggPSBjeCArIGRlbHRhWzBdO1xuXHRcdHZhciB5ID0gY3kgKyBkZWx0YVsxXTtcblx0XHRcblx0XHRpZiAoIXRoaXMuX21hcFt4XVt5XSkgeyAvKiB0aGVyZSBhbHJlYWR5IGlzIGFub3RoZXIgZW1wdHkgbmVpZ2hib3IhICovXG5cdFx0XHRpZiAocmVzdWx0KSB7IHJldHVybiBudWxsOyB9XG5cdFx0XHRyZXN1bHQgPSBkZWx0YTtcblx0XHR9XG5cdH1cblx0XG5cdC8qIG5vIGVtcHR5IG5laWdoYm9yICovXG5cdGlmICghcmVzdWx0KSB7IHJldHVybiBudWxsOyB9XG5cdFxuXHRyZXR1cm4gWy1yZXN1bHRbMF0sIC1yZXN1bHRbMV1dO1xufVxuXG4vKipcbiAqIEZpbmQgZW1wdHkgc3BhY2VzIHN1cnJvdW5kaW5nIHJvb21zLCBhbmQgYXBwbHkgZG9vcnMuXG4gKi9cblJPVC5NYXAuRGlnZ2VyLnByb3RvdHlwZS5fYWRkRG9vcnMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGRhdGEgPSB0aGlzLl9tYXA7XG5cdHZhciBpc1dhbGxDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRyZXR1cm4gKGRhdGFbeF1beV0gPT0gMSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb29tcy5sZW5ndGg7IGkrKyApIHtcblx0XHR2YXIgcm9vbSA9IHRoaXMuX3Jvb21zW2ldO1xuXHRcdHJvb20uY2xlYXJEb29ycygpO1xuXHRcdHJvb20uYWRkRG9vcnMoaXNXYWxsQ2FsbGJhY2spO1xuXHR9XG59XG4vKipcbiAqIEBjbGFzcyBEdW5nZW9uIGdlbmVyYXRvciB3aGljaCB0cmllcyB0byBmaWxsIHRoZSBzcGFjZSBldmVubHkuIEdlbmVyYXRlcyBpbmRlcGVuZGVudCByb29tcyBhbmQgdHJpZXMgdG8gY29ubmVjdCB0aGVtLlxuICogQGF1Z21lbnRzIFJPVC5NYXAuRHVuZ2VvblxuICovXG5ST1QuTWFwLlVuaWZvcm0gPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cdFJPVC5NYXAuRHVuZ2Vvbi5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuXG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0cm9vbVdpZHRoOiBbMywgOV0sIC8qIHJvb20gbWluaW11bSBhbmQgbWF4aW11bSB3aWR0aCAqL1xuXHRcdHJvb21IZWlnaHQ6IFszLCA1XSwgLyogcm9vbSBtaW5pbXVtIGFuZCBtYXhpbXVtIGhlaWdodCAqL1xuXHRcdHJvb21EdWdQZXJjZW50YWdlOiAwLjEsIC8qIHdlIHN0b3AgYWZ0ZXIgdGhpcyBwZXJjZW50YWdlIG9mIGxldmVsIGFyZWEgaGFzIGJlZW4gZHVnIG91dCBieSByb29tcyAqL1xuXHRcdHRpbWVMaW1pdDogMTAwMCAvKiB3ZSBzdG9wIGFmdGVyIHRoaXMgbXVjaCB0aW1lIGhhcyBwYXNzZWQgKG1zZWMpICovXG5cdH1cblx0Zm9yICh2YXIgcCBpbiBvcHRpb25zKSB7IHRoaXMuX29wdGlvbnNbcF0gPSBvcHRpb25zW3BdOyB9XG5cblx0dGhpcy5fcm9vbUF0dGVtcHRzID0gMjA7IC8qIG5ldyByb29tIGlzIGNyZWF0ZWQgTi10aW1lcyB1bnRpbCBpcyBjb25zaWRlcmVkIGFzIGltcG9zc2libGUgdG8gZ2VuZXJhdGUgKi9cblx0dGhpcy5fY29ycmlkb3JBdHRlbXB0cyA9IDIwOyAvKiBjb3JyaWRvcnMgYXJlIHRyaWVkIE4tdGltZXMgdW50aWwgdGhlIGxldmVsIGlzIGNvbnNpZGVyZWQgYXMgaW1wb3NzaWJsZSB0byBjb25uZWN0ICovXG5cblx0dGhpcy5fY29ubmVjdGVkID0gW107IC8qIGxpc3Qgb2YgYWxyZWFkeSBjb25uZWN0ZWQgcm9vbXMgKi9cblx0dGhpcy5fdW5jb25uZWN0ZWQgPSBbXTsgLyogbGlzdCBvZiByZW1haW5pbmcgdW5jb25uZWN0ZWQgcm9vbXMgKi9cblx0XG5cdHRoaXMuX2RpZ0NhbGxiYWNrID0gdGhpcy5fZGlnQ2FsbGJhY2suYmluZCh0aGlzKTtcblx0dGhpcy5fY2FuQmVEdWdDYWxsYmFjayA9IHRoaXMuX2NhbkJlRHVnQ2FsbGJhY2suYmluZCh0aGlzKTtcblx0dGhpcy5faXNXYWxsQ2FsbGJhY2sgPSB0aGlzLl9pc1dhbGxDYWxsYmFjay5iaW5kKHRoaXMpO1xufVxuUk9ULk1hcC5Vbmlmb3JtLmV4dGVuZChST1QuTWFwLkR1bmdlb24pO1xuXG4vKipcbiAqIENyZWF0ZSBhIG1hcC4gSWYgdGhlIHRpbWUgbGltaXQgaGFzIGJlZW4gaGl0LCByZXR1cm5zIG51bGwuXG4gKiBAc2VlIFJPVC5NYXAjY3JlYXRlXG4gKi9cblJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dmFyIHQxID0gRGF0ZS5ub3coKTtcblx0d2hpbGUgKDEpIHtcblx0XHR2YXIgdDIgPSBEYXRlLm5vdygpO1xuXHRcdGlmICh0MiAtIHQxID4gdGhpcy5fb3B0aW9ucy50aW1lTGltaXQpIHsgcmV0dXJuIG51bGw7IH0gLyogdGltZSBsaW1pdCEgKi9cblx0XG5cdFx0dGhpcy5fbWFwID0gdGhpcy5fZmlsbE1hcCgxKTtcblx0XHR0aGlzLl9kdWcgPSAwO1xuXHRcdHRoaXMuX3Jvb21zID0gW107XG5cdFx0dGhpcy5fdW5jb25uZWN0ZWQgPSBbXTtcblx0XHR0aGlzLl9nZW5lcmF0ZVJvb21zKCk7XG5cdFx0aWYgKHRoaXMuX3Jvb21zLmxlbmd0aCA8IDIpIHsgY29udGludWU7IH1cblx0XHRpZiAodGhpcy5fZ2VuZXJhdGVDb3JyaWRvcnMoKSkgeyBicmVhazsgfVxuXHR9XG5cdFxuXHRpZiAoY2FsbGJhY2spIHtcblx0XHRmb3IgKHZhciBpPTA7aTx0aGlzLl93aWR0aDtpKyspIHtcblx0XHRcdGZvciAodmFyIGo9MDtqPHRoaXMuX2hlaWdodDtqKyspIHtcblx0XHRcdFx0Y2FsbGJhY2soaSwgaiwgdGhpcy5fbWFwW2ldW2pdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHN1aXRhYmxlIGFtb3VudCBvZiByb29tc1xuICovXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9nZW5lcmF0ZVJvb21zID0gZnVuY3Rpb24oKSB7XG5cdHZhciB3ID0gdGhpcy5fd2lkdGgtMjtcblx0dmFyIGggPSB0aGlzLl9oZWlnaHQtMjtcblxuXHRkbyB7XG5cdFx0dmFyIHJvb20gPSB0aGlzLl9nZW5lcmF0ZVJvb20oKTtcblx0XHRpZiAodGhpcy5fZHVnLyh3KmgpID4gdGhpcy5fb3B0aW9ucy5yb29tRHVnUGVyY2VudGFnZSkgeyBicmVhazsgfSAvKiBhY2hpZXZlZCByZXF1ZXN0ZWQgYW1vdW50IG9mIGZyZWUgc3BhY2UgKi9cblx0fSB3aGlsZSAocm9vbSk7XG5cblx0LyogZWl0aGVyIGVub3VnaCByb29tcywgb3Igbm90IGFibGUgdG8gZ2VuZXJhdGUgbW9yZSBvZiB0aGVtIDopICovXG59XG5cbi8qKlxuICogVHJ5IHRvIGdlbmVyYXRlIG9uZSByb29tXG4gKi9cblJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2dlbmVyYXRlUm9vbSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY291bnQgPSAwO1xuXHR3aGlsZSAoY291bnQgPCB0aGlzLl9yb29tQXR0ZW1wdHMpIHtcblx0XHRjb3VudCsrO1xuXHRcdFxuXHRcdHZhciByb29tID0gUk9ULk1hcC5GZWF0dXJlLlJvb20uY3JlYXRlUmFuZG9tKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHRoaXMuX29wdGlvbnMpO1xuXHRcdGlmICghcm9vbS5pc1ZhbGlkKHRoaXMuX2lzV2FsbENhbGxiYWNrLCB0aGlzLl9jYW5CZUR1Z0NhbGxiYWNrKSkgeyBjb250aW51ZTsgfVxuXHRcdFxuXHRcdHJvb20uY3JlYXRlKHRoaXMuX2RpZ0NhbGxiYWNrKTtcblx0XHR0aGlzLl9yb29tcy5wdXNoKHJvb20pO1xuXHRcdHJldHVybiByb29tO1xuXHR9IFxuXG5cdC8qIG5vIHJvb20gd2FzIGdlbmVyYXRlZCBpbiBhIGdpdmVuIG51bWJlciBvZiBhdHRlbXB0cyAqL1xuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgY29ubmVjdG9ycyBiZXdlZW4gcm9vbXNcbiAqIEByZXR1cm5zIHtib29sfSBzdWNjZXNzIFdhcyB0aGlzIGF0dGVtcHQgc3VjY2Vzc2Z1bGw/XG4gKi9cblJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2dlbmVyYXRlQ29ycmlkb3JzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBjbnQgPSAwO1xuXHR3aGlsZSAoY250IDwgdGhpcy5fY29ycmlkb3JBdHRlbXB0cykge1xuXHRcdGNudCsrO1xuXHRcdHRoaXMuX2NvcnJpZG9ycyA9IFtdO1xuXG5cdFx0LyogZGlnIHJvb21zIGludG8gYSBjbGVhciBtYXAgKi9cblx0XHR0aGlzLl9tYXAgPSB0aGlzLl9maWxsTWFwKDEpO1xuXHRcdGZvciAodmFyIGk9MDtpPHRoaXMuX3Jvb21zLmxlbmd0aDtpKyspIHsgXG5cdFx0XHR2YXIgcm9vbSA9IHRoaXMuX3Jvb21zW2ldO1xuXHRcdFx0cm9vbS5jbGVhckRvb3JzKCk7XG5cdFx0XHRyb29tLmNyZWF0ZSh0aGlzLl9kaWdDYWxsYmFjayk7IFxuXHRcdH1cblxuXHRcdHRoaXMuX3VuY29ubmVjdGVkID0gdGhpcy5fcm9vbXMuc2xpY2UoKS5yYW5kb21pemUoKTtcblx0XHR0aGlzLl9jb25uZWN0ZWQgPSBbXTtcblx0XHRpZiAodGhpcy5fdW5jb25uZWN0ZWQubGVuZ3RoKSB7IHRoaXMuX2Nvbm5lY3RlZC5wdXNoKHRoaXMuX3VuY29ubmVjdGVkLnBvcCgpKTsgfSAvKiBmaXJzdCBvbmUgaXMgYWx3YXlzIGNvbm5lY3RlZCAqL1xuXHRcdFxuXHRcdHdoaWxlICgxKSB7XG5cdFx0XHQvKiAxLiBwaWNrIHJhbmRvbSBjb25uZWN0ZWQgcm9vbSAqL1xuXHRcdFx0dmFyIGNvbm5lY3RlZCA9IHRoaXMuX2Nvbm5lY3RlZC5yYW5kb20oKTtcblx0XHRcdFxuXHRcdFx0LyogMi4gZmluZCBjbG9zZXN0IHVuY29ubmVjdGVkICovXG5cdFx0XHR2YXIgcm9vbTEgPSB0aGlzLl9jbG9zZXN0Um9vbSh0aGlzLl91bmNvbm5lY3RlZCwgY29ubmVjdGVkKTtcblx0XHRcdFxuXHRcdFx0LyogMy4gY29ubmVjdCBpdCB0byBjbG9zZXN0IGNvbm5lY3RlZCAqL1xuXHRcdFx0dmFyIHJvb20yID0gdGhpcy5fY2xvc2VzdFJvb20odGhpcy5fY29ubmVjdGVkLCByb29tMSk7XG5cdFx0XHRcblx0XHRcdHZhciBvayA9IHRoaXMuX2Nvbm5lY3RSb29tcyhyb29tMSwgcm9vbTIpO1xuXHRcdFx0aWYgKCFvaykgeyBicmVhazsgfSAvKiBzdG9wIGNvbm5lY3RpbmcsIHJlLXNodWZmbGUgKi9cblx0XHRcdFxuXHRcdFx0aWYgKCF0aGlzLl91bmNvbm5lY3RlZC5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH0gLyogZG9uZTsgbm8gcm9vbXMgcmVtYWluICovXG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBGb3IgYSBnaXZlbiByb29tLCBmaW5kIHRoZSBjbG9zZXN0IG9uZSBmcm9tIHRoZSBsaXN0XG4gKi9cblJPVC5NYXAuVW5pZm9ybS5wcm90b3R5cGUuX2Nsb3Nlc3RSb29tID0gZnVuY3Rpb24ocm9vbXMsIHJvb20pIHtcblx0dmFyIGRpc3QgPSBJbmZpbml0eTtcblx0dmFyIGNlbnRlciA9IHJvb20uZ2V0Q2VudGVyKCk7XG5cdHZhciByZXN1bHQgPSBudWxsO1xuXHRcblx0Zm9yICh2YXIgaT0wO2k8cm9vbXMubGVuZ3RoO2krKykge1xuXHRcdHZhciByID0gcm9vbXNbaV07XG5cdFx0dmFyIGMgPSByLmdldENlbnRlcigpO1xuXHRcdHZhciBkeCA9IGNbMF0tY2VudGVyWzBdO1xuXHRcdHZhciBkeSA9IGNbMV0tY2VudGVyWzFdO1xuXHRcdHZhciBkID0gZHgqZHgrZHkqZHk7XG5cdFx0XG5cdFx0aWYgKGQgPCBkaXN0KSB7XG5cdFx0XHRkaXN0ID0gZDtcblx0XHRcdHJlc3VsdCA9IHI7XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9jb25uZWN0Um9vbXMgPSBmdW5jdGlvbihyb29tMSwgcm9vbTIpIHtcblx0Lypcblx0XHRyb29tMS5kZWJ1ZygpO1xuXHRcdHJvb20yLmRlYnVnKCk7XG5cdCovXG5cblx0dmFyIGNlbnRlcjEgPSByb29tMS5nZXRDZW50ZXIoKTtcblx0dmFyIGNlbnRlcjIgPSByb29tMi5nZXRDZW50ZXIoKTtcblxuXHR2YXIgZGlmZlggPSBjZW50ZXIyWzBdIC0gY2VudGVyMVswXTtcblx0dmFyIGRpZmZZID0gY2VudGVyMlsxXSAtIGNlbnRlcjFbMV07XG5cblx0aWYgKE1hdGguYWJzKGRpZmZYKSA8IE1hdGguYWJzKGRpZmZZKSkgeyAvKiBmaXJzdCB0cnkgY29ubmVjdGluZyBub3J0aC1zb3V0aCB3YWxscyAqL1xuXHRcdHZhciBkaXJJbmRleDEgPSAoZGlmZlkgPiAwID8gMiA6IDApO1xuXHRcdHZhciBkaXJJbmRleDIgPSAoZGlySW5kZXgxICsgMikgJSA0O1xuXHRcdHZhciBtaW4gPSByb29tMi5nZXRMZWZ0KCk7XG5cdFx0dmFyIG1heCA9IHJvb20yLmdldFJpZ2h0KCk7XG5cdFx0dmFyIGluZGV4ID0gMDtcblx0fSBlbHNlIHsgLyogZmlyc3QgdHJ5IGNvbm5lY3RpbmcgZWFzdC13ZXN0IHdhbGxzICovXG5cdFx0dmFyIGRpckluZGV4MSA9IChkaWZmWCA+IDAgPyAxIDogMyk7XG5cdFx0dmFyIGRpckluZGV4MiA9IChkaXJJbmRleDEgKyAyKSAlIDQ7XG5cdFx0dmFyIG1pbiA9IHJvb20yLmdldFRvcCgpO1xuXHRcdHZhciBtYXggPSByb29tMi5nZXRCb3R0b20oKTtcblx0XHR2YXIgaW5kZXggPSAxO1xuXHR9XG5cblx0dmFyIHN0YXJ0ID0gdGhpcy5fcGxhY2VJbldhbGwocm9vbTEsIGRpckluZGV4MSk7IC8qIGNvcnJpZG9yIHdpbGwgc3RhcnQgaGVyZSAqL1xuXHRpZiAoIXN0YXJ0KSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChzdGFydFtpbmRleF0gPj0gbWluICYmIHN0YXJ0W2luZGV4XSA8PSBtYXgpIHsgLyogcG9zc2libGUgdG8gY29ubmVjdCB3aXRoIHN0cmFpZ2h0IGxpbmUgKEktbGlrZSkgKi9cblx0XHR2YXIgZW5kID0gc3RhcnQuc2xpY2UoKTtcblx0XHR2YXIgdmFsdWUgPSBudWxsO1xuXHRcdHN3aXRjaCAoZGlySW5kZXgyKSB7XG5cdFx0XHRjYXNlIDA6IHZhbHVlID0gcm9vbTIuZ2V0VG9wKCktMTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHZhbHVlID0gcm9vbTIuZ2V0UmlnaHQoKSsxOyBicmVhaztcblx0XHRcdGNhc2UgMjogdmFsdWUgPSByb29tMi5nZXRCb3R0b20oKSsxOyBicmVhaztcblx0XHRcdGNhc2UgMzogdmFsdWUgPSByb29tMi5nZXRMZWZ0KCktMTsgYnJlYWs7XG5cdFx0fVxuXHRcdGVuZFsoaW5kZXgrMSklMl0gPSB2YWx1ZTtcblx0XHR0aGlzLl9kaWdMaW5lKFtzdGFydCwgZW5kXSk7XG5cdFx0XG5cdH0gZWxzZSBpZiAoc3RhcnRbaW5kZXhdIDwgbWluLTEgfHwgc3RhcnRbaW5kZXhdID4gbWF4KzEpIHsgLyogbmVlZCB0byBzd2l0Y2ggdGFyZ2V0IHdhbGwgKEwtbGlrZSkgKi9cblxuXHRcdHZhciBkaWZmID0gc3RhcnRbaW5kZXhdIC0gY2VudGVyMltpbmRleF07XG5cdFx0c3dpdGNoIChkaXJJbmRleDIpIHtcblx0XHRcdGNhc2UgMDpcblx0XHRcdGNhc2UgMTpcdHZhciByb3RhdGlvbiA9IChkaWZmIDwgMCA/IDMgOiAxKTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRjYXNlIDM6XHR2YXIgcm90YXRpb24gPSAoZGlmZiA8IDAgPyAxIDogMyk7IGJyZWFrO1xuXHRcdH1cblx0XHRkaXJJbmRleDIgPSAoZGlySW5kZXgyICsgcm90YXRpb24pICUgNDtcblx0XHRcblx0XHR2YXIgZW5kID0gdGhpcy5fcGxhY2VJbldhbGwocm9vbTIsIGRpckluZGV4Mik7XG5cdFx0aWYgKCFlbmQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgbWlkID0gWzAsIDBdO1xuXHRcdG1pZFtpbmRleF0gPSBzdGFydFtpbmRleF07XG5cdFx0dmFyIGluZGV4MiA9IChpbmRleCsxKSUyO1xuXHRcdG1pZFtpbmRleDJdID0gZW5kW2luZGV4Ml07XG5cdFx0dGhpcy5fZGlnTGluZShbc3RhcnQsIG1pZCwgZW5kXSk7XG5cdFx0XG5cdH0gZWxzZSB7IC8qIHVzZSBjdXJyZW50IHdhbGwgcGFpciwgYnV0IGFkanVzdCB0aGUgbGluZSBpbiB0aGUgbWlkZGxlIChTLWxpa2UpICovXG5cdFxuXHRcdHZhciBpbmRleDIgPSAoaW5kZXgrMSklMjtcblx0XHR2YXIgZW5kID0gdGhpcy5fcGxhY2VJbldhbGwocm9vbTIsIGRpckluZGV4Mik7XG5cdFx0aWYgKCFlbmQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIG1pZCA9IE1hdGgucm91bmQoKGVuZFtpbmRleDJdICsgc3RhcnRbaW5kZXgyXSkvMik7XG5cblx0XHR2YXIgbWlkMSA9IFswLCAwXTtcblx0XHR2YXIgbWlkMiA9IFswLCAwXTtcblx0XHRtaWQxW2luZGV4XSA9IHN0YXJ0W2luZGV4XTtcblx0XHRtaWQxW2luZGV4Ml0gPSBtaWQ7XG5cdFx0bWlkMltpbmRleF0gPSBlbmRbaW5kZXhdO1xuXHRcdG1pZDJbaW5kZXgyXSA9IG1pZDtcblx0XHR0aGlzLl9kaWdMaW5lKFtzdGFydCwgbWlkMSwgbWlkMiwgZW5kXSk7XG5cdH1cblxuXHRyb29tMS5hZGREb29yKHN0YXJ0WzBdLCBzdGFydFsxXSk7XG5cdHJvb20yLmFkZERvb3IoZW5kWzBdLCBlbmRbMV0pO1xuXHRcblx0dmFyIGluZGV4ID0gdGhpcy5fdW5jb25uZWN0ZWQuaW5kZXhPZihyb29tMSk7XG5cdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdHRoaXMuX3VuY29ubmVjdGVkLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5fY29ubmVjdGVkLnB1c2gocm9vbTEpO1xuXHR9XG5cblx0dmFyIGluZGV4ID0gdGhpcy5fdW5jb25uZWN0ZWQuaW5kZXhPZihyb29tMik7XG5cdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdHRoaXMuX3VuY29ubmVjdGVkLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5fY29ubmVjdGVkLnB1c2gocm9vbTIpO1xuXHR9XG5cdFxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5fcGxhY2VJbldhbGwgPSBmdW5jdGlvbihyb29tLCBkaXJJbmRleCkge1xuXHR2YXIgc3RhcnQgPSBbMCwgMF07XG5cdHZhciBkaXIgPSBbMCwgMF07XG5cdHZhciBsZW5ndGggPSAwO1xuXHRcblx0c3dpdGNoIChkaXJJbmRleCkge1xuXHRcdGNhc2UgMDpcblx0XHRcdGRpciA9IFsxLCAwXTtcblx0XHRcdHN0YXJ0ID0gW3Jvb20uZ2V0TGVmdCgpLCByb29tLmdldFRvcCgpLTFdO1xuXHRcdFx0bGVuZ3RoID0gcm9vbS5nZXRSaWdodCgpLXJvb20uZ2V0TGVmdCgpKzE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0ZGlyID0gWzAsIDFdO1xuXHRcdFx0c3RhcnQgPSBbcm9vbS5nZXRSaWdodCgpKzEsIHJvb20uZ2V0VG9wKCldO1xuXHRcdFx0bGVuZ3RoID0gcm9vbS5nZXRCb3R0b20oKS1yb29tLmdldFRvcCgpKzE7XG5cdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0ZGlyID0gWzEsIDBdO1xuXHRcdFx0c3RhcnQgPSBbcm9vbS5nZXRMZWZ0KCksIHJvb20uZ2V0Qm90dG9tKCkrMV07XG5cdFx0XHRsZW5ndGggPSByb29tLmdldFJpZ2h0KCktcm9vbS5nZXRMZWZ0KCkrMTtcblx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRkaXIgPSBbMCwgMV07XG5cdFx0XHRzdGFydCA9IFtyb29tLmdldExlZnQoKS0xLCByb29tLmdldFRvcCgpXTtcblx0XHRcdGxlbmd0aCA9IHJvb20uZ2V0Qm90dG9tKCktcm9vbS5nZXRUb3AoKSsxO1xuXHRcdGJyZWFrO1xuXHR9XG5cdFxuXHR2YXIgYXZhaWwgPSBbXTtcblx0dmFyIGxhc3RCYWRJbmRleCA9IC0yO1xuXG5cdGZvciAodmFyIGk9MDtpPGxlbmd0aDtpKyspIHtcblx0XHR2YXIgeCA9IHN0YXJ0WzBdICsgaSpkaXJbMF07XG5cdFx0dmFyIHkgPSBzdGFydFsxXSArIGkqZGlyWzFdO1xuXHRcdGF2YWlsLnB1c2gobnVsbCk7XG5cdFx0XG5cdFx0dmFyIGlzV2FsbCA9ICh0aGlzLl9tYXBbeF1beV0gPT0gMSk7XG5cdFx0aWYgKGlzV2FsbCkge1xuXHRcdFx0aWYgKGxhc3RCYWRJbmRleCAhPSBpLTEpIHsgYXZhaWxbaV0gPSBbeCwgeV07IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bGFzdEJhZEluZGV4ID0gaTtcblx0XHRcdGlmIChpKSB7IGF2YWlsW2ktMV0gPSBudWxsOyB9XG5cdFx0fVxuXHR9XG5cdFxuXHRmb3IgKHZhciBpPWF2YWlsLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRpZiAoIWF2YWlsW2ldKSB7IGF2YWlsLnNwbGljZShpLCAxKTsgfVxuXHR9XG5cdHJldHVybiAoYXZhaWwubGVuZ3RoID8gYXZhaWwucmFuZG9tKCkgOiBudWxsKTtcbn1cblxuLyoqXG4gKiBEaWcgYSBwb2x5bGluZS5cbiAqL1xuUk9ULk1hcC5Vbmlmb3JtLnByb3RvdHlwZS5fZGlnTGluZSA9IGZ1bmN0aW9uKHBvaW50cykge1xuXHRmb3IgKHZhciBpPTE7aTxwb2ludHMubGVuZ3RoO2krKykge1xuXHRcdHZhciBzdGFydCA9IHBvaW50c1tpLTFdO1xuXHRcdHZhciBlbmQgPSBwb2ludHNbaV07XG5cdFx0dmFyIGNvcnJpZG9yID0gbmV3IFJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvcihzdGFydFswXSwgc3RhcnRbMV0sIGVuZFswXSwgZW5kWzFdKTtcblx0XHRjb3JyaWRvci5jcmVhdGUodGhpcy5fZGlnQ2FsbGJhY2spO1xuXHRcdHRoaXMuX2NvcnJpZG9ycy5wdXNoKGNvcnJpZG9yKTtcblx0fVxufVxuXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9kaWdDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG5cdHRoaXMuX21hcFt4XVt5XSA9IHZhbHVlO1xuXHRpZiAodmFsdWUgPT0gMCkgeyB0aGlzLl9kdWcrKzsgfVxufVxuXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9pc1dhbGxDYWxsYmFjayA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0aWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5fd2lkdGggfHwgeSA+PSB0aGlzLl9oZWlnaHQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiAodGhpcy5fbWFwW3hdW3ldID09IDEpO1xufVxuXG5ST1QuTWFwLlVuaWZvcm0ucHJvdG90eXBlLl9jYW5CZUR1Z0NhbGxiYWNrID0gZnVuY3Rpb24oeCwgeSkge1xuXHRpZiAoeCA8IDEgfHwgeSA8IDEgfHwgeCsxID49IHRoaXMuX3dpZHRoIHx8IHkrMSA+PSB0aGlzLl9oZWlnaHQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiAodGhpcy5fbWFwW3hdW3ldID09IDEpO1xufVxuXG4vKipcbiAqIEBhdXRob3IgaHlha3VnZWlcbiAqIEBjbGFzcyBEdW5nZW9uIGdlbmVyYXRvciB3aGljaCB1c2VzIHRoZSBcIm9yZ2luYWxcIiBSb2d1ZSBkdW5nZW9uIGdlbmVyYXRpb24gYWxnb3JpdGhtLiBTZWUgaHR0cDovL2t1b2kuY29tL35rYW1pa2F6ZS9HYW1lRGVzaWduL2FydDA3X3JvZ3VlX2R1bmdlb24ucGhwXG4gKiBAYXVnbWVudHMgUk9ULk1hcFxuICogQHBhcmFtIHtpbnR9IFt3aWR0aD1ST1QuREVGQVVMVF9XSURUSF1cbiAqIEBwYXJhbSB7aW50fSBbaGVpZ2h0PVJPVC5ERUZBVUxUX0hFSUdIVF1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuY2VsbFdpZHRoPTNdIE51bWJlciBvZiBjZWxscyB0byBjcmVhdGUgb24gdGhlIGhvcml6b250YWwgKG51bWJlciBvZiByb29tcyBob3Jpem9udGFsbHkpXG4gKiBAcGFyYW0ge2ludFtdfSBbb3B0aW9ucy5jZWxsSGVpZ2h0PTNdIE51bWJlciBvZiBjZWxscyB0byBjcmVhdGUgb24gdGhlIHZlcnRpY2FsIChudW1iZXIgb2Ygcm9vbXMgdmVydGljYWxseSkgXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMucm9vbVdpZHRoXSBSb29tIG1pbiBhbmQgbWF4IHdpZHRoIC0gbm9ybWFsbHkgc2V0IGF1dG8tbWFnaWNhbGx5IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMucm9vbUhlaWdodF0gUm9vbSBtaW4gYW5kIG1heCBoZWlnaHQgLSBub3JtYWxseSBzZXQgYXV0by1tYWdpY2FsbHkgdmlhIHRoZSBjb25zdHJ1Y3Rvci4gXG4gKi9cblJPVC5NYXAuUm9ndWUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cdFJPVC5NYXAuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcblx0XG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0Y2VsbFdpZHRoOiAzLCAgLy8gTk9URSB0byBzZWxmLCB0aGVzZSBjb3VsZCBwcm9iYWJseSB3b3JrIHRoZSBzYW1lIGFzIHRoZSByb29tV2lkdGgvcm9vbSBIZWlnaHQgdmFsdWVzXG5cdFx0Y2VsbEhlaWdodDogMyAgLy8gICAgIGllLiBhcyBhbiBhcnJheSB3aXRoIG1pbi1tYXggdmFsdWVzIGZvciBlYWNoIGRpcmVjdGlvbi4uLi5cblx0fVxuXHRcblx0Zm9yICh2YXIgcCBpbiBvcHRpb25zKSB7IHRoaXMuX29wdGlvbnNbcF0gPSBvcHRpb25zW3BdOyB9XG5cdFxuXHQvKlxuXHRTZXQgdGhlIHJvb20gc2l6ZXMgYWNjb3JkaW5nIHRvIHRoZSBvdmVyLWFsbCB3aWR0aCBvZiB0aGUgbWFwLCBcblx0YW5kIHRoZSBjZWxsIHNpemVzLiBcblx0Ki9cblx0XG5cdGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInJvb21XaWR0aFwiKSkge1xuXHRcdHRoaXMuX29wdGlvbnNbXCJyb29tV2lkdGhcIl0gPSB0aGlzLl9jYWxjdWxhdGVSb29tU2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5fb3B0aW9uc1tcImNlbGxXaWR0aFwiXSk7XG5cdH1cblx0aWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KFwicm9vbUhlaWdodFwiKSkge1xuXHRcdHRoaXMuX29wdGlvbnNbXCJyb29tSGVpZ2h0XCJdID0gdGhpcy5fY2FsY3VsYXRlUm9vbVNpemUodGhpcy5faGVpZ2h0LCB0aGlzLl9vcHRpb25zW1wiY2VsbEhlaWdodFwiXSk7XG5cdH1cblx0XG59XG5cblJPVC5NYXAuUm9ndWUuZXh0ZW5kKFJPVC5NYXApOyBcblxuLyoqXG4gKiBAc2VlIFJPVC5NYXAjY3JlYXRlXG4gKi9cblJPVC5NYXAuUm9ndWUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHRoaXMubWFwID0gdGhpcy5fZmlsbE1hcCgxKTtcblx0dGhpcy5yb29tcyA9IFtdO1xuXHR0aGlzLmNvbm5lY3RlZENlbGxzID0gW107XG5cdFxuXHR0aGlzLl9pbml0Um9vbXMoKTtcblx0dGhpcy5fY29ubmVjdFJvb21zKCk7XG5cdHRoaXMuX2Nvbm5lY3RVbmNvbm5lY3RlZFJvb21zKCk7XG5cdHRoaXMuX2NyZWF0ZVJhbmRvbVJvb21Db25uZWN0aW9ucygpO1xuXHR0aGlzLl9jcmVhdGVSb29tcygpO1xuXHR0aGlzLl9jcmVhdGVDb3JyaWRvcnMoKTtcblx0XG5cdGlmIChjYWxsYmFjaykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fd2lkdGg7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9oZWlnaHQ7IGorKykge1xuXHRcdFx0XHRjYWxsYmFjayhpLCBqLCB0aGlzLm1hcFtpXVtqXSk7ICAgXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2NhbGN1bGF0ZVJvb21TaXplID0gZnVuY3Rpb24oc2l6ZSwgY2VsbCkge1xuXHR2YXIgbWF4ID0gTWF0aC5mbG9vcigoc2l6ZS9jZWxsKSAqIDAuOCk7XG5cdHZhciBtaW4gPSBNYXRoLmZsb29yKChzaXplL2NlbGwpICogMC4yNSk7XG5cdGlmIChtaW4gPCAyKSBtaW4gPSAyO1xuXHRpZiAobWF4IDwgMikgbWF4ID0gMjtcblx0cmV0dXJuIFttaW4sIG1heF07XG59XG5cblJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9pbml0Um9vbXMgPSBmdW5jdGlvbiAoKSB7IFxuXHQvLyBjcmVhdGUgcm9vbXMgYXJyYXkuIFRoaXMgaXMgdGhlIFwiZ3JpZFwiIGxpc3QgZnJvbSB0aGUgYWxnby4gIFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29wdGlvbnMuY2VsbFdpZHRoOyBpKyspIHsgIFxuXHRcdHRoaXMucm9vbXMucHVzaChbXSk7XG5cdFx0Zm9yKHZhciBqID0gMDsgaiA8IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDsgaisrKSB7XG5cdFx0XHR0aGlzLnJvb21zW2ldLnB1c2goe1wieFwiOjAsIFwieVwiOjAsIFwid2lkdGhcIjowLCBcImhlaWdodFwiOjAsIFwiY29ubmVjdGlvbnNcIjpbXSwgXCJjZWxseFwiOmksIFwiY2VsbHlcIjpqfSk7XG5cdFx0fVxuXHR9XG59XG5cblJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9jb25uZWN0Um9vbXMgPSBmdW5jdGlvbigpIHtcblx0Ly9waWNrIHJhbmRvbSBzdGFydGluZyBncmlkXG5cdHZhciBjZ3ggPSBST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwgdGhpcy5fb3B0aW9ucy5jZWxsV2lkdGgtMSk7XG5cdHZhciBjZ3kgPSBST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwgdGhpcy5fb3B0aW9ucy5jZWxsSGVpZ2h0LTEpO1xuXHRcblx0dmFyIGlkeDtcblx0dmFyIG5jZ3g7XG5cdHZhciBuY2d5O1xuXHRcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdHZhciByb29tO1xuXHR2YXIgb3RoZXJSb29tO1xuXHRcblx0Ly8gZmluZCAgdW5jb25uZWN0ZWQgbmVpZ2hib3VyIGNlbGxzXG5cdGRvIHtcblx0XG5cdFx0Ly92YXIgZGlyVG9DaGVjayA9IFswLDEsMiwzLDQsNSw2LDddO1xuXHRcdHZhciBkaXJUb0NoZWNrID0gWzAsMiw0LDZdO1xuXHRcdGRpclRvQ2hlY2sgPSBkaXJUb0NoZWNrLnJhbmRvbWl6ZSgpO1xuXHRcdFxuXHRcdGRvIHtcblx0XHRcdGZvdW5kID0gZmFsc2U7XG5cdFx0XHRpZHggPSBkaXJUb0NoZWNrLnBvcCgpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdG5jZ3ggPSBjZ3ggKyBST1QuRElSU1s4XVtpZHhdWzBdO1xuXHRcdFx0bmNneSA9IGNneSArIFJPVC5ESVJTWzhdW2lkeF1bMV07XG5cdFx0XHRcblx0XHRcdGlmKG5jZ3ggPCAwIHx8IG5jZ3ggPj0gdGhpcy5fb3B0aW9ucy5jZWxsV2lkdGgpIGNvbnRpbnVlO1xuXHRcdFx0aWYobmNneSA8IDAgfHwgbmNneSA+PSB0aGlzLl9vcHRpb25zLmNlbGxIZWlnaHQpIGNvbnRpbnVlO1xuXHRcdFx0XG5cdFx0XHRyb29tID0gdGhpcy5yb29tc1tjZ3hdW2NneV07XG5cdFx0XHRcblx0XHRcdGlmKHJvb21bXCJjb25uZWN0aW9uc1wiXS5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBhcyBsb25nIGFzIHRoaXMgcm9vbSBkb2Vzbid0IGFscmVhZHkgY29vbmVjdCB0byBtZSwgd2UgYXJlIG9rIHdpdGggaXQuIFxuXHRcdFx0XHRpZihyb29tW1wiY29ubmVjdGlvbnNcIl1bMF1bMF0gPT0gbmNneCAmJlxuXHRcdFx0XHRyb29tW1wiY29ubmVjdGlvbnNcIl1bMF1bMV0gPT0gbmNneSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdG90aGVyUm9vbSA9IHRoaXMucm9vbXNbbmNneF1bbmNneV07XG5cdFx0XHRcblx0XHRcdGlmIChvdGhlclJvb21bXCJjb25uZWN0aW9uc1wiXS5sZW5ndGggPT0gMCkgeyBcblx0XHRcdFx0b3RoZXJSb29tW1wiY29ubmVjdGlvbnNcIl0ucHVzaChbY2d4LGNneV0pO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5jb25uZWN0ZWRDZWxscy5wdXNoKFtuY2d4LCBuY2d5XSk7XG5cdFx0XHRcdGNneCA9IG5jZ3g7XG5cdFx0XHRcdGNneSA9IG5jZ3k7XG5cdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHR9IHdoaWxlIChkaXJUb0NoZWNrLmxlbmd0aCA+IDAgJiYgZm91bmQgPT0gZmFsc2UpXG5cdFx0XG5cdH0gd2hpbGUgKGRpclRvQ2hlY2subGVuZ3RoID4gMClcblxufVxuXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fY29ubmVjdFVuY29ubmVjdGVkUm9vbXMgPSBmdW5jdGlvbigpIHtcblx0Ly9XaGlsZSB0aGVyZSBhcmUgdW5jb25uZWN0ZWQgcm9vbXMsIHRyeSB0byBjb25uZWN0IHRoZW0gdG8gYSByYW5kb20gY29ubmVjdGVkIG5laWdoYm9yIFxuXHQvLyhpZiBhIHJvb20gaGFzIG5vIGNvbm5lY3RlZCBuZWlnaGJvcnMgeWV0LCBqdXN0IGtlZXAgY3ljbGluZywgeW91J2xsIGZpbGwgb3V0IHRvIGl0IGV2ZW50dWFsbHkpLlxuXHR2YXIgY3cgPSB0aGlzLl9vcHRpb25zLmNlbGxXaWR0aDtcblx0dmFyIGNoID0gdGhpcy5fb3B0aW9ucy5jZWxsSGVpZ2h0O1xuXHRcblx0dmFyIHJhbmRvbUNvbm5lY3RlZENlbGw7XG5cdHRoaXMuY29ubmVjdGVkQ2VsbHMgPSB0aGlzLmNvbm5lY3RlZENlbGxzLnJhbmRvbWl6ZSgpO1xuXHR2YXIgcm9vbTtcblx0dmFyIG90aGVyUm9vbTtcblx0dmFyIHZhbGlkUm9vbTtcblx0XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3B0aW9ucy5jZWxsV2lkdGg7IGkrKykge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fb3B0aW9ucy5jZWxsSGVpZ2h0OyBqKyspICB7XG5cdFx0XHRcdFxuXHRcdFx0cm9vbSA9IHRoaXMucm9vbXNbaV1bal07XG5cdFx0XHRcblx0XHRcdGlmIChyb29tW1wiY29ubmVjdGlvbnNcIl0ubGVuZ3RoID09IDApIHtcblx0XHRcdFx0dmFyIGRpcmVjdGlvbnMgPSBbMCwyLDQsNl07XG5cdFx0XHRcdGRpcmVjdGlvbnMgPSBkaXJlY3Rpb25zLnJhbmRvbWl6ZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHZhbGlkUm9vbSA9IGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBkaXJJZHggPSBkaXJlY3Rpb25zLnBvcCgpO1xuXHRcdFx0XHRcdHZhciBuZXdJID0gaSArIFJPVC5ESVJTWzhdW2RpcklkeF1bMF07XG5cdFx0XHRcdFx0dmFyIG5ld0ogPSBqICsgUk9ULkRJUlNbOF1bZGlySWR4XVsxXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobmV3SSA8IDAgfHwgbmV3SSA+PSBjdyB8fCBcblx0XHRcdFx0XHRuZXdKIDwgMCB8fCBuZXdKID49IGNoKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0b3RoZXJSb29tID0gdGhpcy5yb29tc1tuZXdJXVtuZXdKXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YWxpZFJvb20gPSB0cnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChvdGhlclJvb21bXCJjb25uZWN0aW9uc1wiXS5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgb3RoZXJSb29tW1wiY29ubmVjdGlvbnNcIl0ubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdGlmKG90aGVyUm9vbVtcImNvbm5lY3Rpb25zXCJdW2tdWzBdID09IGkgJiYgXG5cdFx0XHRcdFx0XHRvdGhlclJvb21bXCJjb25uZWN0aW9uc1wiXVtrXVsxXSA9PSBqKSB7XG5cdFx0XHRcdFx0XHRcdHZhbGlkUm9vbSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHZhbGlkUm9vbSkgYnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0gd2hpbGUgKGRpcmVjdGlvbnMubGVuZ3RoKVxuXHRcdFx0XHRcblx0XHRcdFx0aWYodmFsaWRSb29tKSB7IFxuXHRcdFx0XHRcdHJvb21bXCJjb25uZWN0aW9uc1wiXS5wdXNoKCBbb3RoZXJSb29tW1wiY2VsbHhcIl0sIG90aGVyUm9vbVtcImNlbGx5XCJdXSApOyAgXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCItLSBVbmFibGUgdG8gY29ubmVjdCByb29tLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fY3JlYXRlUmFuZG9tUm9vbUNvbm5lY3Rpb25zID0gZnVuY3Rpb24oY29ubmVjdGlvbnMpIHtcblx0Ly8gRW1wdHkgZm9yIG5vdy4gXG59XG5cblxuUk9ULk1hcC5Sb2d1ZS5wcm90b3R5cGUuX2NyZWF0ZVJvb21zID0gZnVuY3Rpb24oKSB7XG5cdC8vIENyZWF0ZSBSb29tcyBcblx0XG5cdHZhciB3ID0gdGhpcy5fd2lkdGg7XG5cdHZhciBoID0gdGhpcy5faGVpZ2h0O1xuXHRcblx0dmFyIGN3ID0gdGhpcy5fb3B0aW9ucy5jZWxsV2lkdGg7XG5cdHZhciBjaCA9IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDtcblx0XG5cdHZhciBjd3AgPSBNYXRoLmZsb29yKHRoaXMuX3dpZHRoIC8gY3cpO1xuXHR2YXIgY2hwID0gTWF0aC5mbG9vcih0aGlzLl9oZWlnaHQgLyBjaCk7XG5cdFxuXHR2YXIgcm9vbXc7XG5cdHZhciByb29taDtcblx0dmFyIHJvb21XaWR0aCA9IHRoaXMuX29wdGlvbnNbXCJyb29tV2lkdGhcIl07XG5cdHZhciByb29tSGVpZ2h0ID0gdGhpcy5fb3B0aW9uc1tcInJvb21IZWlnaHRcIl07XG5cdHZhciBzeDtcblx0dmFyIHN5O1xuXHR2YXIgdHg7XG5cdHZhciB0eTtcblx0dmFyIG90aGVyUm9vbTtcblx0XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY3c7IGkrKykge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY2g7IGorKykge1xuXHRcdFx0c3ggPSBjd3AgKiBpO1xuXHRcdFx0c3kgPSBjaHAgKiBqO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3ggPT0gMCkgc3ggPSAxO1xuXHRcdFx0aWYgKHN5ID09IDApIHN5ID0gMTtcblx0XHRcdFxuXHRcdFx0cm9vbXcgPSBST1QuUk5HLmdldFVuaWZvcm1JbnQocm9vbVdpZHRoWzBdLCByb29tV2lkdGhbMV0pO1xuXHRcdFx0cm9vbWggPSBST1QuUk5HLmdldFVuaWZvcm1JbnQocm9vbUhlaWdodFswXSwgcm9vbUhlaWdodFsxXSk7XG5cdFx0XHRcblx0XHRcdGlmIChqID4gMCkge1xuXHRcdFx0XHRvdGhlclJvb20gPSB0aGlzLnJvb21zW2ldW2otMV07XG5cdFx0XHRcdHdoaWxlIChzeSAtIChvdGhlclJvb21bXCJ5XCJdICsgb3RoZXJSb29tW1wiaGVpZ2h0XCJdICkgPCAzKSB7XG5cdFx0XHRcdFx0c3krKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0b3RoZXJSb29tID0gdGhpcy5yb29tc1tpLTFdW2pdO1xuXHRcdFx0XHR3aGlsZShzeCAtIChvdGhlclJvb21bXCJ4XCJdICsgb3RoZXJSb29tW1wid2lkdGhcIl0pIDwgMykge1xuXHRcdFx0XHRcdHN4Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIHN4T2Zmc2V0ID0gTWF0aC5yb3VuZChST1QuUk5HLmdldFVuaWZvcm1JbnQoMCwgY3dwLXJvb213KS8yKTtcblx0XHRcdHZhciBzeU9mZnNldCA9IE1hdGgucm91bmQoUk9ULlJORy5nZXRVbmlmb3JtSW50KDAsIGNocC1yb29taCkvMik7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChzeCArIHN4T2Zmc2V0ICsgcm9vbXcgPj0gdykge1xuXHRcdFx0XHRpZihzeE9mZnNldCkge1xuXHRcdFx0XHRcdHN4T2Zmc2V0LS07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm9vbXctLTsgXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0d2hpbGUgKHN5ICsgc3lPZmZzZXQgKyByb29taCA+PSBoKSB7IFxuXHRcdFx0XHRpZihzeU9mZnNldCkge1xuXHRcdFx0XHRcdHN5T2Zmc2V0LS07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm9vbWgtLTsgXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0c3ggPSBzeCArIHN4T2Zmc2V0O1xuXHRcdFx0c3kgPSBzeSArIHN5T2Zmc2V0O1xuXHRcdFx0XG5cdFx0XHR0aGlzLnJvb21zW2ldW2pdW1wieFwiXSA9IHN4O1xuXHRcdFx0dGhpcy5yb29tc1tpXVtqXVtcInlcIl0gPSBzeTtcblx0XHRcdHRoaXMucm9vbXNbaV1bal1bXCJ3aWR0aFwiXSA9IHJvb213O1xuXHRcdFx0dGhpcy5yb29tc1tpXVtqXVtcImhlaWdodFwiXSA9IHJvb21oOyAgXG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGlpID0gc3g7IGlpIDwgc3ggKyByb29tdzsgaWkrKykge1xuXHRcdFx0XHRmb3IgKHZhciBqaiA9IHN5OyBqaiA8IHN5ICsgcm9vbWg7IGpqKyspIHtcblx0XHRcdFx0XHR0aGlzLm1hcFtpaV1bampdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fSAgXG5cdFx0fVxuXHR9XG59XG5cblJPVC5NYXAuUm9ndWUucHJvdG90eXBlLl9nZXRXYWxsUG9zaXRpb24gPSBmdW5jdGlvbihhUm9vbSwgYURpcmVjdGlvbikge1xuXHR2YXIgcng7XG5cdHZhciByeTtcblx0dmFyIGRvb3I7XG5cdFxuXHRpZiAoYURpcmVjdGlvbiA9PSAxIHx8IGFEaXJlY3Rpb24gPT0gMykge1xuXHRcdHJ4ID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KGFSb29tW1wieFwiXSArIDEsIGFSb29tW1wieFwiXSArIGFSb29tW1wid2lkdGhcIl0gLSAyKTtcblx0XHRpZiAoYURpcmVjdGlvbiA9PSAxKSB7XG5cdFx0XHRyeSA9IGFSb29tW1wieVwiXSAtIDI7XG5cdFx0XHRkb29yID0gcnkgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyeSA9IGFSb29tW1wieVwiXSArIGFSb29tW1wiaGVpZ2h0XCJdICsgMTtcblx0XHRcdGRvb3IgPSByeSAtMTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5tYXBbcnhdW2Rvb3JdID0gMDsgLy8gaSdtIG5vdCBzZXR0aW5nIGEgc3BlY2lmaWMgJ2Rvb3InIHRpbGUgdmFsdWUgcmlnaHQgbm93LCBqdXN0IGVtcHR5IHNwYWNlLiBcblx0XHRcblx0fSBlbHNlIGlmIChhRGlyZWN0aW9uID09IDIgfHwgYURpcmVjdGlvbiA9PSA0KSB7XG5cdFx0cnkgPSBST1QuUk5HLmdldFVuaWZvcm1JbnQoYVJvb21bXCJ5XCJdICsgMSwgYVJvb21bXCJ5XCJdICsgYVJvb21bXCJoZWlnaHRcIl0gLSAyKTtcblx0XHRpZihhRGlyZWN0aW9uID09IDIpIHtcblx0XHRcdHJ4ID0gYVJvb21bXCJ4XCJdICsgYVJvb21bXCJ3aWR0aFwiXSArIDE7XG5cdFx0XHRkb29yID0gcnggLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyeCA9IGFSb29tW1wieFwiXSAtIDI7XG5cdFx0XHRkb29yID0gcnggKyAxO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLm1hcFtkb29yXVtyeV0gPSAwOyAvLyBpJ20gbm90IHNldHRpbmcgYSBzcGVjaWZpYyAnZG9vcicgdGlsZSB2YWx1ZSByaWdodCBub3csIGp1c3QgZW1wdHkgc3BhY2UuIFxuXHRcdFxuXHR9XG5cdHJldHVybiBbcngsIHJ5XTtcbn1cblxuLyoqKlxuKiBAcGFyYW0gc3RhcnRQb3NpdGlvbiBhIDIgZWxlbWVudCBhcnJheVxuKiBAcGFyYW0gZW5kUG9zaXRpb24gYSAyIGVsZW1lbnQgYXJyYXlcbiovXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fZHJhd0NvcnJpZG9yZSA9IGZ1bmN0aW9uIChzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xuXHR2YXIgeE9mZnNldCA9IGVuZFBvc2l0aW9uWzBdIC0gc3RhcnRQb3NpdGlvblswXTtcblx0dmFyIHlPZmZzZXQgPSBlbmRQb3NpdGlvblsxXSAtIHN0YXJ0UG9zaXRpb25bMV07XG5cdFxuXHR2YXIgeHBvcyA9IHN0YXJ0UG9zaXRpb25bMF07XG5cdHZhciB5cG9zID0gc3RhcnRQb3NpdGlvblsxXTtcblx0XG5cdHZhciB0ZW1wRGlzdDtcblx0dmFyIHhEaXI7XG5cdHZhciB5RGlyO1xuXHRcblx0dmFyIG1vdmU7IC8vIDIgZWxlbWVudCBhcnJheSwgZWxlbWVudCAwIGlzIHRoZSBkaXJlY3Rpb24sIGVsZW1lbnQgMSBpcyB0aGUgdG90YWwgdmFsdWUgdG8gbW92ZS4gXG5cdHZhciBtb3ZlcyA9IFtdOyAvLyBhIGxpc3Qgb2YgMiBlbGVtZW50IGFycmF5c1xuXHRcblx0dmFyIHhBYnMgPSBNYXRoLmFicyh4T2Zmc2V0KTtcblx0dmFyIHlBYnMgPSBNYXRoLmFicyh5T2Zmc2V0KTtcblx0XG5cdHZhciBwZXJjZW50ID0gUk9ULlJORy5nZXRVbmlmb3JtKCk7IC8vIHVzZWQgdG8gc3BsaXQgdGhlIG1vdmUgYXQgZGlmZmVyZW50IHBsYWNlcyBhbG9uZyB0aGUgbG9uZyBheGlzXG5cdHZhciBmaXJzdEhhbGYgPSBwZXJjZW50O1xuXHR2YXIgc2Vjb25kSGFsZiA9IDEgLSBwZXJjZW50O1xuXHRcblx0eERpciA9IHhPZmZzZXQgPiAwID8gMiA6IDY7XG5cdHlEaXIgPSB5T2Zmc2V0ID4gMCA/IDQgOiAwO1xuXHRcblx0aWYgKHhBYnMgPCB5QWJzKSB7XG5cdFx0Ly8gbW92ZSBmaXJzdEhhbGYgb2YgdGhlIHkgb2Zmc2V0XG5cdFx0dGVtcERpc3QgPSBNYXRoLmNlaWwoeUFicyAqIGZpcnN0SGFsZik7XG5cdFx0bW92ZXMucHVzaChbeURpciwgdGVtcERpc3RdKTtcblx0XHQvLyBtb3ZlIGFsbCB0aGUgeCBvZmZzZXRcblx0XHRtb3Zlcy5wdXNoKFt4RGlyLCB4QWJzXSk7XG5cdFx0Ly8gbW92ZSBzZW5kSGFsZiBvZiB0aGUgIHkgb2Zmc2V0XG5cdFx0dGVtcERpc3QgPSBNYXRoLmZsb29yKHlBYnMgKiBzZWNvbmRIYWxmKTtcblx0XHRtb3Zlcy5wdXNoKFt5RGlyLCB0ZW1wRGlzdF0pO1xuXHR9IGVsc2Uge1xuXHRcdC8vICBtb3ZlIGZpcnN0SGFsZiBvZiB0aGUgeCBvZmZzZXRcblx0XHR0ZW1wRGlzdCA9IE1hdGguY2VpbCh4QWJzICogZmlyc3RIYWxmKTtcblx0XHRtb3Zlcy5wdXNoKFt4RGlyLCB0ZW1wRGlzdF0pO1xuXHRcdC8vIG1vdmUgYWxsIHRoZSB5IG9mZnNldFxuXHRcdG1vdmVzLnB1c2goW3lEaXIsIHlBYnNdKTtcblx0XHQvLyBtb3ZlIHNlY29uZEhhbGYgb2YgdGhlIHggb2Zmc2V0LlxuXHRcdHRlbXBEaXN0ID0gTWF0aC5mbG9vcih4QWJzICogc2Vjb25kSGFsZik7XG5cdFx0bW92ZXMucHVzaChbeERpciwgdGVtcERpc3RdKTsgIFxuXHR9XG5cdFxuXHR0aGlzLm1hcFt4cG9zXVt5cG9zXSA9IDA7XG5cdFxuXHR3aGlsZSAobW92ZXMubGVuZ3RoID4gMCkge1xuXHRcdG1vdmUgPSBtb3Zlcy5wb3AoKTtcblx0XHR3aGlsZSAobW92ZVsxXSA+IDApIHtcblx0XHRcdHhwb3MgKz0gUk9ULkRJUlNbOF1bbW92ZVswXV1bMF07XG5cdFx0XHR5cG9zICs9IFJPVC5ESVJTWzhdW21vdmVbMF1dWzFdO1xuXHRcdFx0dGhpcy5tYXBbeHBvc11beXBvc10gPSAwO1xuXHRcdFx0bW92ZVsxXSA9IG1vdmVbMV0gLSAxO1xuXHRcdH1cblx0fVxufVxuXG5ST1QuTWFwLlJvZ3VlLnByb3RvdHlwZS5fY3JlYXRlQ29ycmlkb3JzID0gZnVuY3Rpb24gKCkge1xuXHQvLyBEcmF3IENvcnJpZG9ycyBiZXR3ZWVuIGNvbm5lY3RlZCByb29tc1xuXHRcblx0dmFyIGN3ID0gdGhpcy5fb3B0aW9ucy5jZWxsV2lkdGg7XG5cdHZhciBjaCA9IHRoaXMuX29wdGlvbnMuY2VsbEhlaWdodDtcblx0dmFyIHJvb207XG5cdHZhciBjb25uZWN0aW9uO1xuXHR2YXIgb3RoZXJSb29tO1xuXHR2YXIgd2FsbDtcblx0dmFyIG90aGVyV2FsbDtcblx0XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY3c7IGkrKykge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY2g7IGorKykge1xuXHRcdFx0cm9vbSA9IHRoaXMucm9vbXNbaV1bal07XG5cdFx0XHRcblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgcm9vbVtcImNvbm5lY3Rpb25zXCJdLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdGNvbm5lY3Rpb24gPSByb29tW1wiY29ubmVjdGlvbnNcIl1ba107IFxuXHRcdFx0XHRcblx0XHRcdFx0b3RoZXJSb29tID0gdGhpcy5yb29tc1tjb25uZWN0aW9uWzBdXVtjb25uZWN0aW9uWzFdXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGZpZ3VyZSBvdXQgd2hhdCB3YWxsIG91ciBjb3JyaWRvciB3aWxsIHN0YXJ0IG9uZS5cblx0XHRcdFx0Ly8gZmlndXJlIG91dCB3aGF0IHdhbGwgb3VyIGNvcnJpZG9yIHdpbGwgZW5kIG9uLiBcblx0XHRcdFx0aWYgKG90aGVyUm9vbVtcImNlbGx4XCJdID4gcm9vbVtcImNlbGx4XCJdICkge1xuXHRcdFx0XHRcdHdhbGwgPSAyO1xuXHRcdFx0XHRcdG90aGVyV2FsbCA9IDQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAob3RoZXJSb29tW1wiY2VsbHhcIl0gPCByb29tW1wiY2VsbHhcIl0gKSB7XG5cdFx0XHRcdFx0d2FsbCA9IDQ7XG5cdFx0XHRcdFx0b3RoZXJXYWxsID0gMjtcblx0XHRcdFx0fSBlbHNlIGlmKG90aGVyUm9vbVtcImNlbGx5XCJdID4gcm9vbVtcImNlbGx5XCJdKSB7XG5cdFx0XHRcdFx0d2FsbCA9IDM7XG5cdFx0XHRcdFx0b3RoZXJXYWxsID0gMTtcblx0XHRcdFx0fSBlbHNlIGlmKG90aGVyUm9vbVtcImNlbGx5XCJdIDwgcm9vbVtcImNlbGx5XCJdKSB7XG5cdFx0XHRcdFx0d2FsbCA9IDE7XG5cdFx0XHRcdFx0b3RoZXJXYWxsID0gMztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5fZHJhd0NvcnJpZG9yZSh0aGlzLl9nZXRXYWxsUG9zaXRpb24ocm9vbSwgd2FsbCksIHRoaXMuX2dldFdhbGxQb3NpdGlvbihvdGhlclJvb20sIG90aGVyV2FsbCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuLyoqXG4gKiBAY2xhc3MgRHVuZ2VvbiBmZWF0dXJlOyBoYXMgb3duIC5jcmVhdGUoKSBtZXRob2RcbiAqL1xuUk9ULk1hcC5GZWF0dXJlID0gZnVuY3Rpb24oKSB7fVxuUk9ULk1hcC5GZWF0dXJlLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oY2FuQmVEdWdDYWxsYmFjaykge31cblJPVC5NYXAuRmVhdHVyZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZGlnQ2FsbGJhY2spIHt9XG5ST1QuTWFwLkZlYXR1cmUucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKSB7fVxuUk9ULk1hcC5GZWF0dXJlLmNyZWF0ZVJhbmRvbUF0ID0gZnVuY3Rpb24oeCwgeSwgZHgsIGR5LCBvcHRpb25zKSB7fVxuXG4vKipcbiAqIEBjbGFzcyBSb29tXG4gKiBAYXVnbWVudHMgUk9ULk1hcC5GZWF0dXJlXG4gKiBAcGFyYW0ge2ludH0geDFcbiAqIEBwYXJhbSB7aW50fSB5MVxuICogQHBhcmFtIHtpbnR9IHgyXG4gKiBAcGFyYW0ge2ludH0geTJcbiAqIEBwYXJhbSB7aW50fSBbZG9vclhdXG4gKiBAcGFyYW0ge2ludH0gW2Rvb3JZXVxuICovXG5ST1QuTWFwLkZlYXR1cmUuUm9vbSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCBkb29yWCwgZG9vclkpIHtcblx0dGhpcy5feDEgPSB4MTtcblx0dGhpcy5feTEgPSB5MTtcblx0dGhpcy5feDIgPSB4Mjtcblx0dGhpcy5feTIgPSB5Mjtcblx0dGhpcy5fZG9vcnMgPSB7fTtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0KSB7IHRoaXMuYWRkRG9vcihkb29yWCwgZG9vclkpOyB9XG59XG5ST1QuTWFwLkZlYXR1cmUuUm9vbS5leHRlbmQoUk9ULk1hcC5GZWF0dXJlKTtcblxuLyoqXG4gKiBSb29tIG9mIHJhbmRvbSBzaXplLCB3aXRoIGEgZ2l2ZW4gZG9vcnMgYW5kIGRpcmVjdGlvblxuICovXG5ST1QuTWFwLkZlYXR1cmUuUm9vbS5jcmVhdGVSYW5kb21BdCA9IGZ1bmN0aW9uKHgsIHksIGR4LCBkeSwgb3B0aW9ucykge1xuXHR2YXIgbWluID0gb3B0aW9ucy5yb29tV2lkdGhbMF07XG5cdHZhciBtYXggPSBvcHRpb25zLnJvb21XaWR0aFsxXTtcblx0dmFyIHdpZHRoID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KG1pbiwgbWF4KTtcblx0XG5cdHZhciBtaW4gPSBvcHRpb25zLnJvb21IZWlnaHRbMF07XG5cdHZhciBtYXggPSBvcHRpb25zLnJvb21IZWlnaHRbMV07XG5cdHZhciBoZWlnaHQgPSBST1QuUk5HLmdldFVuaWZvcm1JbnQobWluLCBtYXgpO1xuXHRcblx0aWYgKGR4ID09IDEpIHsgLyogdG8gdGhlIHJpZ2h0ICovXG5cdFx0dmFyIHkyID0geSAtIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkgKiBoZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgdGhpcyh4KzEsIHkyLCB4K3dpZHRoLCB5MitoZWlnaHQtMSwgeCwgeSk7XG5cdH1cblx0XG5cdGlmIChkeCA9PSAtMSkgeyAvKiB0byB0aGUgbGVmdCAqL1xuXHRcdHZhciB5MiA9IHkgLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogaGVpZ2h0KTtcblx0XHRyZXR1cm4gbmV3IHRoaXMoeC13aWR0aCwgeTIsIHgtMSwgeTIraGVpZ2h0LTEsIHgsIHkpO1xuXHR9XG5cblx0aWYgKGR5ID09IDEpIHsgLyogdG8gdGhlIGJvdHRvbSAqL1xuXHRcdHZhciB4MiA9IHggLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogd2lkdGgpO1xuXHRcdHJldHVybiBuZXcgdGhpcyh4MiwgeSsxLCB4Mit3aWR0aC0xLCB5K2hlaWdodCwgeCwgeSk7XG5cdH1cblxuXHRpZiAoZHkgPT0gLTEpIHsgLyogdG8gdGhlIHRvcCAqL1xuXHRcdHZhciB4MiA9IHggLSBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpICogd2lkdGgpO1xuXHRcdHJldHVybiBuZXcgdGhpcyh4MiwgeS1oZWlnaHQsIHgyK3dpZHRoLTEsIHktMSwgeCwgeSk7XG5cdH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkeCBvciBkeSBtdXN0IGJlIDEgb3IgLTFcIik7XG59XG5cbi8qKlxuICogUm9vbSBvZiByYW5kb20gc2l6ZSwgcG9zaXRpb25lZCBhcm91bmQgY2VudGVyIGNvb3Jkc1xuICovXG5ST1QuTWFwLkZlYXR1cmUuUm9vbS5jcmVhdGVSYW5kb21DZW50ZXIgPSBmdW5jdGlvbihjeCwgY3ksIG9wdGlvbnMpIHtcblx0dmFyIG1pbiA9IG9wdGlvbnMucm9vbVdpZHRoWzBdO1xuXHR2YXIgbWF4ID0gb3B0aW9ucy5yb29tV2lkdGhbMV07XG5cdHZhciB3aWR0aCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChtaW4sIG1heCk7XG5cdFxuXHR2YXIgbWluID0gb3B0aW9ucy5yb29tSGVpZ2h0WzBdO1xuXHR2YXIgbWF4ID0gb3B0aW9ucy5yb29tSGVpZ2h0WzFdO1xuXHR2YXIgaGVpZ2h0ID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KG1pbiwgbWF4KTtcblxuXHR2YXIgeDEgPSBjeCAtIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqd2lkdGgpO1xuXHR2YXIgeTEgPSBjeSAtIE1hdGguZmxvb3IoUk9ULlJORy5nZXRVbmlmb3JtKCkqaGVpZ2h0KTtcblx0dmFyIHgyID0geDEgKyB3aWR0aCAtIDE7XG5cdHZhciB5MiA9IHkxICsgaGVpZ2h0IC0gMTtcblxuXHRyZXR1cm4gbmV3IHRoaXMoeDEsIHkxLCB4MiwgeTIpO1xufVxuXG4vKipcbiAqIFJvb20gb2YgcmFuZG9tIHNpemUgd2l0aGluIGEgZ2l2ZW4gZGltZW5zaW9uc1xuICovXG5ST1QuTWFwLkZlYXR1cmUuUm9vbS5jcmVhdGVSYW5kb20gPSBmdW5jdGlvbihhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCwgb3B0aW9ucykge1xuXHR2YXIgbWluID0gb3B0aW9ucy5yb29tV2lkdGhbMF07XG5cdHZhciBtYXggPSBvcHRpb25zLnJvb21XaWR0aFsxXTtcblx0dmFyIHdpZHRoID0gUk9ULlJORy5nZXRVbmlmb3JtSW50KG1pbiwgbWF4KTtcblx0XG5cdHZhciBtaW4gPSBvcHRpb25zLnJvb21IZWlnaHRbMF07XG5cdHZhciBtYXggPSBvcHRpb25zLnJvb21IZWlnaHRbMV07XG5cdHZhciBoZWlnaHQgPSBST1QuUk5HLmdldFVuaWZvcm1JbnQobWluLCBtYXgpO1xuXHRcblx0dmFyIGxlZnQgPSBhdmFpbFdpZHRoIC0gd2lkdGggLSAxO1xuXHR2YXIgdG9wID0gYXZhaWxIZWlnaHQgLSBoZWlnaHQgLSAxO1xuXG5cdHZhciB4MSA9IDEgKyBNYXRoLmZsb29yKFJPVC5STkcuZ2V0VW5pZm9ybSgpKmxlZnQpO1xuXHR2YXIgeTEgPSAxICsgTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSp0b3ApO1xuXHR2YXIgeDIgPSB4MSArIHdpZHRoIC0gMTtcblx0dmFyIHkyID0geTEgKyBoZWlnaHQgLSAxO1xuXG5cdHJldHVybiBuZXcgdGhpcyh4MSwgeTEsIHgyLCB5Mik7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5hZGREb29yID0gZnVuY3Rpb24oeCwgeSkge1xuXHR0aGlzLl9kb29yc1t4K1wiLFwiK3ldID0gMTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn1cbiAqL1xuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldERvb3JzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuX2Rvb3JzKSB7XG5cdFx0dmFyIHBhcnRzID0ga2V5LnNwbGl0KFwiLFwiKTtcblx0XHRjYWxsYmFjayhwYXJzZUludChwYXJ0c1swXSksIHBhcnNlSW50KHBhcnRzWzFdKSk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5jbGVhckRvb3JzID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX2Rvb3JzID0ge307XG5cdHJldHVybiB0aGlzO1xufVxuXG5ST1QuTWFwLkZlYXR1cmUuUm9vbS5wcm90b3R5cGUuYWRkRG9vcnMgPSBmdW5jdGlvbihpc1dhbGxDYWxsYmFjaykge1xuXHR2YXIgbGVmdCA9IHRoaXMuX3gxLTE7XG5cdHZhciByaWdodCA9IHRoaXMuX3gyKzE7XG5cdHZhciB0b3AgPSB0aGlzLl95MS0xO1xuXHR2YXIgYm90dG9tID0gdGhpcy5feTIrMTtcblxuXHRmb3IgKHZhciB4PWxlZnQ7IHg8PXJpZ2h0OyB4KyspIHtcblx0XHRmb3IgKHZhciB5PXRvcDsgeTw9Ym90dG9tOyB5KyspIHtcblx0XHRcdGlmICh4ICE9IGxlZnQgJiYgeCAhPSByaWdodCAmJiB5ICE9IHRvcCAmJiB5ICE9IGJvdHRvbSkgeyBjb250aW51ZTsgfVxuXHRcdFx0aWYgKGlzV2FsbENhbGxiYWNrKHgsIHkpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHRoaXMuYWRkRG9vcih4LCB5KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKFwicm9vbVwiLCB0aGlzLl94MSwgdGhpcy5feTEsIHRoaXMuX3gyLCB0aGlzLl95Mik7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oaXNXYWxsQ2FsbGJhY2ssIGNhbkJlRHVnQ2FsbGJhY2spIHsgXG5cdHZhciBsZWZ0ID0gdGhpcy5feDEtMTtcblx0dmFyIHJpZ2h0ID0gdGhpcy5feDIrMTtcblx0dmFyIHRvcCA9IHRoaXMuX3kxLTE7XG5cdHZhciBib3R0b20gPSB0aGlzLl95MisxO1xuXHRcblx0Zm9yICh2YXIgeD1sZWZ0OyB4PD1yaWdodDsgeCsrKSB7XG5cdFx0Zm9yICh2YXIgeT10b3A7IHk8PWJvdHRvbTsgeSsrKSB7XG5cdFx0XHRpZiAoeCA9PSBsZWZ0IHx8IHggPT0gcmlnaHQgfHwgeSA9PSB0b3AgfHwgeSA9PSBib3R0b20pIHtcblx0XHRcdFx0aWYgKCFpc1dhbGxDYWxsYmFjayh4LCB5KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghY2FuQmVEdWdDYWxsYmFjayh4LCB5KSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaWdDYWxsYmFjayBEaWcgY2FsbGJhY2sgd2l0aCBhIHNpZ25hdHVyZSAoeCwgeSwgdmFsdWUpLiBWYWx1ZXM6IDAgPSBlbXB0eSwgMSA9IHdhbGwsIDIgPSBkb29yLiBNdWx0aXBsZSBkb29ycyBhcmUgYWxsb3dlZC5cbiAqL1xuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRpZ0NhbGxiYWNrKSB7IFxuXHR2YXIgbGVmdCA9IHRoaXMuX3gxLTE7XG5cdHZhciByaWdodCA9IHRoaXMuX3gyKzE7XG5cdHZhciB0b3AgPSB0aGlzLl95MS0xO1xuXHR2YXIgYm90dG9tID0gdGhpcy5feTIrMTtcblx0XG5cdHZhciB2YWx1ZSA9IDA7XG5cdGZvciAodmFyIHg9bGVmdDsgeDw9cmlnaHQ7IHgrKykge1xuXHRcdGZvciAodmFyIHk9dG9wOyB5PD1ib3R0b207IHkrKykge1xuXHRcdFx0aWYgKHgrXCIsXCIreSBpbiB0aGlzLl9kb29ycykge1xuXHRcdFx0XHR2YWx1ZSA9IDI7XG5cdFx0XHR9IGVsc2UgaWYgKHggPT0gbGVmdCB8fCB4ID09IHJpZ2h0IHx8IHkgPT0gdG9wIHx8IHkgPT0gYm90dG9tKSB7XG5cdFx0XHRcdHZhbHVlID0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gMDtcblx0XHRcdH1cblx0XHRcdGRpZ0NhbGxiYWNrKHgsIHksIHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gW01hdGgucm91bmQoKHRoaXMuX3gxICsgdGhpcy5feDIpLzIpLCBNYXRoLnJvdW5kKCh0aGlzLl95MSArIHRoaXMuX3kyKS8yKV07XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl94MTtcbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl94Mjtcbn1cblxuUk9ULk1hcC5GZWF0dXJlLlJvb20ucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5feTE7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Sb29tLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX3kyO1xufVxuXG4vKipcbiAqIEBjbGFzcyBDb3JyaWRvclxuICogQGF1Z21lbnRzIFJPVC5NYXAuRmVhdHVyZVxuICogQHBhcmFtIHtpbnR9IHN0YXJ0WFxuICogQHBhcmFtIHtpbnR9IHN0YXJ0WVxuICogQHBhcmFtIHtpbnR9IGVuZFhcbiAqIEBwYXJhbSB7aW50fSBlbmRZXG4gKi9cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvciA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKSB7XG5cdHRoaXMuX3N0YXJ0WCA9IHN0YXJ0WDtcblx0dGhpcy5fc3RhcnRZID0gc3RhcnRZO1xuXHR0aGlzLl9lbmRYID0gZW5kWDsgXG5cdHRoaXMuX2VuZFkgPSBlbmRZO1xuXHR0aGlzLl9lbmRzV2l0aEFXYWxsID0gdHJ1ZTtcbn1cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5leHRlbmQoUk9ULk1hcC5GZWF0dXJlKTtcblxuUk9ULk1hcC5GZWF0dXJlLkNvcnJpZG9yLmNyZWF0ZVJhbmRvbUF0ID0gZnVuY3Rpb24oeCwgeSwgZHgsIGR5LCBvcHRpb25zKSB7XG5cdHZhciBtaW4gPSBvcHRpb25zLmNvcnJpZG9yTGVuZ3RoWzBdO1xuXHR2YXIgbWF4ID0gb3B0aW9ucy5jb3JyaWRvckxlbmd0aFsxXTtcblx0dmFyIGxlbmd0aCA9IFJPVC5STkcuZ2V0VW5pZm9ybUludChtaW4sIG1heCk7XG5cdFxuXHRyZXR1cm4gbmV3IHRoaXMoeCwgeSwgeCArIGR4Kmxlbmd0aCwgeSArIGR5Kmxlbmd0aCk7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coXCJjb3JyaWRvclwiLCB0aGlzLl9zdGFydFgsIHRoaXMuX3N0YXJ0WSwgdGhpcy5fZW5kWCwgdGhpcy5fZW5kWSk7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKGlzV2FsbENhbGxiYWNrLCBjYW5CZUR1Z0NhbGxiYWNrKXsgXG5cdHZhciBzeCA9IHRoaXMuX3N0YXJ0WDtcblx0dmFyIHN5ID0gdGhpcy5fc3RhcnRZO1xuXHR2YXIgZHggPSB0aGlzLl9lbmRYLXN4O1xuXHR2YXIgZHkgPSB0aGlzLl9lbmRZLXN5O1xuXHR2YXIgbGVuZ3RoID0gMSArIE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKTtcblx0XG5cdGlmIChkeCkgeyBkeCA9IGR4L01hdGguYWJzKGR4KTsgfVxuXHRpZiAoZHkpIHsgZHkgPSBkeS9NYXRoLmFicyhkeSk7IH1cblx0dmFyIG54ID0gZHk7XG5cdHZhciBueSA9IC1keDtcblx0XG5cdHZhciBvayA9IHRydWU7XG5cdGZvciAodmFyIGk9MDsgaTxsZW5ndGg7IGkrKykge1xuXHRcdHZhciB4ID0gc3ggKyBpKmR4O1xuXHRcdHZhciB5ID0gc3kgKyBpKmR5O1xuXG5cdFx0aWYgKCFjYW5CZUR1Z0NhbGxiYWNrKCAgICAgeCwgICAgICB5KSkgeyBvayA9IGZhbHNlOyB9XG5cdFx0aWYgKCFpc1dhbGxDYWxsYmFjayAgKHggKyBueCwgeSArIG55KSkgeyBvayA9IGZhbHNlOyB9XG5cdFx0aWYgKCFpc1dhbGxDYWxsYmFjayAgKHggLSBueCwgeSAtIG55KSkgeyBvayA9IGZhbHNlOyB9XG5cdFx0XG5cdFx0aWYgKCFvaykge1xuXHRcdFx0bGVuZ3RoID0gaTtcblx0XHRcdHRoaXMuX2VuZFggPSB4LWR4O1xuXHRcdFx0dGhpcy5fZW5kWSA9IHktZHk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBJZiB0aGUgbGVuZ3RoIGRlZ2VuZXJhdGVkLCB0aGlzIGNvcnJpZG9yIG1pZ2h0IGJlIGludmFsaWRcblx0ICovXG5cdCBcblx0Lyogbm90IHN1cHBvcnRlZCAqL1xuXHRpZiAobGVuZ3RoID09IDApIHsgcmV0dXJuIGZhbHNlOyB9IFxuXHRcblx0IC8qIGxlbmd0aCAxIGFsbG93ZWQgb25seSBpZiB0aGUgbmV4dCBzcGFjZSBpcyBlbXB0eSAqL1xuXHRpZiAobGVuZ3RoID09IDEgJiYgaXNXYWxsQ2FsbGJhY2sodGhpcy5fZW5kWCArIGR4LCB0aGlzLl9lbmRZICsgZHkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcblx0LyoqXG5cdCAqIFdlIGRvIG5vdCB3YW50IHRoZSBjb3JyaWRvciB0byBjcmFzaCBpbnRvIGEgY29ybmVyIG9mIGEgcm9vbTtcblx0ICogaWYgYW55IG9mIHRoZSBlbmRpbmcgY29ybmVycyBpcyBlbXB0eSwgdGhlIE4rMXRoIGNlbGwgb2YgdGhpcyBjb3JyaWRvciBtdXN0IGJlIGVtcHR5IHRvby5cblx0ICogXG5cdCAqIFNpdHVhdGlvbjpcblx0ICogIyMjIyMjIzFcblx0ICogLi4uLi4uLj9cblx0ICogIyMjIyMjIzJcblx0ICogXG5cdCAqIFRoZSBjb3JyaWRvciB3YXMgZHVnIGZyb20gbGVmdCB0byByaWdodC5cblx0ICogMSwgMiAtIHByb2JsZW1hdGljIGNvcm5lcnMsID8gPSBOKzF0aCBjZWxsIChub3QgZHVnKVxuXHQgKi9cblx0dmFyIGZpcnN0Q29ybmVyQmFkID0gIWlzV2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCArIG54LCB0aGlzLl9lbmRZICsgZHkgKyBueSk7XG5cdHZhciBzZWNvbmRDb3JuZXJCYWQgPSAhaXNXYWxsQ2FsbGJhY2sodGhpcy5fZW5kWCArIGR4IC0gbngsIHRoaXMuX2VuZFkgKyBkeSAtIG55KTtcblx0dGhpcy5fZW5kc1dpdGhBV2FsbCA9IGlzV2FsbENhbGxiYWNrKHRoaXMuX2VuZFggKyBkeCwgdGhpcy5fZW5kWSArIGR5KTtcblx0aWYgKChmaXJzdENvcm5lckJhZCB8fCBzZWNvbmRDb3JuZXJCYWQpICYmIHRoaXMuX2VuZHNXaXRoQVdhbGwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnQ2FsbGJhY2sgRGlnIGNhbGxiYWNrIHdpdGggYSBzaWduYXR1cmUgKHgsIHksIHZhbHVlKS4gVmFsdWVzOiAwID0gZW1wdHkuXG4gKi9cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZGlnQ2FsbGJhY2spIHsgXG5cdHZhciBzeCA9IHRoaXMuX3N0YXJ0WDtcblx0dmFyIHN5ID0gdGhpcy5fc3RhcnRZO1xuXHR2YXIgZHggPSB0aGlzLl9lbmRYLXN4O1xuXHR2YXIgZHkgPSB0aGlzLl9lbmRZLXN5O1xuXHR2YXIgbGVuZ3RoID0gMStNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSk7XG5cdFxuXHRpZiAoZHgpIHsgZHggPSBkeC9NYXRoLmFicyhkeCk7IH1cblx0aWYgKGR5KSB7IGR5ID0gZHkvTWF0aC5hYnMoZHkpOyB9XG5cdHZhciBueCA9IGR5O1xuXHR2YXIgbnkgPSAtZHg7XG5cdFxuXHRmb3IgKHZhciBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgeCA9IHN4ICsgaSpkeDtcblx0XHR2YXIgeSA9IHN5ICsgaSpkeTtcblx0XHRkaWdDYWxsYmFjayh4LCB5LCAwKTtcblx0fVxuXHRcblx0cmV0dXJuIHRydWU7XG59XG5cblJPVC5NYXAuRmVhdHVyZS5Db3JyaWRvci5wcm90b3R5cGUuY3JlYXRlUHJpb3JpdHlXYWxscyA9IGZ1bmN0aW9uKHByaW9yaXR5V2FsbENhbGxiYWNrKSB7XG5cdGlmICghdGhpcy5fZW5kc1dpdGhBV2FsbCkgeyByZXR1cm47IH1cblxuXHR2YXIgc3ggPSB0aGlzLl9zdGFydFg7XG5cdHZhciBzeSA9IHRoaXMuX3N0YXJ0WTtcblxuXHR2YXIgZHggPSB0aGlzLl9lbmRYLXN4O1xuXHR2YXIgZHkgPSB0aGlzLl9lbmRZLXN5O1xuXHRpZiAoZHgpIHsgZHggPSBkeC9NYXRoLmFicyhkeCk7IH1cblx0aWYgKGR5KSB7IGR5ID0gZHkvTWF0aC5hYnMoZHkpOyB9XG5cdHZhciBueCA9IGR5O1xuXHR2YXIgbnkgPSAtZHg7XG5cblx0cHJpb3JpdHlXYWxsQ2FsbGJhY2sodGhpcy5fZW5kWCArIGR4LCB0aGlzLl9lbmRZICsgZHkpO1xuXHRwcmlvcml0eVdhbGxDYWxsYmFjayh0aGlzLl9lbmRYICsgbngsIHRoaXMuX2VuZFkgKyBueSk7XG5cdHByaW9yaXR5V2FsbENhbGxiYWNrKHRoaXMuX2VuZFggLSBueCwgdGhpcy5fZW5kWSAtIG55KTtcbn1cbi8qKlxuICogQGNsYXNzIEJhc2Ugbm9pc2UgZ2VuZXJhdG9yXG4gKi9cblJPVC5Ob2lzZSA9IGZ1bmN0aW9uKCkge1xufTtcblxuUk9ULk5vaXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4LCB5KSB7fVxuLyoqXG4gKiBBIHNpbXBsZSAyZCBpbXBsZW1lbnRhdGlvbiBvZiBzaW1wbGV4IG5vaXNlIGJ5IE9uZHJlaiBaYXJhXG4gKlxuICogQmFzZWQgb24gYSBzcGVlZC1pbXByb3ZlZCBzaW1wbGV4IG5vaXNlIGFsZ29yaXRobSBmb3IgMkQsIDNEIGFuZCA0RCBpbiBKYXZhLlxuICogV2hpY2ggaXMgYmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxuICogV2l0aCBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cbiAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMkQgc2ltcGxleCBub2lzZSBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7aW50fSBbZ3JhZGllbnRzPTI1Nl0gUmFuZG9tIGdyYWRpZW50c1xuICovXG5ST1QuTm9pc2UuU2ltcGxleCA9IGZ1bmN0aW9uKGdyYWRpZW50cykge1xuXHRST1QuTm9pc2UuY2FsbCh0aGlzKTtcblxuXHR0aGlzLl9GMiA9IDAuNSAqIChNYXRoLnNxcnQoMykgLSAxKTtcblx0dGhpcy5fRzIgPSAoMyAtIE1hdGguc3FydCgzKSkgLyA2O1xuXG5cdHRoaXMuX2dyYWRpZW50cyA9IFtcblx0XHRbIDAsIC0xXSxcblx0XHRbIDEsIC0xXSxcblx0XHRbIDEsICAwXSxcblx0XHRbIDEsICAxXSxcblx0XHRbIDAsICAxXSxcblx0XHRbLTEsICAxXSxcblx0XHRbLTEsICAwXSxcblx0XHRbLTEsIC0xXVxuXHRdO1xuXG5cdHZhciBwZXJtdXRhdGlvbnMgPSBbXTtcblx0dmFyIGNvdW50ID0gZ3JhZGllbnRzIHx8IDI1Njtcblx0Zm9yICh2YXIgaT0wO2k8Y291bnQ7aSsrKSB7IHBlcm11dGF0aW9ucy5wdXNoKGkpOyB9XG5cdHBlcm11dGF0aW9ucyA9IHBlcm11dGF0aW9ucy5yYW5kb21pemUoKTtcblxuXHR0aGlzLl9wZXJtcyA9IFtdO1xuXHR0aGlzLl9pbmRleGVzID0gW107XG5cblx0Zm9yICh2YXIgaT0wO2k8Mipjb3VudDtpKyspIHtcblx0XHR0aGlzLl9wZXJtcy5wdXNoKHBlcm11dGF0aW9uc1tpICUgY291bnRdKTtcblx0XHR0aGlzLl9pbmRleGVzLnB1c2godGhpcy5fcGVybXNbaV0gJSB0aGlzLl9ncmFkaWVudHMubGVuZ3RoKTtcblx0fVxuXG59O1xuUk9ULk5vaXNlLlNpbXBsZXguZXh0ZW5kKFJPVC5Ob2lzZSk7XG5cblJPVC5Ob2lzZS5TaW1wbGV4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4aW4sIHlpbikge1xuXHR2YXIgcGVybXMgPSB0aGlzLl9wZXJtcztcblx0dmFyIGluZGV4ZXMgPSB0aGlzLl9pbmRleGVzO1xuXHR2YXIgY291bnQgPSBwZXJtcy5sZW5ndGgvMjtcblx0dmFyIEcyID0gdGhpcy5fRzI7XG5cblx0dmFyIG4wID0wLCBuMSA9IDAsIG4yID0gMCwgZ2k7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuXG5cdC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cblx0dmFyIHMgPSAoeGluICsgeWluKSAqIHRoaXMuX0YyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG5cdHZhciBpID0gTWF0aC5mbG9vcih4aW4gKyBzKTtcblx0dmFyIGogPSBNYXRoLmZsb29yKHlpbiArIHMpO1xuXHR2YXIgdCA9IChpICsgaikgKiBHMjtcblx0dmFyIFgwID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5KSBzcGFjZVxuXHR2YXIgWTAgPSBqIC0gdDtcblx0dmFyIHgwID0geGluIC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG5cdHZhciB5MCA9IHlpbiAtIFkwO1xuXG5cdC8vIEZvciB0aGUgMkQgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUuXG5cdC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cblx0dmFyIGkxLCBqMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIChtaWRkbGUpIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGopIGNvb3Jkc1xuXHRpZiAoeDAgPiB5MCkge1xuXHRcdGkxID0gMTtcblx0XHRqMSA9IDA7XG5cdH0gZWxzZSB7IC8vIGxvd2VyIHRyaWFuZ2xlLCBYWSBvcmRlcjogKDAsMCktPigxLDApLT4oMSwxKVxuXHRcdGkxID0gMDtcblx0XHRqMSA9IDE7XG5cdH0gLy8gdXBwZXIgdHJpYW5nbGUsIFlYIG9yZGVyOiAoMCwwKS0+KDAsMSktPigxLDEpXG5cblx0Ly8gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAoeCx5KSwgYW5kXG5cdC8vIGEgc3RlcCBvZiAoMCwxKSBpbiAoaSxqKSBtZWFucyBhIHN0ZXAgb2YgKC1jLDEtYykgaW4gKHgseSksIHdoZXJlXG5cdC8vIGMgPSAoMy1zcXJ0KDMpKS82XG5cdHZhciB4MSA9IHgwIC0gaTEgKyBHMjsgLy8gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcblx0dmFyIHkxID0geTAgLSBqMSArIEcyO1xuXHR2YXIgeDIgPSB4MCAtIDEgKyAyKkcyOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcblx0dmFyIHkyID0geTAgLSAxICsgMipHMjtcblxuXHQvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVyc1xuXHR2YXIgaWkgPSBpLm1vZChjb3VudCk7XG5cdHZhciBqaiA9IGoubW9kKGNvdW50KTtcblxuXHQvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXG5cdHZhciB0MCA9IDAuNSAtIHgwKngwIC0geTAqeTA7XG5cdGlmICh0MCA+PSAwKSB7XG5cdFx0dDAgKj0gdDA7XG5cdFx0Z2kgPSBpbmRleGVzW2lpK3Blcm1zW2pqXV07XG5cdFx0dmFyIGdyYWQgPSB0aGlzLl9ncmFkaWVudHNbZ2ldO1xuXHRcdG4wID0gdDAgKiB0MCAqIChncmFkWzBdICogeDAgKyBncmFkWzFdICogeTApO1xuXHR9XG5cdFxuXHR2YXIgdDEgPSAwLjUgLSB4MSp4MSAtIHkxKnkxO1xuXHRpZiAodDEgPj0gMCkge1xuXHRcdHQxICo9IHQxO1xuXHRcdGdpID0gaW5kZXhlc1tpaStpMStwZXJtc1tqaitqMV1dO1xuXHRcdHZhciBncmFkID0gdGhpcy5fZ3JhZGllbnRzW2dpXTtcblx0XHRuMSA9IHQxICogdDEgKiAoZ3JhZFswXSAqIHgxICsgZ3JhZFsxXSAqIHkxKTtcblx0fVxuXHRcblx0dmFyIHQyID0gMC41IC0geDIqeDIgLSB5Mip5Mjtcblx0aWYgKHQyID49IDApIHtcblx0XHR0MiAqPSB0Mjtcblx0XHRnaSA9IGluZGV4ZXNbaWkrMStwZXJtc1tqaisxXV07XG5cdFx0dmFyIGdyYWQgPSB0aGlzLl9ncmFkaWVudHNbZ2ldO1xuXHRcdG4yID0gdDIgKiB0MiAqIChncmFkWzBdICogeDIgKyBncmFkWzFdICogeTIpO1xuXHR9XG5cblx0Ly8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuXHQvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byByZXR1cm4gdmFsdWVzIGluIHRoZSBpbnRlcnZhbCBbLTEsMV0uXG5cdHJldHVybiA3MCAqIChuMCArIG4xICsgbjIpO1xufVxuLyoqXG4gKiBAY2xhc3MgQWJzdHJhY3QgRk9WIGFsZ29yaXRobVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlnaHRQYXNzZXNDYWxsYmFjayBEb2VzIHRoZSBsaWdodCBwYXNzIHRocm91Z2ggeCx5P1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRvcG9sb2d5PThdIDQvNi84XG4gKi9cblJPVC5GT1YgPSBmdW5jdGlvbihsaWdodFBhc3Nlc0NhbGxiYWNrLCBvcHRpb25zKSB7XG5cdHRoaXMuX2xpZ2h0UGFzc2VzID0gbGlnaHRQYXNzZXNDYWxsYmFjaztcblx0dGhpcy5fb3B0aW9ucyA9IHtcblx0XHR0b3BvbG9neTogOFxuXHR9XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHZpc2liaWxpdHkgZm9yIGEgMzYwLWRlZ3JlZSBjaXJjbGVcbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtpbnR9IFIgTWF4aW11bSB2aXNpYmlsaXR5IHJhZGl1c1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuUk9ULkZPVi5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKHgsIHksIFIsIGNhbGxiYWNrKSB7fVxuXG4vKipcbiAqIFJldHVybiBhbGwgbmVpZ2hib3JzIGluIGEgY29uY2VudHJpYyByaW5nXG4gKiBAcGFyYW0ge2ludH0gY3ggY2VudGVyLXhcbiAqIEBwYXJhbSB7aW50fSBjeSBjZW50ZXIteVxuICogQHBhcmFtIHtpbnR9IHIgcmFuZ2VcbiAqL1xuUk9ULkZPVi5wcm90b3R5cGUuX2dldENpcmNsZSA9IGZ1bmN0aW9uKGN4LCBjeSwgcikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBkaXJzLCBjb3VudEZhY3Rvciwgc3RhcnRPZmZzZXQ7XG5cblx0c3dpdGNoICh0aGlzLl9vcHRpb25zLnRvcG9sb2d5KSB7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0Y291bnRGYWN0b3IgPSAxO1xuXHRcdFx0c3RhcnRPZmZzZXQgPSBbMCwgMV07XG5cdFx0XHRkaXJzID0gW1xuXHRcdFx0XHRST1QuRElSU1s4XVs3XSxcblx0XHRcdFx0Uk9ULkRJUlNbOF1bMV0sXG5cdFx0XHRcdFJPVC5ESVJTWzhdWzNdLFxuXHRcdFx0XHRST1QuRElSU1s4XVs1XVxuXHRcdFx0XVxuXHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSA2OlxuXHRcdFx0ZGlycyA9IFJPVC5ESVJTWzZdO1xuXHRcdFx0Y291bnRGYWN0b3IgPSAxO1xuXHRcdFx0c3RhcnRPZmZzZXQgPSBbLTEsIDFdO1xuXHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSA4OlxuXHRcdFx0ZGlycyA9IFJPVC5ESVJTWzRdO1xuXHRcdFx0Y291bnRGYWN0b3IgPSAyO1xuXHRcdFx0c3RhcnRPZmZzZXQgPSBbLTEsIDFdO1xuXHRcdGJyZWFrO1xuXHR9XG5cblx0Lyogc3RhcnRpbmcgbmVpZ2hib3IgKi9cblx0dmFyIHggPSBjeCArIHN0YXJ0T2Zmc2V0WzBdKnI7XG5cdHZhciB5ID0gY3kgKyBzdGFydE9mZnNldFsxXSpyO1xuXG5cdC8qIGNpcmNsZSAqL1xuXHRmb3IgKHZhciBpPTA7aTxkaXJzLmxlbmd0aDtpKyspIHtcblx0XHRmb3IgKHZhciBqPTA7ajxyKmNvdW50RmFjdG9yO2orKykge1xuXHRcdFx0cmVzdWx0LnB1c2goW3gsIHldKTtcblx0XHRcdHggKz0gZGlyc1tpXVswXTtcblx0XHRcdHkgKz0gZGlyc1tpXVsxXTtcblxuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBjbGFzcyBEaXNjcmV0ZSBzaGFkb3djYXN0aW5nIGFsZ29yaXRobS4gT2Jzb2xldGVkIGJ5IFByZWNpc2Ugc2hhZG93Y2FzdGluZy5cbiAqIEBhdWdtZW50cyBST1QuRk9WXG4gKi9cblJPVC5GT1YuRGlzY3JldGVTaGFkb3djYXN0aW5nID0gZnVuY3Rpb24obGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucykge1xuXHRST1QuRk9WLmNhbGwodGhpcywgbGlnaHRQYXNzZXNDYWxsYmFjaywgb3B0aW9ucyk7XG59XG5ST1QuRk9WLkRpc2NyZXRlU2hhZG93Y2FzdGluZy5leHRlbmQoUk9ULkZPVik7XG5cbi8qKlxuICogQHNlZSBST1QuRk9WI2NvbXB1dGVcbiAqL1xuUk9ULkZPVi5EaXNjcmV0ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbih4LCB5LCBSLCBjYWxsYmFjaykge1xuXHR2YXIgY2VudGVyID0gdGhpcy5fY29vcmRzO1xuXHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdC8qIHRoaXMgcGxhY2UgaXMgYWx3YXlzIHZpc2libGUgKi9cblx0Y2FsbGJhY2soeCwgeSwgMCwgMSk7XG5cblx0Lyogc3RhbmRpbmcgaW4gYSBkYXJrIHBsYWNlLiBGSVhNRSBpcyB0aGlzIGEgZ29vZCBpZGVhPyAgKi9cblx0aWYgKCF0aGlzLl9saWdodFBhc3Nlcyh4LCB5KSkgeyByZXR1cm47IH1cblx0XG5cdC8qIHN0YXJ0IGFuZCBlbmQgYW5nbGVzICovXG5cdHZhciBEQVRBID0gW107XG5cdFxuXHR2YXIgQSwgQiwgY3gsIGN5LCBibG9ja3M7XG5cblx0LyogYW5hbHl6ZSBzdXJyb3VuZGluZyBjZWxscyBpbiBjb25jZW50cmljIHJpbmdzLCBzdGFydGluZyBmcm9tIHRoZSBjZW50ZXIgKi9cblx0Zm9yICh2YXIgcj0xOyByPD1SOyByKyspIHtcblx0XHR2YXIgbmVpZ2hib3JzID0gdGhpcy5fZ2V0Q2lyY2xlKHgsIHksIHIpO1xuXHRcdHZhciBhbmdsZSA9IDM2MCAvIG5laWdoYm9ycy5sZW5ndGg7XG5cblx0XHRmb3IgKHZhciBpPTA7aTxuZWlnaGJvcnMubGVuZ3RoO2krKykge1xuXHRcdFx0Y3ggPSBuZWlnaGJvcnNbaV1bMF07XG5cdFx0XHRjeSA9IG5laWdoYm9yc1tpXVsxXTtcblx0XHRcdEEgPSBhbmdsZSAqIChpIC0gMC41KTtcblx0XHRcdEIgPSBBICsgYW5nbGU7XG5cdFx0XHRcblx0XHRcdGJsb2NrcyA9ICF0aGlzLl9saWdodFBhc3NlcyhjeCwgY3kpO1xuXHRcdFx0aWYgKHRoaXMuX3Zpc2libGVDb29yZHMoTWF0aC5mbG9vcihBKSwgTWF0aC5jZWlsKEIpLCBibG9ja3MsIERBVEEpKSB7IGNhbGxiYWNrKGN4LCBjeSwgciwgMSk7IH1cblx0XHRcdFxuXHRcdFx0aWYgKERBVEEubGVuZ3RoID09IDIgJiYgREFUQVswXSA9PSAwICYmIERBVEFbMV0gPT0gMzYwKSB7IHJldHVybjsgfSAvKiBjdXRvZmY/ICovXG5cblx0XHR9IC8qIGZvciBhbGwgY2VsbHMgaW4gdGhpcyByaW5nICovXG5cdH0gLyogZm9yIGFsbCByaW5ncyAqL1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50fSBBIHN0YXJ0IGFuZ2xlXG4gKiBAcGFyYW0ge2ludH0gQiBlbmQgYW5nbGVcbiAqIEBwYXJhbSB7Ym9vbH0gYmxvY2tzIERvZXMgY3VycmVudCBjZWxsIGJsb2NrIHZpc2liaWxpdHk/XG4gKiBAcGFyYW0ge2ludFtdW119IERBVEEgc2hhZG93ZWQgYW5nbGUgcGFpcnNcbiAqL1xuUk9ULkZPVi5EaXNjcmV0ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLl92aXNpYmxlQ29vcmRzID0gZnVuY3Rpb24oQSwgQiwgYmxvY2tzLCBEQVRBKSB7XG5cdGlmIChBIDwgMCkgeyBcblx0XHR2YXIgdjEgPSBhcmd1bWVudHMuY2FsbGVlKDAsIEIsIGJsb2NrcywgREFUQSk7XG5cdFx0dmFyIHYyID0gYXJndW1lbnRzLmNhbGxlZSgzNjArQSwgMzYwLCBibG9ja3MsIERBVEEpO1xuXHRcdHJldHVybiB2MSB8fCB2Mjtcblx0fVxuXHRcblx0dmFyIGluZGV4ID0gMDtcblx0d2hpbGUgKGluZGV4IDwgREFUQS5sZW5ndGggJiYgREFUQVtpbmRleF0gPCBBKSB7IGluZGV4Kys7IH1cblx0XG5cdGlmIChpbmRleCA9PSBEQVRBLmxlbmd0aCkgeyAvKiBjb21wbGV0ZWx5IG5ldyBzaGFkb3cgKi9cblx0XHRpZiAoYmxvY2tzKSB7IERBVEEucHVzaChBLCBCKTsgfSBcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0dmFyIGNvdW50ID0gMDtcblx0XG5cdGlmIChpbmRleCAlIDIpIHsgLyogdGhpcyBzaGFkb3cgc3RhcnRzIGluIGFuIGV4aXN0aW5nIHNoYWRvdywgb3Igd2l0aGluIGl0cyBlbmRpbmcgYm91bmRhcnkgKi9cblx0XHR3aGlsZSAoaW5kZXggPCBEQVRBLmxlbmd0aCAmJiBEQVRBW2luZGV4XSA8IEIpIHtcblx0XHRcdGluZGV4Kys7XG5cdFx0XHRjb3VudCsrO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoY291bnQgPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcblx0XHRpZiAoYmxvY2tzKSB7IFxuXHRcdFx0aWYgKGNvdW50ICUgMikge1xuXHRcdFx0XHREQVRBLnNwbGljZShpbmRleC1jb3VudCwgY291bnQsIEIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0REFUQS5zcGxpY2UoaW5kZXgtY291bnQsIGNvdW50KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSBlbHNlIHsgLyogdGhpcyBzaGFkb3cgc3RhcnRzIG91dHNpZGUgYW4gZXhpc3Rpbmcgc2hhZG93LCBvciB3aXRoaW4gYSBzdGFydGluZyBib3VuZGFyeSAqL1xuXHRcdHdoaWxlIChpbmRleCA8IERBVEEubGVuZ3RoICYmIERBVEFbaW5kZXhdIDwgQikge1xuXHRcdFx0aW5kZXgrKztcblx0XHRcdGNvdW50Kys7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIHZpc2libGUgd2hlbiBvdXRzaWRlIGFuIGV4aXN0aW5nIHNoYWRvdywgb3Igd2hlbiBvdmVybGFwcGluZyAqL1xuXHRcdGlmIChBID09IERBVEFbaW5kZXgtY291bnRdICYmIGNvdW50ID09IDEpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XG5cdFx0aWYgKGJsb2NrcykgeyBcblx0XHRcdGlmIChjb3VudCAlIDIpIHtcblx0XHRcdFx0REFUQS5zcGxpY2UoaW5kZXgtY291bnQsIGNvdW50LCBBKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERBVEEuc3BsaWNlKGluZGV4LWNvdW50LCBjb3VudCwgQSwgQik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFx0XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cbi8qKlxuICogQGNsYXNzIFByZWNpc2Ugc2hhZG93Y2FzdGluZyBhbGdvcml0aG1cbiAqIEBhdWdtZW50cyBST1QuRk9WXG4gKi9cblJPVC5GT1YuUHJlY2lzZVNoYWRvd2Nhc3RpbmcgPSBmdW5jdGlvbihsaWdodFBhc3Nlc0NhbGxiYWNrLCBvcHRpb25zKSB7XG5cdFJPVC5GT1YuY2FsbCh0aGlzLCBsaWdodFBhc3Nlc0NhbGxiYWNrLCBvcHRpb25zKTtcbn1cblJPVC5GT1YuUHJlY2lzZVNoYWRvd2Nhc3RpbmcuZXh0ZW5kKFJPVC5GT1YpO1xuXG4vKipcbiAqIEBzZWUgUk9ULkZPViNjb21wdXRlXG4gKi9cblJPVC5GT1YuUHJlY2lzZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbih4LCB5LCBSLCBjYWxsYmFjaykge1xuXHQvKiB0aGlzIHBsYWNlIGlzIGFsd2F5cyB2aXNpYmxlICovXG5cdGNhbGxiYWNrKHgsIHksIDAsIDEpO1xuXG5cdC8qIHN0YW5kaW5nIGluIGEgZGFyayBwbGFjZS4gRklYTUUgaXMgdGhpcyBhIGdvb2QgaWRlYT8gICovXG5cdGlmICghdGhpcy5fbGlnaHRQYXNzZXMoeCwgeSkpIHsgcmV0dXJuOyB9XG5cdFxuXHQvKiBsaXN0IG9mIGFsbCBzaGFkb3dzICovXG5cdHZhciBTSEFET1dTID0gW107XG5cdFxuXHR2YXIgY3gsIGN5LCBibG9ja3MsIEExLCBBMiwgdmlzaWJpbGl0eTtcblxuXHQvKiBhbmFseXplIHN1cnJvdW5kaW5nIGNlbGxzIGluIGNvbmNlbnRyaWMgcmluZ3MsIHN0YXJ0aW5nIGZyb20gdGhlIGNlbnRlciAqL1xuXHRmb3IgKHZhciByPTE7IHI8PVI7IHIrKykge1xuXHRcdHZhciBuZWlnaGJvcnMgPSB0aGlzLl9nZXRDaXJjbGUoeCwgeSwgcik7XG5cdFx0dmFyIG5laWdoYm9yQ291bnQgPSBuZWlnaGJvcnMubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaT0wO2k8bmVpZ2hib3JDb3VudDtpKyspIHtcblx0XHRcdGN4ID0gbmVpZ2hib3JzW2ldWzBdO1xuXHRcdFx0Y3kgPSBuZWlnaGJvcnNbaV1bMV07XG5cdFx0XHQvKiBzaGlmdCBoYWxmLWFuLWFuZ2xlIGJhY2t3YXJkcyB0byBtYWludGFpbiBjb25zaXN0ZW5jeSBvZiAwLXRoIGNlbGxzICovXG5cdFx0XHRBMSA9IFtpID8gMippLTEgOiAyKm5laWdoYm9yQ291bnQtMSwgMipuZWlnaGJvckNvdW50XTtcblx0XHRcdEEyID0gWzIqaSsxLCAyKm5laWdoYm9yQ291bnRdOyBcblx0XHRcdFxuXHRcdFx0YmxvY2tzID0gIXRoaXMuX2xpZ2h0UGFzc2VzKGN4LCBjeSk7XG5cdFx0XHR2aXNpYmlsaXR5ID0gdGhpcy5fY2hlY2tWaXNpYmlsaXR5KEExLCBBMiwgYmxvY2tzLCBTSEFET1dTKTtcblx0XHRcdGlmICh2aXNpYmlsaXR5KSB7IGNhbGxiYWNrKGN4LCBjeSwgciwgdmlzaWJpbGl0eSk7IH1cblxuXHRcdFx0aWYgKFNIQURPV1MubGVuZ3RoID09IDIgJiYgU0hBRE9XU1swXVswXSA9PSAwICYmIFNIQURPV1NbMV1bMF0gPT0gU0hBRE9XU1sxXVsxXSkgeyByZXR1cm47IH0gLyogY3V0b2ZmPyAqL1xuXG5cdFx0fSAvKiBmb3IgYWxsIGNlbGxzIGluIHRoaXMgcmluZyAqL1xuXHR9IC8qIGZvciBhbGwgcmluZ3MgKi9cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludFsyXX0gQTEgYXJjIHN0YXJ0XG4gKiBAcGFyYW0ge2ludFsyXX0gQTIgYXJjIGVuZFxuICogQHBhcmFtIHtib29sfSBibG9ja3MgRG9lcyBjdXJyZW50IGFyYyBibG9jayB2aXNpYmlsaXR5P1xuICogQHBhcmFtIHtpbnRbXVtdfSBTSEFET1dTIGxpc3Qgb2YgYWN0aXZlIHNoYWRvd3NcbiAqL1xuUk9ULkZPVi5QcmVjaXNlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuX2NoZWNrVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKEExLCBBMiwgYmxvY2tzLCBTSEFET1dTKSB7XG5cdGlmIChBMVswXSA+IEEyWzBdKSB7IC8qIHNwbGl0IGludG8gdHdvIHN1Yi1hcmNzICovXG5cdFx0dmFyIHYxID0gdGhpcy5fY2hlY2tWaXNpYmlsaXR5KEExLCBbQTFbMV0sIEExWzFdXSwgYmxvY2tzLCBTSEFET1dTKTtcblx0XHR2YXIgdjIgPSB0aGlzLl9jaGVja1Zpc2liaWxpdHkoWzAsIDFdLCBBMiwgYmxvY2tzLCBTSEFET1dTKTtcblx0XHRyZXR1cm4gKHYxK3YyKS8yO1xuXHR9XG5cblx0LyogaW5kZXgxOiBmaXJzdCBzaGFkb3cgPj0gQTEgKi9cblx0dmFyIGluZGV4MSA9IDAsIGVkZ2UxID0gZmFsc2U7XG5cdHdoaWxlIChpbmRleDEgPCBTSEFET1dTLmxlbmd0aCkge1xuXHRcdHZhciBvbGQgPSBTSEFET1dTW2luZGV4MV07XG5cdFx0dmFyIGRpZmYgPSBvbGRbMF0qQTFbMV0gLSBBMVswXSpvbGRbMV07XG5cdFx0aWYgKGRpZmYgPj0gMCkgeyAvKiBvbGQgPj0gQTEgKi9cblx0XHRcdGlmIChkaWZmID09IDAgJiYgIShpbmRleDEgJSAyKSkgeyBlZGdlMSA9IHRydWU7IH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpbmRleDErKztcblx0fVxuXG5cdC8qIGluZGV4MjogbGFzdCBzaGFkb3cgPD0gQTIgKi9cblx0dmFyIGluZGV4MiA9IFNIQURPV1MubGVuZ3RoLCBlZGdlMiA9IGZhbHNlO1xuXHR3aGlsZSAoaW5kZXgyLS0pIHtcblx0XHR2YXIgb2xkID0gU0hBRE9XU1tpbmRleDJdO1xuXHRcdHZhciBkaWZmID0gQTJbMF0qb2xkWzFdIC0gb2xkWzBdKkEyWzFdO1xuXHRcdGlmIChkaWZmID49IDApIHsgLyogb2xkIDw9IEEyICovXG5cdFx0XHRpZiAoZGlmZiA9PSAwICYmIChpbmRleDIgJSAyKSkgeyBlZGdlMiA9IHRydWU7IH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHZhciB2aXNpYmxlID0gdHJ1ZTtcblx0aWYgKGluZGV4MSA9PSBpbmRleDIgJiYgKGVkZ2UxIHx8IGVkZ2UyKSkgeyAgLyogc3Vic2V0IG9mIGV4aXN0aW5nIHNoYWRvdywgb25lIG9mIHRoZSBlZGdlcyBtYXRjaCAqL1xuXHRcdHZpc2libGUgPSBmYWxzZTsgXG5cdH0gZWxzZSBpZiAoZWRnZTEgJiYgZWRnZTIgJiYgaW5kZXgxKzE9PWluZGV4MiAmJiAoaW5kZXgyICUgMikpIHsgLyogY29tcGxldGVseSBlcXVpdmFsZW50IHdpdGggZXhpc3Rpbmcgc2hhZG93ICovXG5cdFx0dmlzaWJsZSA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKGluZGV4MSA+IGluZGV4MiAmJiAoaW5kZXgxICUgMikpIHsgLyogc3Vic2V0IG9mIGV4aXN0aW5nIHNoYWRvdywgbm90IHRvdWNoaW5nICovXG5cdFx0dmlzaWJsZSA9IGZhbHNlO1xuXHR9XG5cdFxuXHRpZiAoIXZpc2libGUpIHsgcmV0dXJuIDA7IH0gLyogZmFzdCBjYXNlOiBub3QgdmlzaWJsZSAqL1xuXHRcblx0dmFyIHZpc2libGVMZW5ndGgsIFA7XG5cblx0LyogY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHZpc2libGUgYXJjLCBhZGp1c3QgbGlzdCBvZiBzaGFkb3dzIChpZiBibG9ja2luZykgKi9cblx0dmFyIHJlbW92ZSA9IGluZGV4Mi1pbmRleDErMTtcblx0aWYgKHJlbW92ZSAlIDIpIHtcblx0XHRpZiAoaW5kZXgxICUgMikgeyAvKiBmaXJzdCBlZGdlIHdpdGhpbiBleGlzdGluZyBzaGFkb3csIHNlY29uZCBvdXRzaWRlICovXG5cdFx0XHR2YXIgUCA9IFNIQURPV1NbaW5kZXgxXTtcblx0XHRcdHZpc2libGVMZW5ndGggPSAoQTJbMF0qUFsxXSAtIFBbMF0qQTJbMV0pIC8gKFBbMV0gKiBBMlsxXSk7XG5cdFx0XHRpZiAoYmxvY2tzKSB7IFNIQURPV1Muc3BsaWNlKGluZGV4MSwgcmVtb3ZlLCBBMik7IH1cblx0XHR9IGVsc2UgeyAvKiBzZWNvbmQgZWRnZSB3aXRoaW4gZXhpc3Rpbmcgc2hhZG93LCBmaXJzdCBvdXRzaWRlICovXG5cdFx0XHR2YXIgUCA9IFNIQURPV1NbaW5kZXgyXTtcblx0XHRcdHZpc2libGVMZW5ndGggPSAoUFswXSpBMVsxXSAtIEExWzBdKlBbMV0pIC8gKEExWzFdICogUFsxXSk7XG5cdFx0XHRpZiAoYmxvY2tzKSB7IFNIQURPV1Muc3BsaWNlKGluZGV4MSwgcmVtb3ZlLCBBMSk7IH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGluZGV4MSAlIDIpIHsgLyogYm90aCBlZGdlcyB3aXRoaW4gZXhpc3Rpbmcgc2hhZG93cyAqL1xuXHRcdFx0dmFyIFAxID0gU0hBRE9XU1tpbmRleDFdO1xuXHRcdFx0dmFyIFAyID0gU0hBRE9XU1tpbmRleDJdO1xuXHRcdFx0dmlzaWJsZUxlbmd0aCA9IChQMlswXSpQMVsxXSAtIFAxWzBdKlAyWzFdKSAvIChQMVsxXSAqIFAyWzFdKTtcblx0XHRcdGlmIChibG9ja3MpIHsgU0hBRE9XUy5zcGxpY2UoaW5kZXgxLCByZW1vdmUpOyB9XG5cdFx0fSBlbHNlIHsgLyogYm90aCBlZGdlcyBvdXRzaWRlIGV4aXN0aW5nIHNoYWRvd3MgKi9cblx0XHRcdGlmIChibG9ja3MpIHsgU0hBRE9XUy5zcGxpY2UoaW5kZXgxLCByZW1vdmUsIEExLCBBMik7IH1cblx0XHRcdHJldHVybiAxOyAvKiB3aG9sZSBhcmMgdmlzaWJsZSEgKi9cblx0XHR9XG5cdH1cblxuXHR2YXIgYXJjTGVuZ3RoID0gKEEyWzBdKkExWzFdIC0gQTFbMF0qQTJbMV0pIC8gKEExWzFdICogQTJbMV0pO1xuXG5cdHJldHVybiB2aXNpYmxlTGVuZ3RoL2FyY0xlbmd0aDtcbn1cbi8qKlxuICogQGNsYXNzIFJlY3Vyc2l2ZSBzaGFkb3djYXN0aW5nIGFsZ29yaXRobVxuICogQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgNC84IHRvcG9sb2dpZXMsIG5vdCBoZXhhZ29uYWwuXG4gKiBCYXNlZCBvbiBQZXRlciBIYXJraW5zJyBpbXBsZW1lbnRhdGlvbiBvZiBCasO2cm4gQmVyZ3N0csO2bSdzIGFsZ29yaXRobSBkZXNjcmliZWQgaGVyZTogaHR0cDovL3d3dy5yb2d1ZWJhc2luLmNvbS9pbmRleC5waHA/dGl0bGU9Rk9WX3VzaW5nX3JlY3Vyc2l2ZV9zaGFkb3djYXN0aW5nXG4gKiBAYXVnbWVudHMgUk9ULkZPVlxuICovXG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcgPSBmdW5jdGlvbihsaWdodFBhc3Nlc0NhbGxiYWNrLCBvcHRpb25zKSB7XG5cdFJPVC5GT1YuY2FsbCh0aGlzLCBsaWdodFBhc3Nlc0NhbGxiYWNrLCBvcHRpb25zKTtcbn1cblJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5leHRlbmQoUk9ULkZPVik7XG5cbi8qKiBPY3RhbnRzIHVzZWQgZm9yIHRyYW5zbGF0aW5nIHJlY3Vyc2l2ZSBzaGFkb3djYXN0aW5nIG9mZnNldHMgKi9cblJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5PQ1RBTlRTID0gW1xuXHRbLTEsICAwLCAgMCwgIDFdLFxuXHRbIDAsIC0xLCAgMSwgIDBdLFxuXHRbIDAsIC0xLCAtMSwgIDBdLFxuXHRbLTEsICAwLCAgMCwgLTFdLFxuXHRbIDEsICAwLCAgMCwgLTFdLFxuXHRbIDAsICAxLCAtMSwgIDBdLFxuXHRbIDAsICAxLCAgMSwgIDBdLFxuXHRbIDEsICAwLCAgMCwgIDFdXG5dO1xuXG4vKipcbiAqIENvbXB1dGUgdmlzaWJpbGl0eSBmb3IgYSAzNjAtZGVncmVlIGNpcmNsZVxuICogQHBhcmFtIHtpbnR9IHhcbiAqIEBwYXJhbSB7aW50fSB5XG4gKiBAcGFyYW0ge2ludH0gUiBNYXhpbXVtIHZpc2liaWxpdHkgcmFkaXVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbih4LCB5LCBSLCBjYWxsYmFjaykge1xuXHQvL1lvdSBjYW4gYWx3YXlzIHNlZSB5b3VyIG93biB0aWxlXG5cdGNhbGxiYWNrKHgsIHksIDAsIDEpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLl9yZW5kZXJPY3RhbnQoeCwgeSwgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFNbaV0sIFIsIGNhbGxiYWNrKTtcblx0fVxufVxuXG4vKipcbiAqIENvbXB1dGUgdmlzaWJpbGl0eSBmb3IgYSAxODAtZGVncmVlIGFyY1xuICogQHBhcmFtIHtpbnR9IHhcbiAqIEBwYXJhbSB7aW50fSB5XG4gKiBAcGFyYW0ge2ludH0gUiBNYXhpbXVtIHZpc2liaWxpdHkgcmFkaXVzXG4gKiBAcGFyYW0ge2ludH0gZGlyIERpcmVjdGlvbiB0byBsb29rIGluIChleHByZXNzZWQgaW4gYSBST1QuRElSUyB2YWx1ZSk7XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLmNvbXB1dGUxODAgPSBmdW5jdGlvbih4LCB5LCBSLCBkaXIsIGNhbGxiYWNrKSB7XG5cdC8vWW91IGNhbiBhbHdheXMgc2VlIHlvdXIgb3duIHRpbGVcblx0Y2FsbGJhY2soeCwgeSwgMCwgMSk7XG5cdHZhciBwcmV2aW91c09jdGFudCA9IChkaXIgLSAxICsgOCkgJSA4OyAvL05lZWQgdG8gcmV0cmlldmUgdGhlIHByZXZpb3VzIG9jdGFudCB0byByZW5kZXIgYSBmdWxsIDE4MCBkZWdyZWVzXG5cdHZhciBuZXh0UHJldmlvdXNPY3RhbnQgPSAoZGlyIC0gMiArIDgpICUgODsgLy9OZWVkIHRvIHJldHJpZXZlIHRoZSBwcmV2aW91cyB0d28gb2N0YW50cyB0byByZW5kZXIgYSBmdWxsIDE4MCBkZWdyZWVzXG5cdHZhciBuZXh0T2N0YW50ID0gKGRpcisgMSArIDgpICUgODsgLy9OZWVkIHRvIGdyYWIgdG8gbmV4dCBvY3RhbnQgdG8gcmVuZGVyIGEgZnVsbCAxODAgZGVncmVlc1xuXHR0aGlzLl9yZW5kZXJPY3RhbnQoeCwgeSwgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFNbbmV4dFByZXZpb3VzT2N0YW50XSwgUiwgY2FsbGJhY2spO1xuXHR0aGlzLl9yZW5kZXJPY3RhbnQoeCwgeSwgUk9ULkZPVi5SZWN1cnNpdmVTaGFkb3djYXN0aW5nLk9DVEFOVFNbcHJldmlvdXNPY3RhbnRdLCBSLCBjYWxsYmFjayk7XG5cdHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1tkaXJdLCBSLCBjYWxsYmFjayk7XG5cdHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1tuZXh0T2N0YW50XSwgUiwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIENvbXB1dGUgdmlzaWJpbGl0eSBmb3IgYSA5MC1kZWdyZWUgYXJjXG4gKiBAcGFyYW0ge2ludH0geFxuICogQHBhcmFtIHtpbnR9IHlcbiAqIEBwYXJhbSB7aW50fSBSIE1heGltdW0gdmlzaWJpbGl0eSByYWRpdXNcbiAqIEBwYXJhbSB7aW50fSBkaXIgRGlyZWN0aW9uIHRvIGxvb2sgaW4gKGV4cHJlc3NlZCBpbiBhIFJPVC5ESVJTIHZhbHVlKTtcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJPVC5GT1YuUmVjdXJzaXZlU2hhZG93Y2FzdGluZy5wcm90b3R5cGUuY29tcHV0ZTkwID0gZnVuY3Rpb24oeCwgeSwgUiwgZGlyLCBjYWxsYmFjaykge1xuXHQvL1lvdSBjYW4gYWx3YXlzIHNlZSB5b3VyIG93biB0aWxlXG5cdGNhbGxiYWNrKHgsIHksIDAsIDEpO1xuXHR2YXIgcHJldmlvdXNPY3RhbnQgPSAoZGlyIC0gMSArIDgpICUgODsgLy9OZWVkIHRvIHJldHJpZXZlIHRoZSBwcmV2aW91cyBvY3RhbnQgdG8gcmVuZGVyIGEgZnVsbCA5MCBkZWdyZWVzXG5cdHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1tkaXJdLCBSLCBjYWxsYmFjayk7XG5cdHRoaXMuX3JlbmRlck9jdGFudCh4LCB5LCBST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcuT0NUQU5UU1twcmV2aW91c09jdGFudF0sIFIsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgb25lIG9jdGFudCAoNDUtZGVncmVlIGFyYykgb2YgdGhlIHZpZXdzaGVkXG4gKiBAcGFyYW0ge2ludH0geFxuICogQHBhcmFtIHtpbnR9IHlcbiAqIEBwYXJhbSB7aW50fSBvY3RhbnQgT2N0YW50IHRvIGJlIHJlbmRlcmVkXG4gKiBAcGFyYW0ge2ludH0gUiBNYXhpbXVtIHZpc2liaWxpdHkgcmFkaXVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLl9yZW5kZXJPY3RhbnQgPSBmdW5jdGlvbih4LCB5LCBvY3RhbnQsIFIsIGNhbGxiYWNrKSB7XG5cdC8vUmFkaXVzIGluY3JlbWVudGVkIGJ5IDEgdG8gcHJvdmlkZSBzYW1lIGNvdmVyYWdlIGFyZWEgYXMgb3RoZXIgc2hhZG93Y2FzdGluZyByYWRpdXNlc1xuXHR0aGlzLl9jYXN0VmlzaWJpbGl0eSh4LCB5LCAxLCAxLjAsIDAuMCwgUiArIDEsIG9jdGFudFswXSwgb2N0YW50WzFdLCBvY3RhbnRbMl0sIG9jdGFudFszXSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEFjdHVhbGx5IGNhbGN1bGF0ZXMgdGhlIHZpc2liaWxpdHlcbiAqIEBwYXJhbSB7aW50fSBzdGFydFggVGhlIHN0YXJ0aW5nIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtpbnR9IHN0YXJ0WSBUaGUgc3RhcnRpbmcgWSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge2ludH0gcm93IFRoZSByb3cgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2Zsb2F0fSB2aXNTbG9wZVN0YXJ0IFRoZSBzbG9wZSB0byBzdGFydCBhdFxuICogQHBhcmFtIHtmbG9hdH0gdmlzU2xvcGVFbmQgVGhlIHNsb3BlIHRvIGVuZCBhdFxuICogQHBhcmFtIHtpbnR9IHJhZGl1cyBUaGUgcmFkaXVzIHRvIHJlYWNoIG91dCB0b1xuICogQHBhcmFtIHtpbnR9IHh4IFxuICogQHBhcmFtIHtpbnR9IHh5IFxuICogQHBhcmFtIHtpbnR9IHl4IFxuICogQHBhcmFtIHtpbnR9IHl5IFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHVzZSB3aGVuIHdlIGhpdCBhIGJsb2NrIHRoYXQgaXMgdmlzaWJsZVxuICovXG5ST1QuRk9WLlJlY3Vyc2l2ZVNoYWRvd2Nhc3RpbmcucHJvdG90eXBlLl9jYXN0VmlzaWJpbGl0eSA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCByb3csIHZpc1Nsb3BlU3RhcnQsIHZpc1Nsb3BlRW5kLCByYWRpdXMsIHh4LCB4eSwgeXgsIHl5LCBjYWxsYmFjaykge1xuXHRpZih2aXNTbG9wZVN0YXJ0IDwgdmlzU2xvcGVFbmQpIHsgcmV0dXJuOyB9XG5cdGZvcih2YXIgaSA9IHJvdzsgaSA8PSByYWRpdXM7IGkrKykge1xuXHRcdHZhciBkeCA9IC1pIC0gMTtcblx0XHR2YXIgZHkgPSAtaTtcblx0XHR2YXIgYmxvY2tlZCA9IGZhbHNlO1xuXHRcdHZhciBuZXdTdGFydCA9IDA7XG5cblx0XHQvLydSb3cnIGNvdWxkIGJlIGNvbHVtbiwgbmFtZXMgaGVyZSBhc3N1bWUgb2N0YW50IDAgYW5kIHdvdWxkIGJlIGZsaXBwZWQgZm9yIGhhbGYgdGhlIG9jdGFudHNcblx0XHR3aGlsZShkeCA8PSAwKSB7XG5cdFx0XHRkeCArPSAxO1xuXG5cdFx0XHQvL1RyYW5zbGF0ZSBmcm9tIHJlbGF0aXZlIGNvb3JkaW5hdGVzIHRvIG1hcCBjb29yZGluYXRlc1xuXHRcdFx0dmFyIG1hcFggPSBzdGFydFggKyBkeCAqIHh4ICsgZHkgKiB4eTtcblx0XHRcdHZhciBtYXBZID0gc3RhcnRZICsgZHggKiB5eCArIGR5ICogeXk7XG5cblx0XHRcdC8vUmFuZ2Ugb2YgdGhlIHJvd1xuXHRcdFx0dmFyIHNsb3BlU3RhcnQgPSAoZHggLSAwLjUpIC8gKGR5ICsgMC41KTtcblx0XHRcdHZhciBzbG9wZUVuZCA9IChkeCArIDAuNSkgLyAoZHkgLSAwLjUpO1xuXHRcdFxuXHRcdFx0Ly9JZ25vcmUgaWYgbm90IHlldCBhdCBsZWZ0IGVkZ2Ugb2YgT2N0YW50XG5cdFx0XHRpZihzbG9wZUVuZCA+IHZpc1Nsb3BlU3RhcnQpIHsgY29udGludWU7IH1cblx0XHRcdFxuXHRcdFx0Ly9Eb25lIGlmIHBhc3QgcmlnaHQgZWRnZVxuXHRcdFx0aWYoc2xvcGVTdGFydCA8IHZpc1Nsb3BlRW5kKSB7IGJyZWFrOyB9XG5cdFx0XHRcdFxuXHRcdFx0Ly9JZiBpdCdzIGluIHJhbmdlLCBpdCdzIHZpc2libGVcblx0XHRcdGlmKChkeCAqIGR4ICsgZHkgKiBkeSkgPCAocmFkaXVzICogcmFkaXVzKSkge1xuXHRcdFx0XHRjYWxsYmFjayhtYXBYLCBtYXBZLCBpLCAxKTtcblx0XHRcdH1cblx0XG5cdFx0XHRpZighYmxvY2tlZCkge1xuXHRcdFx0XHQvL0lmIHRpbGUgaXMgYSBibG9ja2luZyB0aWxlLCBjYXN0IGFyb3VuZCBpdFxuXHRcdFx0XHRpZighdGhpcy5fbGlnaHRQYXNzZXMobWFwWCwgbWFwWSkgJiYgaSA8IHJhZGl1cykge1xuXHRcdFx0XHRcdGJsb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2Nhc3RWaXNpYmlsaXR5KHN0YXJ0WCwgc3RhcnRZLCBpICsgMSwgdmlzU2xvcGVTdGFydCwgc2xvcGVTdGFydCwgcmFkaXVzLCB4eCwgeHksIHl4LCB5eSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdG5ld1N0YXJ0ID0gc2xvcGVFbmQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vS2VlcCBuYXJyb3dpbmcgaWYgc2Nhbm5pbmcgYWNyb3NzIGEgYmxvY2tcblx0XHRcdFx0aWYoIXRoaXMuX2xpZ2h0UGFzc2VzKG1hcFgsIG1hcFkpKSB7XG5cdFx0XHRcdFx0bmV3U3RhcnQgPSBzbG9wZUVuZDtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdC8vQmxvY2sgaGFzIGVuZGVkXG5cdFx0XHRcdGJsb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0dmlzU2xvcGVTdGFydCA9IG5ld1N0YXJ0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihibG9ja2VkKSB7IGJyZWFrOyB9XG5cdH1cbn1cbi8qKlxuICogQG5hbWVzcGFjZSBDb2xvciBvcGVyYXRpb25zXG4gKi9cblJPVC5Db2xvciA9IHtcblx0ZnJvbVN0cmluZzogZnVuY3Rpb24oc3RyKSB7XG5cdFx0dmFyIGNhY2hlZCwgcjtcblx0XHRpZiAoc3RyIGluIHRoaXMuX2NhY2hlKSB7XG5cdFx0XHRjYWNoZWQgPSB0aGlzLl9jYWNoZVtzdHJdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoc3RyLmNoYXJBdCgwKSA9PSBcIiNcIikgeyAvKiBoZXggcmdiICovXG5cblx0XHRcdFx0dmFyIHZhbHVlcyA9IHN0ci5tYXRjaCgvWzAtOWEtZl0vZ2kpLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBwYXJzZUludCh4LCAxNik7IH0pO1xuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PSAzKSB7XG5cdFx0XHRcdFx0Y2FjaGVkID0gdmFsdWVzLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4KjE3OyB9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykge1xuXHRcdFx0XHRcdFx0dmFsdWVzW2krMV0gKz0gMTYqdmFsdWVzW2ldO1xuXHRcdFx0XHRcdFx0dmFsdWVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FjaGVkID0gdmFsdWVzO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoKHIgPSBzdHIubWF0Y2goL3JnYlxcKChbMC05LCBdKylcXCkvaSkpKSB7IC8qIGRlY2ltYWwgcmdiICovXG5cdFx0XHRcdGNhY2hlZCA9IHJbMV0uc3BsaXQoL1xccyosXFxzKi8pLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBwYXJzZUludCh4KTsgfSk7XG5cdFx0XHR9IGVsc2UgeyAvKiBodG1sIG5hbWUgKi9cblx0XHRcdFx0Y2FjaGVkID0gWzAsIDAsIDBdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jYWNoZVtzdHJdID0gY2FjaGVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYWNoZWQuc2xpY2UoKTtcblx0fSxcblxuXHQvKipcblx0ICogQWRkIHR3byBvciBtb3JlIGNvbG9yc1xuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjFcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGFkZDogZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcblx0XHR2YXIgcmVzdWx0ID0gY29sb3IxLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdGZvciAodmFyIGo9MTtqPGFyZ3VtZW50cy5sZW5ndGg7aisrKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSArPSBhcmd1bWVudHNbal1baV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZCB0d28gb3IgbW9yZSBjb2xvcnMsIE1PRElGSUVTIEZJUlNUIEFSR1VNRU5UXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjJcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0YWRkXzogZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykge1xuXHRcdFx0Zm9yICh2YXIgaj0xO2o8YXJndW1lbnRzLmxlbmd0aDtqKyspIHtcblx0XHRcdFx0Y29sb3IxW2ldICs9IGFyZ3VtZW50c1tqXVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvbG9yMTtcblx0fSxcblxuXHQvKipcblx0ICogTXVsdGlwbHkgKG1peCkgdHdvIG9yIG1vcmUgY29sb3JzXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjJcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGNvbG9yMS5zbGljZSgpO1xuXHRcdGZvciAodmFyIGk9MDtpPDM7aSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqPTE7ajxhcmd1bWVudHMubGVuZ3RoO2orKykge1xuXHRcdFx0XHRyZXN1bHRbaV0gKj0gYXJndW1lbnRzW2pdW2ldIC8gMjU1O1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSAobWl4KSB0d28gb3IgbW9yZSBjb2xvcnMsIE1PRElGSUVTIEZJUlNUIEFSR1VNRU5UXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMVxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjJcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0bXVsdGlwbHlfOiBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuXHRcdGZvciAodmFyIGk9MDtpPDM7aSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqPTE7ajxhcmd1bWVudHMubGVuZ3RoO2orKykge1xuXHRcdFx0XHRjb2xvcjFbaV0gKj0gYXJndW1lbnRzW2pdW2ldIC8gMjU1O1xuXHRcdFx0fVxuXHRcdFx0Y29sb3IxW2ldID0gTWF0aC5yb3VuZChjb2xvcjFbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY29sb3IxO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSAoYmxlbmQpIHR3byBjb2xvcnMgd2l0aCBhIGdpdmVuIGZhY3RvclxuXHQgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcjFcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IyXG5cdCAqIEBwYXJhbSB7ZmxvYXR9IFtmYWN0b3I9MC41XSAwLi4xXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgZmFjdG9yKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7IGZhY3RvciA9IDAuNTsgfVxuXHRcdHZhciByZXN1bHQgPSBjb2xvcjEuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykge1xuXHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0gKyBmYWN0b3IqKGNvbG9yMltpXS1jb2xvcjFbaV0pKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogSW50ZXJwb2xhdGUgKGJsZW5kKSB0d28gY29sb3JzIHdpdGggYSBnaXZlbiBmYWN0b3IgaW4gSFNMIG1vZGVcblx0ICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3IxXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yMlxuXHQgKiBAcGFyYW0ge2Zsb2F0fSBbZmFjdG9yPTAuNV0gMC4uMVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119XG5cdCAqL1xuXHRpbnRlcnBvbGF0ZUhTTDogZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIsIGZhY3Rvcikge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgeyBmYWN0b3IgPSAwLjU7IH1cblx0XHR2YXIgaHNsMSA9IHRoaXMucmdiMmhzbChjb2xvcjEpO1xuXHRcdHZhciBoc2wyID0gdGhpcy5yZ2IyaHNsKGNvbG9yMik7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdGhzbDFbaV0gKz0gZmFjdG9yKihoc2wyW2ldLWhzbDFbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5oc2wycmdiKGhzbDEpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgcmFuZG9tIGNvbG9yIGJhc2VkIG9uIHRoaXMgb25lXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGRpZmYgU2V0IG9mIHN0YW5kYXJkIGRldmlhdGlvbnNcblx0ICogQHJldHVybnMge251bWJlcltdfVxuXHQgKi9cblx0cmFuZG9taXplOiBmdW5jdGlvbihjb2xvciwgZGlmZikge1xuXHRcdGlmICghKGRpZmYgaW5zdGFuY2VvZiBBcnJheSkpIHsgZGlmZiA9IE1hdGgucm91bmQoUk9ULlJORy5nZXROb3JtYWwoMCwgZGlmZikpOyB9XG5cdFx0dmFyIHJlc3VsdCA9IGNvbG9yLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdHJlc3VsdFtpXSArPSAoZGlmZiBpbnN0YW5jZW9mIEFycmF5ID8gTWF0aC5yb3VuZChST1QuUk5HLmdldE5vcm1hbCgwLCBkaWZmW2ldKSkgOiBkaWZmKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTTC4gRXhwZWN0cyAwLi4yNTUgaW5wdXRzLCBwcm9kdWNlcyAwLi4xIG91dHB1dHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdHJnYjJoc2w6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIHIgPSBjb2xvclswXS8yNTU7XG5cdFx0dmFyIGcgPSBjb2xvclsxXS8yNTU7XG5cdFx0dmFyIGIgPSBjb2xvclsyXS8yNTU7XG5cblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuXG5cdFx0aWYgKG1heCA9PSBtaW4pIHtcblx0XHRcdGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZCA9IG1heCAtIG1pbjtcblx0XHRcdHMgPSAobCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbikpO1xuXHRcdFx0c3dpdGNoKG1heCkge1xuXHRcdFx0XHRjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRoIC89IDY7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtoLCBzLCBsXTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi4gRXhwZWN0cyAwLi4xIGlucHV0cywgcHJvZHVjZXMgMC4uMjU1IG91dHB1dHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IGNvbG9yXG5cdCAqIEByZXR1cm5zIHtudW1iZXJbXX1cblx0ICovXG5cdGhzbDJyZ2I6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIGwgPSBjb2xvclsyXTtcblxuXHRcdGlmIChjb2xvclsxXSA9PSAwKSB7XG5cdFx0XHRsID0gTWF0aC5yb3VuZChsKjI1NSk7XG5cdFx0XHRyZXR1cm4gW2wsIGwsIGxdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaHVlMnJnYiA9IGZ1bmN0aW9uKHAsIHEsIHQpIHtcblx0XHRcdFx0aWYgKHQgPCAwKSB0ICs9IDE7XG5cdFx0XHRcdGlmICh0ID4gMSkgdCAtPSAxO1xuXHRcdFx0XHRpZiAodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG5cdFx0XHRcdGlmICh0IDwgMS8yKSByZXR1cm4gcTtcblx0XHRcdFx0aWYgKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IGNvbG9yWzFdO1xuXHRcdFx0dmFyIHEgPSAobCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyk7XG5cdFx0XHR2YXIgcCA9IDIgKiBsIC0gcTtcblx0XHRcdHZhciByID0gaHVlMnJnYihwLCBxLCBjb2xvclswXSArIDEvMyk7XG5cdFx0XHR2YXIgZyA9IGh1ZTJyZ2IocCwgcSwgY29sb3JbMF0pO1xuXHRcdFx0dmFyIGIgPSBodWUycmdiKHAsIHEsIGNvbG9yWzBdIC0gMS8zKTtcblx0XHRcdHJldHVybiBbTWF0aC5yb3VuZChyKjI1NSksIE1hdGgucm91bmQoZyoyNTUpLCBNYXRoLnJvdW5kKGIqMjU1KV07XG5cdFx0fVxuXHR9LFxuXG5cdHRvUkdCOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHJldHVybiBcInJnYihcIiArIHRoaXMuX2NsYW1wKGNvbG9yWzBdKSArIFwiLFwiICsgdGhpcy5fY2xhbXAoY29sb3JbMV0pICsgXCIsXCIgKyB0aGlzLl9jbGFtcChjb2xvclsyXSkgKyBcIilcIjtcblx0fSxcblxuXHR0b0hleDogZnVuY3Rpb24oY29sb3IpIHtcblx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykge1xuXHRcdFx0cGFydHMucHVzaCh0aGlzLl9jbGFtcChjb2xvcltpXSkudG9TdHJpbmcoMTYpLmxwYWQoXCIwXCIsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIFwiI1wiICsgcGFydHMuam9pbihcIlwiKTtcblx0fSxcblxuXHRfY2xhbXA6IGZ1bmN0aW9uKG51bSkge1xuXHRcdGlmIChudW0gPCAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9IGVsc2UgaWYgKG51bSA+IDI1NSkge1xuXHRcdFx0cmV0dXJuIDI1NTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bTtcblx0XHR9XG5cdH0sXG5cblx0X2NhY2hlOiB7XG5cdFx0XCJibGFja1wiOiBbMCwwLDBdLFxuXHRcdFwibmF2eVwiOiBbMCwwLDEyOF0sXG5cdFx0XCJkYXJrYmx1ZVwiOiBbMCwwLDEzOV0sXG5cdFx0XCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1XSxcblx0XHRcImJsdWVcIjogWzAsMCwyNTVdLFxuXHRcdFwiZGFya2dyZWVuXCI6IFswLDEwMCwwXSxcblx0XHRcImdyZWVuXCI6IFswLDEyOCwwXSxcblx0XHRcInRlYWxcIjogWzAsMTI4LDEyOF0sXG5cdFx0XCJkYXJrY3lhblwiOiBbMCwxMzksMTM5XSxcblx0XHRcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTVdLFxuXHRcdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5XSxcblx0XHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTRdLFxuXHRcdFwibGltZVwiOiBbMCwyNTUsMF0sXG5cdFx0XCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3XSxcblx0XHRcImFxdWFcIjogWzAsMjU1LDI1NV0sXG5cdFx0XCJjeWFuXCI6IFswLDI1NSwyNTVdLFxuXHRcdFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTJdLFxuXHRcdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NV0sXG5cdFx0XCJmb3Jlc3RncmVlblwiOiBbMzQsMTM5LDM0XSxcblx0XHRcInNlYWdyZWVuXCI6IFs0NiwxMzksODddLFxuXHRcdFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzldLFxuXHRcdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzldLFxuXHRcdFwibGltZWdyZWVuXCI6IFs1MCwyMDUsNTBdLFxuXHRcdFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTNdLFxuXHRcdFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4XSxcblx0XHRcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNV0sXG5cdFx0XCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODBdLFxuXHRcdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsNjEsMTM5XSxcblx0XHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNF0sXG5cdFx0XCJpbmRpZ29cIjogWzc1LDAsMTMwXSxcblx0XHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDddLFxuXHRcdFwiY2FkZXRibHVlXCI6IFs5NSwxNTgsMTYwXSxcblx0XHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzN10sXG5cdFx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MF0sXG5cdFx0XCJkaW1ncmF5XCI6IFsxMDUsMTA1LDEwNV0sXG5cdFx0XCJkaW1ncmV5XCI6IFsxMDUsMTA1LDEwNV0sXG5cdFx0XCJzbGF0ZWJsdWVcIjogWzEwNiw5MCwyMDVdLFxuXHRcdFwib2xpdmVkcmFiXCI6IFsxMDcsMTQyLDM1XSxcblx0XHRcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDRdLFxuXHRcdFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NF0sXG5cdFx0XCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTNdLFxuXHRcdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzXSxcblx0XHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzhdLFxuXHRcdFwibGF3bmdyZWVuXCI6IFsxMjQsMjUyLDBdLFxuXHRcdFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwXSxcblx0XHRcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyXSxcblx0XHRcIm1hcm9vblwiOiBbMTI4LDAsMF0sXG5cdFx0XCJwdXJwbGVcIjogWzEyOCwwLDEyOF0sXG5cdFx0XCJvbGl2ZVwiOiBbMTI4LDEyOCwwXSxcblx0XHRcImdyYXlcIjogWzEyOCwxMjgsMTI4XSxcblx0XHRcImdyZXlcIjogWzEyOCwxMjgsMTI4XSxcblx0XHRcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1XSxcblx0XHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LDIwNiwyNTBdLFxuXHRcdFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNl0sXG5cdFx0XCJkYXJrcmVkXCI6IFsxMzksMCwwXSxcblx0XHRcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzldLFxuXHRcdFwic2FkZGxlYnJvd25cIjogWzEzOSw2OSwxOV0sXG5cdFx0XCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzXSxcblx0XHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0XSxcblx0XHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTZdLFxuXHRcdFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExXSxcblx0XHRcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTJdLFxuXHRcdFwiZGFya29yY2hpZFwiOiBbMTUzLDUwLDIwNF0sXG5cdFx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MF0sXG5cdFx0XCJzaWVubmFcIjogWzE2MCw4Miw0NV0sXG5cdFx0XCJicm93blwiOiBbMTY1LDQyLDQyXSxcblx0XHRcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OV0sXG5cdFx0XCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjldLFxuXHRcdFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMF0sXG5cdFx0XCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0N10sXG5cdFx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOF0sXG5cdFx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LDE5NiwyMjJdLFxuXHRcdFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzBdLFxuXHRcdFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzRdLFxuXHRcdFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LDEzNCwxMV0sXG5cdFx0XCJtZWRpdW1vcmNoaWRcIjogWzE4Niw4NSwyMTFdLFxuXHRcdFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0M10sXG5cdFx0XCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3XSxcblx0XHRcInNpbHZlclwiOiBbMTkyLDE5MiwxOTJdLFxuXHRcdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzXSxcblx0XHRcImluZGlhbnJlZFwiOiBbMjA1LDkyLDkyXSxcblx0XHRcInBlcnVcIjogWzIwNSwxMzMsNjNdLFxuXHRcdFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwXSxcblx0XHRcInRhblwiOiBbMjEwLDE4MCwxNDBdLFxuXHRcdFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMV0sXG5cdFx0XCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExXSxcblx0XHRcInBhbGV2aW9sZXRyZWRcIjogWzIxNiwxMTIsMTQ3XSxcblx0XHRcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2XSxcblx0XHRcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTRdLFxuXHRcdFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyXSxcblx0XHRcImNyaW1zb25cIjogWzIyMCwyMCw2MF0sXG5cdFx0XCJnYWluc2Jvcm9cIjogWzIyMCwyMjAsMjIwXSxcblx0XHRcInBsdW1cIjogWzIyMSwxNjAsMjIxXSxcblx0XHRcImJ1cmx5d29vZFwiOiBbMjIyLDE4NCwxMzVdLFxuXHRcdFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NV0sXG5cdFx0XCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTBdLFxuXHRcdFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjJdLFxuXHRcdFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOF0sXG5cdFx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsMjMyLDE3MF0sXG5cdFx0XCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOF0sXG5cdFx0XCJraGFraVwiOiBbMjQwLDIzMCwxNDBdLFxuXHRcdFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NV0sXG5cdFx0XCJob25leWRld1wiOiBbMjQwLDI1NSwyNDBdLFxuXHRcdFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1XSxcblx0XHRcInNhbmR5YnJvd25cIjogWzI0NCwxNjQsOTZdLFxuXHRcdFwid2hlYXRcIjogWzI0NSwyMjIsMTc5XSxcblx0XHRcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMF0sXG5cdFx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NV0sXG5cdFx0XCJtaW50Y3JlYW1cIjogWzI0NSwyNTUsMjUwXSxcblx0XHRcImdob3N0d2hpdGVcIjogWzI0OCwyNDgsMjU1XSxcblx0XHRcInNhbG1vblwiOiBbMjUwLDEyOCwxMTRdLFxuXHRcdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNV0sXG5cdFx0XCJsaW5lblwiOiBbMjUwLDI0MCwyMzBdLFxuXHRcdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwXSxcblx0XHRcIm9sZGxhY2VcIjogWzI1MywyNDUsMjMwXSxcblx0XHRcInJlZFwiOiBbMjU1LDAsMF0sXG5cdFx0XCJmdWNoc2lhXCI6IFsyNTUsMCwyNTVdLFxuXHRcdFwibWFnZW50YVwiOiBbMjU1LDAsMjU1XSxcblx0XHRcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3XSxcblx0XHRcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDBdLFxuXHRcdFwidG9tYXRvXCI6IFsyNTUsOTksNzFdLFxuXHRcdFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODBdLFxuXHRcdFwiY29yYWxcIjogWzI1NSwxMjcsODBdLFxuXHRcdFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwXSxcblx0XHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMl0sXG5cdFx0XCJvcmFuZ2VcIjogWzI1NSwxNjUsMF0sXG5cdFx0XCJsaWdodHBpbmtcIjogWzI1NSwxODIsMTkzXSxcblx0XHRcInBpbmtcIjogWzI1NSwxOTIsMjAzXSxcblx0XHRcImdvbGRcIjogWzI1NSwyMTUsMF0sXG5cdFx0XCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1XSxcblx0XHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3M10sXG5cdFx0XCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODFdLFxuXHRcdFwiYmlzcXVlXCI6IFsyNTUsMjI4LDE5Nl0sXG5cdFx0XCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1XSxcblx0XHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNV0sXG5cdFx0XCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxM10sXG5cdFx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NV0sXG5cdFx0XCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzhdLFxuXHRcdFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwXSxcblx0XHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDVdLFxuXHRcdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwXSxcblx0XHRcInNub3dcIjogWzI1NSwyNTAsMjUwXSxcblx0XHRcInllbGxvd1wiOiBbMjU1LDI1NSwwXSxcblx0XHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNF0sXG5cdFx0XCJpdm9yeVwiOiBbMjU1LDI1NSwyNDBdLFxuXHRcdFwid2hpdGVcIjogWzI1NSwyNTUsMjU1XVxuXHR9XG59XG4vKipcbiAqIEBjbGFzcyBMaWdodGluZyBjb21wdXRhdGlvbiwgYmFzZWQgb24gYSB0cmFkaXRpb25hbCBGT1YgZm9yIG11bHRpcGxlIGxpZ2h0IHNvdXJjZXMgYW5kIG11bHRpcGxlIHBhc3Nlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlZmxlY3Rpdml0eUNhbGxiYWNrIENhbGxiYWNrIHRvIHJldHJpZXZlIGNlbGwgcmVmbGVjdGl2aXR5ICgwLi4xKVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnBhc3Nlcz0xXSBOdW1iZXIgb2YgcGFzc2VzLiAxIGVxdWFscyB0byBzaW1wbGUgRk9WIG9mIGFsbCBsaWdodCBzb3VyY2VzLCA+MSBtZWFucyBhICpoaWdobHkgc2ltcGxpZmllZCogcmFkaW9zaXR5LWxpa2UgYWxnb3JpdGhtLlxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmVtaXNzaW9uVGhyZXNob2xkPTEwMF0gQ2VsbHMgd2l0aCBlbWlzc2l2aXR5ID4gdGhyZXNob2xkIHdpbGwgYmUgdHJlYXRlZCBhcyBsaWdodCBzb3VyY2UgaW4gdGhlIG5leHQgcGFzcy5cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5yYW5nZT0xMF0gTWF4IGxpZ2h0IHJhbmdlXG4gKi9cblJPVC5MaWdodGluZyA9IGZ1bmN0aW9uKHJlZmxlY3Rpdml0eUNhbGxiYWNrLCBvcHRpb25zKSB7XG5cdHRoaXMuX3JlZmxlY3Rpdml0eUNhbGxiYWNrID0gcmVmbGVjdGl2aXR5Q2FsbGJhY2s7XG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0cGFzc2VzOiAxLFxuXHRcdGVtaXNzaW9uVGhyZXNob2xkOiAxMDAsXG5cdFx0cmFuZ2U6IDEwXG5cdH07XG5cdHRoaXMuX2ZvdiA9IG51bGw7XG5cblx0dGhpcy5fbGlnaHRzID0ge307XG5cdHRoaXMuX3JlZmxlY3Rpdml0eUNhY2hlID0ge307XG5cdHRoaXMuX2ZvdkNhY2hlID0ge307XG5cblx0dGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFkanVzdCBvcHRpb25zIGF0IHJ1bnRpbWVcbiAqIEBzZWUgUk9ULkxpZ2h0aW5nXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKi9cblJPVC5MaWdodGluZy5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgcCBpbiBvcHRpb25zKSB7IHRoaXMuX29wdGlvbnNbcF0gPSBvcHRpb25zW3BdOyB9XG5cdGlmIChvcHRpb25zICYmIG9wdGlvbnMucmFuZ2UpIHsgdGhpcy5yZXNldCgpOyB9XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdXNlZCBGaWVsZC1PZi1WaWV3IGFsZ29cbiAqIEBwYXJhbSB7Uk9ULkZPVn0gZm92XG4gKi9cblJPVC5MaWdodGluZy5wcm90b3R5cGUuc2V0Rk9WID0gZnVuY3Rpb24oZm92KSB7XG5cdHRoaXMuX2ZvdiA9IGZvdjtcblx0dGhpcy5fZm92Q2FjaGUgPSB7fTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogU2V0IChvciByZW1vdmUpIGEgbGlnaHQgc291cmNlXG4gKiBAcGFyYW0ge2ludH0geFxuICogQHBhcmFtIHtpbnR9IHlcbiAqIEBwYXJhbSB7bnVsbCB8fCBzdHJpbmcgfHwgbnVtYmVyWzNdfSBjb2xvclxuICovXG5ST1QuTGlnaHRpbmcucHJvdG90eXBlLnNldExpZ2h0ID0gZnVuY3Rpb24oeCwgeSwgY29sb3IpIHtcblx0dmFyIGtleSA9IHgrXCIsXCIreTtcblxuXHRpZiAoY29sb3IpIHtcblx0XHR0aGlzLl9saWdodHNba2V5XSA9ICh0eXBlb2YoY29sb3IpID09IFwic3RyaW5nXCIgPyBST1QuQ29sb3IuZnJvbVN0cmluZyhjb2xvcikgOiBjb2xvcik7XG5cdH0gZWxzZSB7XG5cdFx0ZGVsZXRlIHRoaXMuX2xpZ2h0c1trZXldO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlnaHQgc291cmNlc1xuICovXG5ST1QuTGlnaHRpbmcucHJvdG90eXBlLmNsZWFyTGlnaHRzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGlnaHRzID0ge307XG59XG5cbi8qKlxuICogUmVzZXQgdGhlIHByZS1jb21wdXRlZCB0b3BvbG9neSB2YWx1ZXMuIENhbGwgd2hlbmV2ZXIgdGhlIHVuZGVybHlpbmcgbWFwIGNoYW5nZXMgaXRzIGxpZ2h0LXBhc3NhYmlsaXR5LlxuICovXG5ST1QuTGlnaHRpbmcucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3JlZmxlY3Rpdml0eUNhY2hlID0ge307XG5cdHRoaXMuX2ZvdkNhY2hlID0ge307XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGlnaHRpbmdcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpZ2h0aW5nQ2FsbGJhY2sgV2lsbCBiZSBjYWxsZWQgd2l0aCAoeCwgeSwgY29sb3IpIGZvciBldmVyeSBsaXQgY2VsbFxuICovXG5ST1QuTGlnaHRpbmcucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihsaWdodGluZ0NhbGxiYWNrKSB7XG5cdHZhciBkb25lQ2VsbHMgPSB7fTtcblx0dmFyIGVtaXR0aW5nQ2VsbHMgPSB7fTtcblx0dmFyIGxpdENlbGxzID0ge307XG5cblx0Zm9yICh2YXIga2V5IGluIHRoaXMuX2xpZ2h0cykgeyAvKiBwcmVwYXJlIGVtaXR0ZXJzIGZvciBmaXJzdCBwYXNzICovXG5cdFx0dmFyIGxpZ2h0ID0gdGhpcy5fbGlnaHRzW2tleV07XG5cdFx0ZW1pdHRpbmdDZWxsc1trZXldID0gWzAsIDAsIDBdO1xuXHRcdFJPVC5Db2xvci5hZGRfKGVtaXR0aW5nQ2VsbHNba2V5XSwgbGlnaHQpO1xuXHR9XG5cblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fb3B0aW9ucy5wYXNzZXM7aSsrKSB7IC8qIG1haW4gbG9vcCAqL1xuXHRcdHRoaXMuX2VtaXRMaWdodChlbWl0dGluZ0NlbGxzLCBsaXRDZWxscywgZG9uZUNlbGxzKTtcblx0XHRpZiAoaSsxID09IHRoaXMuX29wdGlvbnMucGFzc2VzKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBmb3IgdGhlIGxhc3QgcGFzcyAqL1xuXHRcdGVtaXR0aW5nQ2VsbHMgPSB0aGlzLl9jb21wdXRlRW1pdHRlcnMobGl0Q2VsbHMsIGRvbmVDZWxscyk7XG5cdH1cblxuXHRmb3IgKHZhciBsaXRLZXkgaW4gbGl0Q2VsbHMpIHsgLyogbGV0IHRoZSB1c2VyIGtub3cgd2hhdCBhbmQgaG93IGlzIGxpdCAqL1xuXHRcdHZhciBwYXJ0cyA9IGxpdEtleS5zcGxpdChcIixcIik7XG5cdFx0dmFyIHggPSBwYXJzZUludChwYXJ0c1swXSk7XG5cdFx0dmFyIHkgPSBwYXJzZUludChwYXJ0c1sxXSk7XG5cdFx0bGlnaHRpbmdDYWxsYmFjayh4LCB5LCBsaXRDZWxsc1tsaXRLZXldKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENvbXB1dGUgb25lIGl0ZXJhdGlvbiBmcm9tIGFsbCBlbWl0dGluZyBjZWxsc1xuICogQHBhcmFtIHtvYmplY3R9IGVtaXR0aW5nQ2VsbHMgVGhlc2UgZW1pdCBsaWdodFxuICogQHBhcmFtIHtvYmplY3R9IGxpdENlbGxzIEFkZCBwcm9qZWN0ZWQgbGlnaHQgdG8gdGhlc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb25lQ2VsbHMgVGhlc2UgYWxyZWFkeSBlbWl0dGVkLCBmb3JiaWQgdGhlbSBmcm9tIGZ1cnRoZXIgY2FsY3VsYXRpb25zXG4gKi9cblJPVC5MaWdodGluZy5wcm90b3R5cGUuX2VtaXRMaWdodCA9IGZ1bmN0aW9uKGVtaXR0aW5nQ2VsbHMsIGxpdENlbGxzLCBkb25lQ2VsbHMpIHtcblx0Zm9yICh2YXIga2V5IGluIGVtaXR0aW5nQ2VsbHMpIHtcblx0XHR2YXIgcGFydHMgPSBrZXkuc3BsaXQoXCIsXCIpO1xuXHRcdHZhciB4ID0gcGFyc2VJbnQocGFydHNbMF0pO1xuXHRcdHZhciB5ID0gcGFyc2VJbnQocGFydHNbMV0pO1xuXHRcdHRoaXMuX2VtaXRMaWdodEZyb21DZWxsKHgsIHksIGVtaXR0aW5nQ2VsbHNba2V5XSwgbGl0Q2VsbHMpO1xuXHRcdGRvbmVDZWxsc1trZXldID0gMTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBQcmVwYXJlIGEgbGlzdCBvZiBlbWl0dGVycyBmb3IgbmV4dCBwYXNzXG4gKiBAcGFyYW0ge29iamVjdH0gbGl0Q2VsbHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb25lQ2VsbHNcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblJPVC5MaWdodGluZy5wcm90b3R5cGUuX2NvbXB1dGVFbWl0dGVycyA9IGZ1bmN0aW9uKGxpdENlbGxzLCBkb25lQ2VsbHMpIHtcblx0dmFyIHJlc3VsdCA9IHt9O1xuXG5cdGZvciAodmFyIGtleSBpbiBsaXRDZWxscykge1xuXHRcdGlmIChrZXkgaW4gZG9uZUNlbGxzKSB7IGNvbnRpbnVlOyB9IC8qIGFscmVhZHkgZW1pdHRlZCAqL1xuXG5cdFx0dmFyIGNvbG9yID0gbGl0Q2VsbHNba2V5XTtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcmVmbGVjdGl2aXR5Q2FjaGUpIHtcblx0XHRcdHZhciByZWZsZWN0aXZpdHkgPSB0aGlzLl9yZWZsZWN0aXZpdHlDYWNoZVtrZXldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBrZXkuc3BsaXQoXCIsXCIpO1xuXHRcdFx0dmFyIHggPSBwYXJzZUludChwYXJ0c1swXSk7XG5cdFx0XHR2YXIgeSA9IHBhcnNlSW50KHBhcnRzWzFdKTtcblx0XHRcdHZhciByZWZsZWN0aXZpdHkgPSB0aGlzLl9yZWZsZWN0aXZpdHlDYWxsYmFjayh4LCB5KTtcblx0XHRcdHRoaXMuX3JlZmxlY3Rpdml0eUNhY2hlW2tleV0gPSByZWZsZWN0aXZpdHk7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZmxlY3Rpdml0eSA9PSAwKSB7IGNvbnRpbnVlOyB9IC8qIHdpbGwgbm90IHJlZmxlY3QgYXQgYWxsICovXG5cblx0XHQvKiBjb21wdXRlIGVtaXNzaW9uIGNvbG9yICovXG5cdFx0dmFyIGVtaXNzaW9uID0gW107XG5cdFx0dmFyIGludGVuc2l0eSA9IDA7XG5cdFx0Zm9yICh2YXIgaT0wO2k8MztpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gTWF0aC5yb3VuZChjb2xvcltpXSpyZWZsZWN0aXZpdHkpO1xuXHRcdFx0ZW1pc3Npb25baV0gPSBwYXJ0O1xuXHRcdFx0aW50ZW5zaXR5ICs9IHBhcnQ7XG5cdFx0fVxuXHRcdGlmIChpbnRlbnNpdHkgPiB0aGlzLl9vcHRpb25zLmVtaXNzaW9uVGhyZXNob2xkKSB7IHJlc3VsdFtrZXldID0gZW1pc3Npb247IH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBvbmUgaXRlcmF0aW9uIGZyb20gb25lIGNlbGxcbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBsaXRDZWxscyBDZWxsIGRhdGEgdG8gYnkgdXBkYXRlZFxuICovXG5ST1QuTGlnaHRpbmcucHJvdG90eXBlLl9lbWl0TGlnaHRGcm9tQ2VsbCA9IGZ1bmN0aW9uKHgsIHksIGNvbG9yLCBsaXRDZWxscykge1xuXHR2YXIga2V5ID0geCtcIixcIit5O1xuXHRpZiAoa2V5IGluIHRoaXMuX2ZvdkNhY2hlKSB7XG5cdFx0dmFyIGZvdiA9IHRoaXMuX2ZvdkNhY2hlW2tleV07XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGZvdiA9IHRoaXMuX3VwZGF0ZUZPVih4LCB5KTtcblx0fVxuXG5cdGZvciAodmFyIGZvdktleSBpbiBmb3YpIHtcblx0XHR2YXIgZm9ybUZhY3RvciA9IGZvdltmb3ZLZXldO1xuXG5cdFx0aWYgKGZvdktleSBpbiBsaXRDZWxscykgeyAvKiBhbHJlYWR5IGxpdCAqL1xuXHRcdFx0dmFyIHJlc3VsdCA9IGxpdENlbGxzW2ZvdktleV07XG5cdFx0fSBlbHNlIHsgLyogbmV3bHkgbGl0ICovXG5cdFx0XHR2YXIgcmVzdWx0ID0gWzAsIDAsIDBdO1xuXHRcdFx0bGl0Q2VsbHNbZm92S2V5XSA9IHJlc3VsdDtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpPTA7aTwzO2krKykgeyByZXN1bHRbaV0gKz0gTWF0aC5yb3VuZChjb2xvcltpXSpmb3JtRmFjdG9yKTsgfSAvKiBhZGQgbGlnaHQgY29sb3IgKi9cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENvbXB1dGUgRk9WIChcImZvcm0gZmFjdG9yXCIpIGZvciBhIHBvdGVudGlhbCBsaWdodCBzb3VyY2UgYXQgW3gseV1cbiAqIEBwYXJhbSB7aW50fSB4XG4gKiBAcGFyYW0ge2ludH0geVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuUk9ULkxpZ2h0aW5nLnByb3RvdHlwZS5fdXBkYXRlRk9WID0gZnVuY3Rpb24oeCwgeSkge1xuXHR2YXIga2V5MSA9IHgrXCIsXCIreTtcblx0dmFyIGNhY2hlID0ge307XG5cdHRoaXMuX2ZvdkNhY2hlW2tleTFdID0gY2FjaGU7XG5cdHZhciByYW5nZSA9IHRoaXMuX29wdGlvbnMucmFuZ2U7XG5cdHZhciBjYiA9IGZ1bmN0aW9uKHgsIHksIHIsIHZpcykge1xuXHRcdHZhciBrZXkyID0geCtcIixcIit5O1xuXHRcdHZhciBmb3JtRmFjdG9yID0gdmlzICogKDEtci9yYW5nZSk7XG5cdFx0aWYgKGZvcm1GYWN0b3IgPT0gMCkgeyByZXR1cm47IH1cblx0XHRjYWNoZVtrZXkyXSA9IGZvcm1GYWN0b3I7XG5cdH1cblx0dGhpcy5fZm92LmNvbXB1dGUoeCwgeSwgcmFuZ2UsIGNiLmJpbmQodGhpcykpO1xuXG5cdHJldHVybiBjYWNoZTtcbn1cbi8qKlxuICogQGNsYXNzIEFic3RyYWN0IHBhdGhmaW5kZXJcbiAqIEBwYXJhbSB7aW50fSB0b1ggVGFyZ2V0IFggY29vcmRcbiAqIEBwYXJhbSB7aW50fSB0b1kgVGFyZ2V0IFkgY29vcmRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHBhc3NhYmxlQ2FsbGJhY2sgQ2FsbGJhY2sgdG8gZGV0ZXJtaW5lIG1hcCBwYXNzYWJpbGl0eVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnRvcG9sb2d5PThdXG4gKi9cblJPVC5QYXRoID0gZnVuY3Rpb24odG9YLCB0b1ksIHBhc3NhYmxlQ2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0dGhpcy5fdG9YID0gdG9YO1xuXHR0aGlzLl90b1kgPSB0b1k7XG5cdHRoaXMuX2Zyb21YID0gbnVsbDtcblx0dGhpcy5fZnJvbVkgPSBudWxsO1xuXHR0aGlzLl9wYXNzYWJsZUNhbGxiYWNrID0gcGFzc2FibGVDYWxsYmFjaztcblx0dGhpcy5fb3B0aW9ucyA9IHtcblx0XHR0b3BvbG9neTogOFxuXHR9XG5cdGZvciAodmFyIHAgaW4gb3B0aW9ucykgeyB0aGlzLl9vcHRpb25zW3BdID0gb3B0aW9uc1twXTsgfVxuXG5cdHRoaXMuX2RpcnMgPSBST1QuRElSU1t0aGlzLl9vcHRpb25zLnRvcG9sb2d5XTtcblx0aWYgKHRoaXMuX29wdGlvbnMudG9wb2xvZ3kgPT0gOCkgeyAvKiByZW9yZGVyIGRpcnMgZm9yIG1vcmUgYWVzdGhldGljIHJlc3VsdCAodmVydGljYWwvaG9yaXpvbnRhbCBmaXJzdCkgKi9cblx0XHR0aGlzLl9kaXJzID0gW1xuXHRcdFx0dGhpcy5fZGlyc1swXSxcblx0XHRcdHRoaXMuX2RpcnNbMl0sXG5cdFx0XHR0aGlzLl9kaXJzWzRdLFxuXHRcdFx0dGhpcy5fZGlyc1s2XSxcblx0XHRcdHRoaXMuX2RpcnNbMV0sXG5cdFx0XHR0aGlzLl9kaXJzWzNdLFxuXHRcdFx0dGhpcy5fZGlyc1s1XSxcblx0XHRcdHRoaXMuX2RpcnNbN11cblx0XHRdXG5cdH1cbn1cblxuLyoqXG4gKiBDb21wdXRlIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gcG9pbnRcbiAqIEBwYXJhbSB7aW50fSBmcm9tWFxuICogQHBhcmFtIHtpbnR9IGZyb21ZXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBXaWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgcGF0aCBpdGVtIHdpdGggYXJndW1lbnRzIFwieFwiIGFuZCBcInlcIlxuICovXG5ST1QuUGF0aC5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKGZyb21YLCBmcm9tWSwgY2FsbGJhY2spIHtcbn1cblxuUk9ULlBhdGgucHJvdG90eXBlLl9nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihjeCwgY3kpIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHRmb3IgKHZhciBpPTA7aTx0aGlzLl9kaXJzLmxlbmd0aDtpKyspIHtcblx0XHR2YXIgZGlyID0gdGhpcy5fZGlyc1tpXTtcblx0XHR2YXIgeCA9IGN4ICsgZGlyWzBdO1xuXHRcdHZhciB5ID0gY3kgKyBkaXJbMV07XG5cdFx0XG5cdFx0aWYgKCF0aGlzLl9wYXNzYWJsZUNhbGxiYWNrKHgsIHkpKSB7IGNvbnRpbnVlOyB9XG5cdFx0cmVzdWx0LnB1c2goW3gsIHldKTtcblx0fVxuXHRcblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGNsYXNzIFNpbXBsaWZpZWQgRGlqa3N0cmEncyBhbGdvcml0aG06IGFsbCBlZGdlcyBoYXZlIGEgdmFsdWUgb2YgMVxuICogQGF1Z21lbnRzIFJPVC5QYXRoXG4gKiBAc2VlIFJPVC5QYXRoXG4gKi9cblJPVC5QYXRoLkRpamtzdHJhID0gZnVuY3Rpb24odG9YLCB0b1ksIHBhc3NhYmxlQ2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0Uk9ULlBhdGguY2FsbCh0aGlzLCB0b1gsIHRvWSwgcGFzc2FibGVDYWxsYmFjaywgb3B0aW9ucyk7XG5cblx0dGhpcy5fY29tcHV0ZWQgPSB7fTtcblx0dGhpcy5fdG9kbyA9IFtdO1xuXHR0aGlzLl9hZGQodG9YLCB0b1ksIG51bGwpO1xufVxuUk9ULlBhdGguRGlqa3N0cmEuZXh0ZW5kKFJPVC5QYXRoKTtcblxuLyoqXG4gKiBDb21wdXRlIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gcG9pbnRcbiAqIEBzZWUgUk9ULlBhdGgjY29tcHV0ZVxuICovXG5ST1QuUGF0aC5EaWprc3RyYS5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uKGZyb21YLCBmcm9tWSwgY2FsbGJhY2spIHtcblx0dmFyIGtleSA9IGZyb21YK1wiLFwiK2Zyb21ZO1xuXHRpZiAoIShrZXkgaW4gdGhpcy5fY29tcHV0ZWQpKSB7IHRoaXMuX2NvbXB1dGUoZnJvbVgsIGZyb21ZKTsgfVxuXHRpZiAoIShrZXkgaW4gdGhpcy5fY29tcHV0ZWQpKSB7IHJldHVybjsgfVxuXHRcblx0dmFyIGl0ZW0gPSB0aGlzLl9jb21wdXRlZFtrZXldO1xuXHR3aGlsZSAoaXRlbSkge1xuXHRcdGNhbGxiYWNrKGl0ZW0ueCwgaXRlbS55KTtcblx0XHRpdGVtID0gaXRlbS5wcmV2O1xuXHR9XG59XG5cbi8qKlxuICogQ29tcHV0ZSBhIG5vbi1jYWNoZWQgdmFsdWVcbiAqL1xuUk9ULlBhdGguRGlqa3N0cmEucHJvdG90eXBlLl9jb21wdXRlID0gZnVuY3Rpb24oZnJvbVgsIGZyb21ZKSB7XG5cdHdoaWxlICh0aGlzLl90b2RvLmxlbmd0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fdG9kby5zaGlmdCgpO1xuXHRcdGlmIChpdGVtLnggPT0gZnJvbVggJiYgaXRlbS55ID09IGZyb21ZKSB7IHJldHVybjsgfVxuXHRcdFxuXHRcdHZhciBuZWlnaGJvcnMgPSB0aGlzLl9nZXROZWlnaGJvcnMoaXRlbS54LCBpdGVtLnkpO1xuXHRcdFxuXHRcdGZvciAodmFyIGk9MDtpPG5laWdoYm9ycy5sZW5ndGg7aSsrKSB7XG5cdFx0XHR2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cdFx0XHR2YXIgeCA9IG5laWdoYm9yWzBdO1xuXHRcdFx0dmFyIHkgPSBuZWlnaGJvclsxXTtcblx0XHRcdHZhciBpZCA9IHgrXCIsXCIreTtcblx0XHRcdGlmIChpZCBpbiB0aGlzLl9jb21wdXRlZCkgeyBjb250aW51ZTsgfSAvKiBhbHJlYWR5IGRvbmUgKi9cdFxuXHRcdFx0dGhpcy5fYWRkKHgsIHksIGl0ZW0pOyBcblx0XHR9XG5cdH1cbn1cblxuUk9ULlBhdGguRGlqa3N0cmEucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbih4LCB5LCBwcmV2KSB7XG5cdHZhciBvYmogPSB7XG5cdFx0eDogeCxcblx0XHR5OiB5LFxuXHRcdHByZXY6IHByZXZcblx0fVxuXHR0aGlzLl9jb21wdXRlZFt4K1wiLFwiK3ldID0gb2JqO1xuXHR0aGlzLl90b2RvLnB1c2gob2JqKTtcbn1cbi8qKlxuICogQGNsYXNzIFNpbXBsaWZpZWQgQSogYWxnb3JpdGhtOiBhbGwgZWRnZXMgaGF2ZSBhIHZhbHVlIG9mIDFcbiAqIEBhdWdtZW50cyBST1QuUGF0aFxuICogQHNlZSBST1QuUGF0aFxuICovXG5ST1QuUGF0aC5BU3RhciA9IGZ1bmN0aW9uKHRvWCwgdG9ZLCBwYXNzYWJsZUNhbGxiYWNrLCBvcHRpb25zKSB7XG5cdFJPVC5QYXRoLmNhbGwodGhpcywgdG9YLCB0b1ksIHBhc3NhYmxlQ2FsbGJhY2ssIG9wdGlvbnMpO1xuXG5cdHRoaXMuX3RvZG8gPSBbXTtcblx0dGhpcy5fZG9uZSA9IHt9O1xuXHR0aGlzLl9mcm9tWCA9IG51bGw7XG5cdHRoaXMuX2Zyb21ZID0gbnVsbDtcbn1cblJPVC5QYXRoLkFTdGFyLmV4dGVuZChST1QuUGF0aCk7XG5cbi8qKlxuICogQ29tcHV0ZSBhIHBhdGggZnJvbSBhIGdpdmVuIHBvaW50XG4gKiBAc2VlIFJPVC5QYXRoI2NvbXB1dGVcbiAqL1xuUk9ULlBhdGguQVN0YXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIGNhbGxiYWNrKSB7XG5cdHRoaXMuX3RvZG8gPSBbXTtcblx0dGhpcy5fZG9uZSA9IHt9O1xuXHR0aGlzLl9mcm9tWCA9IGZyb21YO1xuXHR0aGlzLl9mcm9tWSA9IGZyb21ZO1xuXHR0aGlzLl9hZGQodGhpcy5fdG9YLCB0aGlzLl90b1ksIG51bGwpO1xuXG5cdHdoaWxlICh0aGlzLl90b2RvLmxlbmd0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fdG9kby5zaGlmdCgpO1xuXHRcdGlmIChpdGVtLnggPT0gZnJvbVggJiYgaXRlbS55ID09IGZyb21ZKSB7IGJyZWFrOyB9XG5cdFx0dmFyIG5laWdoYm9ycyA9IHRoaXMuX2dldE5laWdoYm9ycyhpdGVtLngsIGl0ZW0ueSk7XG5cblx0XHRmb3IgKHZhciBpPTA7aTxuZWlnaGJvcnMubGVuZ3RoO2krKykge1xuXHRcdFx0dmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXHRcdFx0dmFyIHggPSBuZWlnaGJvclswXTtcblx0XHRcdHZhciB5ID0gbmVpZ2hib3JbMV07XG5cdFx0XHR2YXIgaWQgPSB4K1wiLFwiK3k7XG5cdFx0XHRpZiAoaWQgaW4gdGhpcy5fZG9uZSkgeyBjb250aW51ZTsgfVxuXHRcdFx0dGhpcy5fYWRkKHgsIHksIGl0ZW0pOyBcblx0XHR9XG5cdH1cblx0XG5cdHZhciBpdGVtID0gdGhpcy5fZG9uZVtmcm9tWCtcIixcIitmcm9tWV07XG5cdGlmICghaXRlbSkgeyByZXR1cm47IH1cblx0XG5cdHdoaWxlIChpdGVtKSB7XG5cdFx0Y2FsbGJhY2soaXRlbS54LCBpdGVtLnkpO1xuXHRcdGl0ZW0gPSBpdGVtLnByZXY7XG5cdH1cbn1cblxuUk9ULlBhdGguQVN0YXIucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbih4LCB5LCBwcmV2KSB7XG5cdHZhciBvYmogPSB7XG5cdFx0eDogeCxcblx0XHR5OiB5LFxuXHRcdHByZXY6IHByZXYsXG5cdFx0ZzogKHByZXYgPyBwcmV2LmcrMSA6IDApLFxuXHRcdGg6IHRoaXMuX2Rpc3RhbmNlKHgsIHkpXG5cdH1cblx0dGhpcy5fZG9uZVt4K1wiLFwiK3ldID0gb2JqO1xuXHRcblx0LyogaW5zZXJ0IGludG8gcHJpb3JpdHkgcXVldWUgKi9cblx0XG5cdHZhciBmID0gb2JqLmcgKyBvYmouaDtcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy5fdG9kby5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLl90b2RvW2ldO1xuXHRcdGlmIChmIDwgaXRlbS5nICsgaXRlbS5oKSB7XG5cdFx0XHR0aGlzLl90b2RvLnNwbGljZShpLCAwLCBvYmopO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRcblx0dGhpcy5fdG9kby5wdXNoKG9iaik7XG59XG5cblJPVC5QYXRoLkFTdGFyLnByb3RvdHlwZS5fZGlzdGFuY2UgPSBmdW5jdGlvbih4LCB5KSB7XG5cdHN3aXRjaCAodGhpcy5fb3B0aW9ucy50b3BvbG9neSkge1xuXHRcdGNhc2UgNDpcblx0XHRcdHJldHVybiAoTWF0aC5hYnMoeC10aGlzLl9mcm9tWCkgKyBNYXRoLmFicyh5LXRoaXMuX2Zyb21ZKSk7XG5cdFx0YnJlYWs7XG5cblx0XHRjYXNlIDY6XG5cdFx0XHR2YXIgZHggPSBNYXRoLmFicyh4IC0gdGhpcy5fZnJvbVgpO1xuXHRcdFx0dmFyIGR5ID0gTWF0aC5hYnMoeSAtIHRoaXMuX2Zyb21ZKTtcblx0XHRcdHJldHVybiBkeSArIE1hdGgubWF4KDAsIChkeC1keSkvMik7XG5cdFx0YnJlYWs7XG5cblx0XHRjYXNlIDg6IFxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKHgtdGhpcy5fZnJvbVgpLCBNYXRoLmFicyh5LXRoaXMuX2Zyb21ZKSk7XG5cdFx0YnJlYWs7XG5cdH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHRvcG9sb2d5XCIpO1xufVxuLyoqXG4gKiBAY2xhc3MgVGVybWluYWwgYmFja2VuZFxuICogQHByaXZhdGVcbiAqL1xuUk9ULkRpc3BsYXkuVGVybSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0Uk9ULkRpc3BsYXkuQmFja2VuZC5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXHR0aGlzLl9jeCA9IC0xO1xuXHR0aGlzLl9jeSA9IC0xO1xuXHR0aGlzLl9sYXN0Q29sb3IgPSBcIlwiO1xuXHR0aGlzLl9vcHRpb25zID0ge307XG5cdHRoaXMuX294ID0gMDtcblx0dGhpcy5fb3kgPSAwO1xuXHR0aGlzLl90ZXJtY29sb3IgPSB7fTtcbn1cblJPVC5EaXNwbGF5LlRlcm0uZXh0ZW5kKFJPVC5EaXNwbGF5LkJhY2tlbmQpO1xuXG5ST1QuRGlzcGxheS5UZXJtLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblx0dGhpcy5fb3ggPSBNYXRoLmZsb29yKChwcm9jZXNzLnN0ZG91dC5jb2x1bW5zIC0gb3B0aW9ucy53aWR0aCkgLyAyKTtcblx0dGhpcy5fb3kgPSBNYXRoLmZsb29yKChwcm9jZXNzLnN0ZG91dC5yb3dzIC0gb3B0aW9ucy5oZWlnaHQpIC8gMik7XG5cdHRoaXMuX3Rlcm1jb2xvciA9IG5ldyBST1QuRGlzcGxheS5UZXJtW29wdGlvbnMudGVybUNvbG9yLmNhcGl0YWxpemUoKV0odGhpcy5fY29udGV4dCk7XG5cdHRoaXMuX2NvbnRleHQuX3Rlcm1jb2xvciA9IHRoaXMuX3Rlcm1jb2xvcjtcbn1cblxuUk9ULkRpc3BsYXkuVGVybS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGRhdGEsIGNsZWFyQmVmb3JlKSB7XG5cdC8vIGRldGVybWluZSB3aGVyZSB0byBkcmF3IHdoYXQgd2l0aCB3aGF0IGNvbG9yc1xuXHR2YXIgeCA9IGRhdGFbMF07XG5cdHZhciB5ID0gZGF0YVsxXTtcblx0dmFyIGNoID0gZGF0YVsyXTtcblx0dmFyIGZnID0gZGF0YVszXTtcblx0dmFyIGJnID0gZGF0YVs0XTtcblxuXHQvLyBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBtb3ZlIHRoZSB0ZXJtaW5hbCBjdXJzb3Jcblx0dmFyIGR4ID0gdGhpcy5fb3ggKyB4O1xuXHR2YXIgZHkgPSB0aGlzLl9veSArIHk7XG5cdGlmIChkeCA8IDAgfHwgZHggPj0gcHJvY2Vzcy5zdGRvdXQuY29sdW1ucykgeyByZXR1cm47IH1cblx0aWYgKGR5IDwgMCB8fCBkeSA+PSBwcm9jZXNzLnN0ZG91dC5yb3dzKSB7IHJldHVybjsgfVxuXHRpZiAoZHggIT09IHRoaXMuX2N4IHx8IGR5ICE9PSB0aGlzLl9jeSkge1xuXHRcdHByb2Nlc3Muc3Rkb3V0LndyaXRlKHRoaXMuX3Rlcm1jb2xvci5wb3NpdGlvblRvQW5zaShkeCxkeSkpO1xuXHRcdHRoaXMuX2N4ID0gZHg7XG5cdFx0dGhpcy5fY3kgPSBkeTtcblx0fVxuXG5cdC8vIHRlcm1pbmFscyBhdXRvbWF0aWNhbGx5IGNsZWFyLCBidXQgaWYgd2UncmUgY2xlYXJpbmcgd2hlbiB3ZSdyZVxuXHQvLyBub3Qgb3RoZXJ3aXNlIHByb3ZpZGVkIHdpdGggYSBjaGFyYWN0ZXIsIGp1c3QgdXNlIGEgc3BhY2UgaW5zdGVhZFxuXHRpZiAoY2xlYXJCZWZvcmUpIHtcblx0XHRpZiAoIWNoKSB7XG5cdFx0XHRjaCA9IFwiIFwiO1xuXHRcdH1cblx0fVxuXHRcdFxuXHQvLyBpZiB3ZSdyZSBub3QgY2xlYXJpbmcgYW5kIG5vdCBwcm92aWRlZCB3aXRoIGEgY2hhcmFjdGVyLCBkbyBub3RoaW5nXG5cdGlmICghY2gpIHsgcmV0dXJuOyB9XG5cblx0Ly8gZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIGNvbG9yc1xuXHR2YXIgbmV3Q29sb3IgPSB0aGlzLl90ZXJtY29sb3IuY29sb3JUb0Fuc2koZmcsYmcpO1xuXHRpZiAobmV3Q29sb3IgIT09IHRoaXMuX2xhc3RDb2xvcikge1xuXHRcdHByb2Nlc3Muc3Rkb3V0LndyaXRlKG5ld0NvbG9yKTtcblx0XHR0aGlzLl9sYXN0Q29sb3IgPSBuZXdDb2xvcjtcblx0fVxuXG5cdC8vIHdyaXRlIHRoZSBwcm92aWRlZCBzeW1ib2wgdG8gdGhlIGRpc3BsYXlcblx0dmFyIGNoYXJzID0gW10uY29uY2F0KGNoKTtcblx0cHJvY2Vzcy5zdGRvdXQud3JpdGUoY2hhcnNbMF0pO1xuXG5cdC8vIHVwZGF0ZSBvdXIgcG9zaXRpb24sIGdpdmVuIHRoYXQgd2Ugd3JvdGUgYSBjaGFyYWN0ZXJcblx0dGhpcy5fY3grKztcblx0aWYgKHRoaXMuX2N4ID49IHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMpIHtcblx0XHR0aGlzLl9jeCA9IDA7XG5cdFx0dGhpcy5fY3krKztcblx0fVxufVxuXG5ST1QuRGlzcGxheS5UZXJtLnByb3RvdHlwZS5jb21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KSB7XG5cdHJldHVybiBbcHJvY2Vzcy5zdGRvdXQuY29sdW1ucywgcHJvY2Vzcy5zdGRvdXQucm93c107XG59XG5cblJPVC5EaXNwbGF5LlRlcm0ucHJvdG90eXBlLmNvbXB1dGVGb250U2l6ZSA9IGZ1bmN0aW9uKGF2YWlsV2lkdGgsIGF2YWlsSGVpZ2h0KSB7XG5cdHJldHVybiAxMjtcbn1cblxuUk9ULkRpc3BsYXkuVGVybS5wcm90b3R5cGUuZXZlbnRUb1Bvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuXHRyZXR1cm4gW3gseV1cbn1cbi8qKlxuICogQGNsYXNzIEFic3RyYWN0IHRlcm1pbmFsIGNvZGUgbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5ST1QuRGlzcGxheS5UZXJtLkNvbG9yID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUk9ULkRpc3BsYXkuVGVybS5Db2xvci5wcm90b3R5cGUuY2xlYXJUb0Fuc2kgPSBmdW5jdGlvbihiZykge1xufVxuXG5ST1QuRGlzcGxheS5UZXJtLkNvbG9yLnByb3RvdHlwZS5jb2xvclRvQW5zaSA9IGZ1bmN0aW9uKGZnLCBiZykge1xufVxuXG5ST1QuRGlzcGxheS5UZXJtLkNvbG9yLnByb3RvdHlwZS5wb3NpdGlvblRvQW5zaSA9IGZ1bmN0aW9uKHgsIHkpIHtcbn1cbi8qKlxuICogQGNsYXNzIHh0ZXJtIHRlcm1pbmFsIGNvZGUgbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICovXG5ST1QuRGlzcGxheS5UZXJtLlh0ZXJtID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRST1QuRGlzcGxheS5UZXJtLkNvbG9yLmNhbGwodGhpcywgY29udGV4dCk7XG59XG5ST1QuRGlzcGxheS5UZXJtLlh0ZXJtLmV4dGVuZChST1QuRGlzcGxheS5UZXJtLkNvbG9yKTtcblxuUk9ULkRpc3BsYXkuVGVybS5YdGVybS5wcm90b3R5cGUuY2xlYXJUb0Fuc2kgPSBmdW5jdGlvbihiZykge1xuXHRyZXR1cm4gXCJcXHgxYlswOzQ4OzU7XCJcblx0XHQrIHRoaXMuX3Rlcm1jb2xvcihiZylcblx0XHQrIFwibVxceDFiWzJKXCI7XG59XG5cblJPVC5EaXNwbGF5LlRlcm0uWHRlcm0ucHJvdG90eXBlLmNvbG9yVG9BbnNpID0gZnVuY3Rpb24oZmcsIGJnKSB7XG5cdHJldHVybiBcIlxceDFiWzA7Mzg7NTtcIlxuXHRcdCsgdGhpcy5fdGVybWNvbG9yKGZnKVxuXHRcdCsgXCI7NDg7NTtcIlxuXHRcdCsgdGhpcy5fdGVybWNvbG9yKGJnKVxuXHRcdCsgXCJtXCI7XG59XG5cblJPVC5EaXNwbGF5LlRlcm0uWHRlcm0ucHJvdG90eXBlLnBvc2l0aW9uVG9BbnNpID0gZnVuY3Rpb24oeCwgeSkge1xuXHRyZXR1cm4gXCJcXHgxYltcIiArICh5KzEpICsgXCI7XCIgKyAoeCsxKSArIFwiSFwiO1xufVxuXG5ST1QuRGlzcGxheS5UZXJtLlh0ZXJtLnByb3RvdHlwZS5fdGVybWNvbG9yID0gZnVuY3Rpb24oY29sb3IpIHtcblx0dmFyIFNSQ19DT0xPUlMgPSAyNTYuMDtcblx0dmFyIERTVF9DT0xPUlMgPSA2LjA7XG5cdHZhciBDT0xPUl9SQVRJTyA9IERTVF9DT0xPUlMgLyBTUkNfQ09MT1JTO1xuXHR2YXIgcmdiID0gUk9ULkNvbG9yLmZyb21TdHJpbmcoY29sb3IpO1xuXHR2YXIgciA9IE1hdGguZmxvb3IocmdiWzBdICogQ09MT1JfUkFUSU8pO1xuXHR2YXIgZyA9IE1hdGguZmxvb3IocmdiWzFdICogQ09MT1JfUkFUSU8pO1xuXHR2YXIgYiA9IE1hdGguZmxvb3IocmdiWzJdICogQ09MT1JfUkFUSU8pO1xuXHRyZXR1cm4gciozNiArIGcqNiArIGIqMSArIDE2O1xufVxuLyoqXG4gKiBFeHBvcnQgdG8gTm9kZS5qcyBtb2R1bGVcbiAqL1xuZm9yICh2YXIgcCBpbiBST1QpIHtcblx0ZXhwb3J0c1twXSA9IFJPVFtwXTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcm90LWpzL2xpYi9yb3QuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ../~/process/browser.js ***!
  \*******************************/
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz8yODZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */,
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/***/ (function(module, exports, __webpack_require__) {

eval("var Game = __webpack_require__(/*! ./Game */ 6);\n\nGame.init();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC5qcz9kOGVlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBHYW1lID0gcmVxdWlyZSgnLi9HYW1lJyk7XG5cbkdhbWUuaW5pdCgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!*****************!*\
  !*** ./Game.js ***!
  \*****************/
/***/ (function(module, exports, __webpack_require__) {

eval("var ROT = __webpack_require__(/*! rot-js */ 2);\n\nvar Game = {\n    display: null,\n\tmap: {},\n \n    init: function() {\n\t\tthis.display = new ROT.Display();\n        document.body.appendChild(this.display.getContainer());\n\n        this._generateMap();\n    },\n\n    _generateMap: function() {\n        var digger = new ROT.Map.Digger();\n        var freeCells = [];\n\n        var digCallback = function(x, y, value) {\n            if (value) {\n                return;\n            }\n\n            var key = x + \",\" + y;\n            this.map[key] = \".\";\n            freeCells.push(key);\n        }\n        digger.create(digCallback.bind(this));\n\n        this._generateBoxes(freeCells);\n        this._drawWholeMap();\n    },\n\n    _generateBoxes: function(freeCells) {\n        for (var i = 0; i < 10; i++) {\n            var index = Math.floor(ROT.RNG.getUniform() * freeCells.length);\n            var key = freeCells.splice(index, 1)[0];\n            this.map[key] = \"*\";\n        }\n    },\n\n    _drawWholeMap: function() {\n        for (var key in this.map) {\n            var parts = key.split(\",\");\n            var x = parseInt(parts[0]);\n            var y = parseInt(parts[1]);\n            this.display.draw(x, y, this.map[key]);\n        }\n    }\n}\n\nmodule.exports = Game;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL0dhbWUuanM/ZmUxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUk9UID0gcmVxdWlyZSgncm90LWpzJyk7XG5cbnZhciBHYW1lID0ge1xuICAgIGRpc3BsYXk6IG51bGwsXG5cdG1hcDoge30sXG4gXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kaXNwbGF5ID0gbmV3IFJPVC5EaXNwbGF5KCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kaXNwbGF5LmdldENvbnRhaW5lcigpKTtcblxuICAgICAgICB0aGlzLl9nZW5lcmF0ZU1hcCgpO1xuICAgIH0sXG5cbiAgICBfZ2VuZXJhdGVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGlnZ2VyID0gbmV3IFJPVC5NYXAuRGlnZ2VyKCk7XG4gICAgICAgIHZhciBmcmVlQ2VsbHMgPSBbXTtcblxuICAgICAgICB2YXIgZGlnQ2FsbGJhY2sgPSBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIga2V5ID0geCArIFwiLFwiICsgeTtcbiAgICAgICAgICAgIHRoaXMubWFwW2tleV0gPSBcIi5cIjtcbiAgICAgICAgICAgIGZyZWVDZWxscy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlnZ2VyLmNyZWF0ZShkaWdDYWxsYmFjay5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9nZW5lcmF0ZUJveGVzKGZyZWVDZWxscyk7XG4gICAgICAgIHRoaXMuX2RyYXdXaG9sZU1hcCgpO1xuICAgIH0sXG5cbiAgICBfZ2VuZXJhdGVCb3hlczogZnVuY3Rpb24oZnJlZUNlbGxzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcihST1QuUk5HLmdldFVuaWZvcm0oKSAqIGZyZWVDZWxscy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGZyZWVDZWxscy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgdGhpcy5tYXBba2V5XSA9IFwiKlwiO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kcmF3V2hvbGVNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5tYXApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGtleS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KHBhcnRzWzBdKTtcbiAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQocGFydHNbMV0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5LmRyYXcoeCwgeSwgdGhpcy5tYXBba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vR2FtZS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);